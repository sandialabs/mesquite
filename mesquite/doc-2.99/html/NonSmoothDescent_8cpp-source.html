<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>MESQUITE: NonSmoothDescent.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>NonSmoothDescent.cpp</h1><a href="NonSmoothDescent_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* ***************************************************************** </span>
<a name="l00002"></a>00002 <span class="comment">    MESQUITE -- The Mesh Quality Improvement Toolkit</span>
<a name="l00003"></a>00003 <span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment">    Copyright 2004 Sandia Corporation and Argonne National</span>
<a name="l00005"></a>00005 <span class="comment">    Laboratory.  Under the terms of Contract DE-AC04-94AL85000 </span>
<a name="l00006"></a>00006 <span class="comment">    with Sandia Corporation, the U.S. Government retains certain </span>
<a name="l00007"></a>00007 <span class="comment">    rights in this software.</span>
<a name="l00008"></a>00008 <span class="comment"></span>
<a name="l00009"></a>00009 <span class="comment">    This library is free software; you can redistribute it and/or</span>
<a name="l00010"></a>00010 <span class="comment">    modify it under the terms of the GNU Lesser General Public</span>
<a name="l00011"></a>00011 <span class="comment">    License as published by the Free Software Foundation; either</span>
<a name="l00012"></a>00012 <span class="comment">    version 2.1 of the License, or (at your option) any later version.</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">    This library is distributed in the hope that it will be useful,</span>
<a name="l00015"></a>00015 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00016"></a>00016 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00017"></a>00017 <span class="comment">    Lesser General Public License for more details.</span>
<a name="l00018"></a>00018 <span class="comment"></span>
<a name="l00019"></a>00019 <span class="comment">    You should have received a copy of the GNU Lesser General Public License </span>
<a name="l00020"></a>00020 <span class="comment">    (lgpl.txt) along with this library; if not, write to the Free Software</span>
<a name="l00021"></a>00021 <span class="comment">    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<a name="l00022"></a>00022 <span class="comment"> </span>
<a name="l00023"></a>00023 <span class="comment">    diachin2@llnl.gov, djmelan@sandia.gov, mbrewer@sandia.gov, </span>
<a name="l00024"></a>00024 <span class="comment">    pknupp@sandia.gov, tleurent@mcs.anl.gov, tmunson@mcs.anl.gov      </span>
<a name="l00025"></a>00025 <span class="comment">   </span>
<a name="l00026"></a>00026 <span class="comment">  ***************************************************************** */</span>
<a name="l00027"></a>00027 <span class="comment">// -*- Mode : c++; tab-width: 3; c-tab-always-indent: t; indent-tabs-mode: nil; c-basic-offset: 3 -*-</span>
<a name="l00028"></a>00028 
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include "<a class="code" href="NonSmoothDescent_8hpp.html">NonSmoothDescent.hpp</a>"</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include "<a class="code" href="MsqTimer_8hpp.html">MsqTimer.hpp</a>"</span>
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="preprocessor">#undef NUMERICAL_GRADIENT</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span>
<a name="l00043"></a>00043 <span class="keyword">namespace </span><a class="code" href="mesquite__version_8h.html#5369e4b5c018c90ed6aa26daf172f006">MESQUITE_NS</a> {
<a name="l00044"></a>00044 
<a name="l00045"></a><a class="code" href="namespaceMesquite.html#27308dfd82a6c76f4c3075ac5af1b464">00045</a> <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespaceMesquite.html#27308dfd82a6c76f4c3075ac5af1b464">EPSILON</a> = 1e-16;
<a name="l00046"></a><a class="code" href="namespaceMesquite.html#36d95041ba906e07b70bb395358e4443">00046</a> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="namespaceMesquite.html#36d95041ba906e07b70bb395358e4443">MSQ_MAX_OPT_ITER</a> = 20;
<a name="l00047"></a>00047 
<a name="l00048"></a><a class="code" href="namespaceMesquite.html#b08a3b2c2d4b869dc6b91498bf112c5f">00048</a> <span class="keyword">enum</span> <a class="code" href="namespaceMesquite.html#b08a3b2c2d4b869dc6b91498bf112c5f">Rotate</a> {
<a name="l00049"></a>00049   <a class="code" href="namespaceMesquite.html#b08a3b2c2d4b869dc6b91498bf112c5f386e97e4eebb1f8daefda9375a376006">COUNTERCLOCKWISE</a> = 1,
<a name="l00050"></a>00050   <a class="code" href="namespaceMesquite.html#b08a3b2c2d4b869dc6b91498bf112c5f3c9f055c37d071417e2dc70fcb1b0d02">CLOCKWISE</a> = 0
<a name="l00051"></a>00051 };
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 
<a name="l00054"></a><a class="code" href="classMesquite_1_1NonSmoothDescent.html#fa3a82cdc7adb784b5b0385611ddcb7e">00054</a> NonSmoothDescent::NonSmoothDescent(<a class="code" href="classMesquite_1_1QualityMetric.html">QualityMetric</a>* qm)
<a name="l00055"></a>00055   : currentQM(qm)
<a name="l00056"></a>00056 {
<a name="l00057"></a>00057 
<a name="l00058"></a>00058   <a class="code" href="group__debug.html#gc1fb4ac3396b35008642ebd22e1b4d02">MSQ_DBGOUT</a>(1) &lt;&lt; <span class="stringliteral">"- Executed NonSmoothDescent::NonSmoothDescent()\n"</span>;
<a name="l00059"></a>00059 }  
<a name="l00060"></a>00060 
<a name="l00061"></a><a class="code" href="classMesquite_1_1NonSmoothDescent.html#c0f111431cb8af16d070c8cae6b3efbe">00061</a> std::string <a class="code" href="classMesquite_1_1NonSmoothDescent.html#c0f111431cb8af16d070c8cae6b3efbe">NonSmoothDescent::get_name</a>()<span class="keyword"> const</span>
<a name="l00062"></a>00062 <span class="keyword">  </span>{ <span class="keywordflow">return</span> <span class="stringliteral">"NonSmoothDescent"</span>; }
<a name="l00063"></a>00063 
<a name="l00064"></a><a class="code" href="classMesquite_1_1NonSmoothDescent.html#399f5db8ae02a35300444070f3f856c6">00064</a> <a class="code" href="classMesquite_1_1PatchSet.html">PatchSet</a>* <a class="code" href="classMesquite_1_1NonSmoothDescent.html#399f5db8ae02a35300444070f3f856c6">NonSmoothDescent::get_patch_set</a>()
<a name="l00065"></a>00065   { <span class="keywordflow">return</span> &amp;patchSet; }
<a name="l00066"></a>00066   
<a name="l00067"></a><a class="code" href="classMesquite_1_1NonSmoothDescent.html#c12a229963ebddb3b22a479894b2ba7d">00067</a> <span class="keywordtype">void</span> <a class="code" href="classMesquite_1_1NonSmoothDescent.html#c12a229963ebddb3b22a479894b2ba7d">NonSmoothDescent::initialize</a>(PatchData &amp;<span class="comment">/*pd*/</span>, <a class="code" href="classMesquite_1_1MsqError.html">MsqError</a> &amp;err)
<a name="l00068"></a>00068 {
<a name="l00069"></a>00069   minStepSize = 1e-6;
<a name="l00070"></a>00070   <a class="code" href="group__debug.html#gc1fb4ac3396b35008642ebd22e1b4d02">MSQ_DBGOUT</a>(1) &lt;&lt; <span class="stringliteral">"- Executed NonSmoothDescent::initialize()\n"</span>;
<a name="l00071"></a>00071 }
<a name="l00072"></a>00072 
<a name="l00073"></a><a class="code" href="classMesquite_1_1NonSmoothDescent.html#4546e729ac7a3cc7ea1db5712f064e1c">00073</a> <span class="keywordtype">void</span> <a class="code" href="classMesquite_1_1NonSmoothDescent.html#4546e729ac7a3cc7ea1db5712f064e1c">NonSmoothDescent::initialize_mesh_iteration</a>(PatchData &amp;<span class="comment">/*pd*/</span>,
<a name="l00074"></a>00074                                                          <a class="code" href="classMesquite_1_1MsqError.html">MsqError</a> &amp;<span class="comment">/*err*/</span>)
<a name="l00075"></a>00075 {
<a name="l00076"></a>00076 }
<a name="l00077"></a><a class="code" href="classMesquite_1_1NonSmoothDescent.html#56753d3f1cf3710a2757c5b371879c26">00077</a> <span class="keywordtype">void</span> <a class="code" href="classMesquite_1_1NonSmoothDescent.html#56753d3f1cf3710a2757c5b371879c26">NonSmoothDescent::optimize_vertex_positions</a>(PatchData &amp;pd, 
<a name="l00078"></a>00078                                                 <a class="code" href="classMesquite_1_1MsqError.html">MsqError</a> &amp;err)
<a name="l00079"></a>00079 {
<a name="l00080"></a>00080   <a class="code" href="MsqTimer_8hpp.html#605f98d565a626d6fba847fa56ea8a1e">MSQ_FUNCTION_TIMER</a>( <span class="stringliteral">"NonSmoothDescent"</span> );
<a name="l00081"></a>00081 
<a name="l00082"></a>00082   <span class="comment">//  cout &lt;&lt; "- Executing NonSmoothDescent::optimize_node_positions()\n";</span>
<a name="l00083"></a>00083   <span class="comment">/* perform the min max smoothing algorithm */</span>
<a name="l00084"></a>00084   <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(2)(<span class="stringliteral">"\nInitializing the patch iteration\n"</span>);
<a name="l00085"></a>00085 
<a name="l00086"></a>00086   <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"Number of Vertices: %d\n"</span>,(int)pd.num_nodes());
<a name="l00087"></a>00087   <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"Number of Elements: %d\n"</span>,(int)pd.num_elements());
<a name="l00088"></a>00088     <span class="comment">//Michael: Note: is this a reliable way to get the dimension?</span>
<a name="l00089"></a>00089   <span class="comment">// NOTE: Mesquite only does 3-dimensional (including surface) meshes.</span>
<a name="l00090"></a>00090   <span class="comment">// mDimension = pd.get_mesh()-&gt;get_geometric_dimension(err); MSQ_ERRRTN(err);</span>
<a name="l00091"></a>00091   <span class="comment">// MSQ_PRINT(3)("Spatial Dimension: %d\n",mDimension);</span>
<a name="l00092"></a>00092   <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"Spatial Dimension: 3\n"</span>);
<a name="l00093"></a>00093 
<a name="l00094"></a>00094   <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"Num Free = %d\n"</span>,(int)pd.num_free_vertices());
<a name="l00095"></a>00095 
<a name="l00096"></a>00096   MsqFreeVertexIndexIterator free_iter(pd, err); <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l00097"></a>00097   free_iter.reset();
<a name="l00098"></a>00098   free_iter.next(); 
<a name="l00099"></a>00099   freeVertexIndex = free_iter.value();
<a name="l00100"></a>00100   <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"Free Vertex Index = %lu\n"</span>,(<span class="keywordtype">unsigned</span> long)freeVertexIndex);
<a name="l00101"></a>00101 
<a name="l00102"></a>00102   <span class="comment">// TODO - need to switch to validity via metric evaluations should</span>
<a name="l00103"></a>00103   <span class="comment">// be associated with the compute_function somehow</span>
<a name="l00104"></a>00104   <span class="comment">/* check for an invalid mesh; if it's invalid return and ask the user </span>
<a name="l00105"></a>00105 <span class="comment">     to use untangle */</span>
<a name="l00106"></a>00106   <span class="keywordflow">if</span> (!this-&gt;validity_check(pd,err)) {
<a name="l00107"></a>00107       <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(1)(<span class="stringliteral">"ERROR: Invalid mesh\n"</span>);
<a name="l00108"></a>00108       <a class="code" href="group__error.html#g2a2fbc6c2b94ad06a287ec11ea469868">MSQ_SETERR</a>(err)(<span class="stringliteral">"Invalid Mesh: Use untangle to create a valid "</span>
<a name="l00109"></a>00109                       <span class="stringliteral">"triangulation"</span>, <a class="code" href="classMesquite_1_1MsqError.html#1d7c4cd95eccb8d09c39504ff0c2ec0b0f0d34ca5ee885772c3a45bd98725e0b">MsqError::INVALID_MESH</a>);
<a name="l00110"></a>00110       <span class="keywordflow">return</span>;
<a name="l00111"></a>00111   }
<a name="l00112"></a>00112 
<a name="l00113"></a>00113   <span class="comment">/* initialize the optimization data up to numFunctionValues */</span>
<a name="l00114"></a>00114   this-&gt;init_opt(pd,err); <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l00115"></a>00115   this-&gt;init_max_step_length(pd,err);  <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l00116"></a>00116   <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"Done initializing optimization\n"</span>);
<a name="l00117"></a>00117 
<a name="l00118"></a>00118   <span class="comment">/* compute the initial function values */</span>
<a name="l00119"></a>00119   <span class="comment">//TODO this should return a bool with the validity</span>
<a name="l00120"></a>00120   this-&gt;compute_function(&amp;pd, originalFunction, err);  <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l00121"></a>00121  
<a name="l00122"></a>00122   <span class="comment">// find the initial active set</span>
<a name="l00123"></a>00123   this-&gt;find_active_set(originalFunction, mActive);
<a name="l00124"></a>00124 
<a name="l00125"></a>00125   this-&gt;minmax_opt(pd,err);  <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l00126"></a>00126 }
<a name="l00127"></a>00127 
<a name="l00128"></a>00128 
<a name="l00129"></a><a class="code" href="classMesquite_1_1NonSmoothDescent.html#56303439d2e71dc103de9e789a556376">00129</a> <span class="keywordtype">void</span> <a class="code" href="classMesquite_1_1NonSmoothDescent.html#56303439d2e71dc103de9e789a556376">NonSmoothDescent::terminate_mesh_iteration</a>( PatchData &amp;<span class="comment">/*pd*/</span>,
<a name="l00130"></a>00130                                                  <a class="code" href="classMesquite_1_1MsqError.html">MsqError</a> &amp;<span class="comment">/*err*/</span>)
<a name="l00131"></a>00131 {
<a name="l00132"></a>00132 }
<a name="l00133"></a>00133   
<a name="l00134"></a><a class="code" href="classMesquite_1_1NonSmoothDescent.html#a7db668eac75059074e8450a34aeef3d">00134</a> <span class="keywordtype">void</span> <a class="code" href="classMesquite_1_1NonSmoothDescent.html#a7db668eac75059074e8450a34aeef3d">NonSmoothDescent::cleanup</a>()
<a name="l00135"></a>00135 {
<a name="l00136"></a>00136   <a class="code" href="group__debug.html#gc1fb4ac3396b35008642ebd22e1b4d02">MSQ_DBGOUT</a>(1) &lt;&lt; <span class="stringliteral">"- Executing NonSmoothDescent::cleanup()\n"</span>;
<a name="l00137"></a>00137   <a class="code" href="group__debug.html#gc1fb4ac3396b35008642ebd22e1b4d02">MSQ_DBGOUT</a>(1) &lt;&lt; <span class="stringliteral">"- Done with NonSmoothDescent::cleanup()\n"</span>;
<a name="l00138"></a>00138 }
<a name="l00139"></a>00139 
<a name="l00140"></a>00140 
<a name="l00141"></a>00141 
<a name="l00142"></a>00142 
<a name="l00143"></a>00143 
<a name="l00144"></a>00144 <span class="keywordtype">void</span> NonSmoothDescent::find_plane_points( Direction dir1, 
<a name="l00145"></a>00145                                           Direction dir2,
<a name="l00146"></a>00146                                           <span class="keyword">const</span> std::vector&lt;Vector3D&gt;&amp; vec,
<a name="l00147"></a>00147                                           <a class="code" href="classMesquite_1_1Vector3D.html">Vector3D</a>&amp; pt1,
<a name="l00148"></a>00148                                           <a class="code" href="classMesquite_1_1Vector3D.html">Vector3D</a>&amp; pt2,
<a name="l00149"></a>00149                                           <a class="code" href="classMesquite_1_1Vector3D.html">Vector3D</a>&amp; <span class="comment">/*pt3*/</span>,
<a name="l00150"></a>00150                                           Status&amp; status,
<a name="l00151"></a>00151                                           <a class="code" href="classMesquite_1_1MsqError.html">MsqError</a>&amp; )
<a name="l00152"></a>00152 {
<a name="l00153"></a>00153     <span class="keywordtype">int</span> i;
<a name="l00154"></a>00154     <span class="keywordtype">int</span> num_min, num_max;
<a name="l00155"></a>00155     <a class="code" href="namespaceMesquite.html#b08a3b2c2d4b869dc6b91498bf112c5f">Rotate</a> rotate=<a class="code" href="namespaceMesquite.html#b08a3b2c2d4b869dc6b91498bf112c5f3c9f055c37d071417e2dc70fcb1b0d02">CLOCKWISE</a>;
<a name="l00156"></a>00156     <span class="keywordtype">int</span> num_rotated=0;
<a name="l00157"></a>00157     <span class="keywordtype">double</span> pt_1, pt_2;
<a name="l00158"></a>00158     <span class="keywordtype">double</span> min, inv_slope;
<a name="l00159"></a>00159     <span class="keywordtype">double</span> min_inv_slope=0.;
<a name="l00160"></a>00160     <span class="keywordtype">double</span> max; 
<a name="l00161"></a>00161     <span class="keywordtype">double</span> max_inv_slope=0;
<a name="l00162"></a>00162     <span class="keywordtype">double</span> inv_origin_slope=0;
<a name="l00163"></a>00163     <span class="keyword">const</span> <span class="keywordtype">int</span> num_vec = vec.size();
<a name="l00164"></a>00164     <span class="keyword">const</span> <span class="keywordtype">int</span> auto_ind_size = 50;
<a name="l00165"></a>00165     <span class="keywordtype">int</span> auto_ind[auto_ind_size];
<a name="l00166"></a>00166     std::vector&lt;int&gt; heap_ind;
<a name="l00167"></a>00167     <span class="keywordtype">int</span>* ind;
<a name="l00168"></a>00168     <span class="keywordflow">if</span> (num_vec &lt;= auto_ind_size)
<a name="l00169"></a>00169       ind = auto_ind;
<a name="l00170"></a>00170     <span class="keywordflow">else</span> {
<a name="l00171"></a>00171       heap_ind.resize(num_vec);
<a name="l00172"></a>00172       ind = &amp;heap_ind[0];
<a name="l00173"></a>00173     }
<a name="l00174"></a>00174 
<a name="l00175"></a>00175     status = MSQ_CHECK_BOTTOM_UP;
<a name="l00176"></a>00176     <span class="comment">/* find the minimum points in dir1 starting at -1 */</span>
<a name="l00177"></a>00177     num_min = 0; ind[0]=-1; ind[1]=-1; ind[2]=-1; min=1.0;
<a name="l00178"></a>00178     <span class="keywordflow">for</span> (i=0;i&lt;num_vec;i++) {
<a name="l00179"></a>00179       <span class="keywordflow">if</span> (vec[i][dir1]&lt;min) {
<a name="l00180"></a>00180         min = vec[i][dir1]; ind[0] = i; num_min = 1;
<a name="l00181"></a>00181       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fabs(vec[i][dir1] - min) &lt; <a class="code" href="namespaceMesquite.html#27308dfd82a6c76f4c3075ac5af1b464">EPSILON</a>) {
<a name="l00182"></a>00182         ind[num_min++] = i;
<a name="l00183"></a>00183       }
<a name="l00184"></a>00184     }
<a name="l00185"></a>00185     <span class="keywordflow">if</span> (min &gt;= 0) status = MSQ_NO_EQUIL;
<a name="l00186"></a>00186  
<a name="l00187"></a>00187     <span class="keywordflow">if</span> (status != MSQ_NO_EQUIL) {
<a name="l00188"></a>00188       <span class="keywordflow">switch</span>(num_min) {
<a name="l00189"></a>00189       <span class="keywordflow">case</span> 1: <span class="comment">/* rotate to find the next point */</span>
<a name="l00190"></a>00190         pt1 = vec[ind[0]];
<a name="l00191"></a>00191         pt_1 = pt1[dir1]; pt_2 = pt1[dir2];
<a name="l00192"></a>00192         <span class="keywordflow">if</span> (pt1[dir2] &lt;= 0){rotate=<a class="code" href="namespaceMesquite.html#b08a3b2c2d4b869dc6b91498bf112c5f386e97e4eebb1f8daefda9375a376006">COUNTERCLOCKWISE</a>; max_inv_slope=-HUGE_VAL;}
<a name="l00193"></a>00193         <span class="keywordflow">if</span> (pt1[dir2] &gt; 0){rotate=<a class="code" href="namespaceMesquite.html#b08a3b2c2d4b869dc6b91498bf112c5f3c9f055c37d071417e2dc70fcb1b0d02">CLOCKWISE</a>; min_inv_slope=HUGE_VAL;}
<a name="l00194"></a>00194         <span class="keywordflow">switch</span>(rotate) {
<a name="l00195"></a>00195         <span class="keywordflow">case</span> <a class="code" href="namespaceMesquite.html#b08a3b2c2d4b869dc6b91498bf112c5f386e97e4eebb1f8daefda9375a376006">COUNTERCLOCKWISE</a>:
<a name="l00196"></a>00196           <span class="keywordflow">for</span> (i=0;i&lt;num_vec;i++) {
<a name="l00197"></a>00197             <span class="keywordflow">if</span> (i!=ind[0]) {
<a name="l00198"></a>00198               inv_slope = (vec[i][dir2] - pt_2)/(vec[i][dir1]-pt_1);
<a name="l00199"></a>00199               <span class="keywordflow">if</span> ((inv_slope&gt;max_inv_slope) &amp;&amp;  
<a name="l00200"></a>00200                   (fabs(inv_slope - max_inv_slope) &gt; <a class="code" href="namespaceMesquite.html#27308dfd82a6c76f4c3075ac5af1b464">EPSILON</a>)) {
<a name="l00201"></a>00201                 ind[1] = i; max_inv_slope=inv_slope; num_rotated = 1;
<a name="l00202"></a>00202               } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fabs(inv_slope - max_inv_slope) &lt; <a class="code" href="namespaceMesquite.html#27308dfd82a6c76f4c3075ac5af1b464">EPSILON</a>) {
<a name="l00203"></a>00203                 ind[2] = i; num_rotated++;
<a name="l00204"></a>00204               }
<a name="l00205"></a>00205             }
<a name="l00206"></a>00206           }
<a name="l00207"></a>00207           <span class="keywordflow">break</span>;
<a name="l00208"></a>00208         <span class="keywordflow">case</span> <a class="code" href="namespaceMesquite.html#b08a3b2c2d4b869dc6b91498bf112c5f3c9f055c37d071417e2dc70fcb1b0d02">CLOCKWISE</a>:
<a name="l00209"></a>00209           <span class="keywordflow">for</span> (i=0;i&lt;num_vec;i++) {
<a name="l00210"></a>00210             <span class="keywordflow">if</span> (i!=ind[0]) {
<a name="l00211"></a>00211               inv_slope = (vec[i][dir2] - pt_2)/(vec[i][dir1]-pt_1);
<a name="l00212"></a>00212               <span class="keywordflow">if</span> ((inv_slope&lt;min_inv_slope) &amp;&amp; 
<a name="l00213"></a>00213                   (fabs(inv_slope - max_inv_slope) &gt; <a class="code" href="namespaceMesquite.html#27308dfd82a6c76f4c3075ac5af1b464">EPSILON</a>)){
<a name="l00214"></a>00214                 ind[1] = i; min_inv_slope=inv_slope; num_rotated = 1;
<a name="l00215"></a>00215               } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fabs(inv_slope - min_inv_slope) &lt; <a class="code" href="namespaceMesquite.html#27308dfd82a6c76f4c3075ac5af1b464">EPSILON</a>) {
<a name="l00216"></a>00216                 ind[2] = i; num_rotated++;
<a name="l00217"></a>00217               }
<a name="l00218"></a>00218             }
<a name="l00219"></a>00219           }
<a name="l00220"></a>00220         }
<a name="l00221"></a>00221         <span class="keywordflow">switch</span>(num_rotated) {
<a name="l00222"></a>00222         <span class="keywordflow">case</span> 0:
<a name="l00223"></a>00223           <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"No points in the rotation ... odd\n"</span>);
<a name="l00224"></a>00224             status = MSQ_HULL_TEST_ERROR;
<a name="l00225"></a>00225           <span class="keywordflow">break</span>;
<a name="l00226"></a>00226         <span class="keywordflow">case</span> 1:
<a name="l00227"></a>00227           <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"Found a line in the convex hull\n"</span>);
<a name="l00228"></a>00228           pt2 = vec[ind[1]];
<a name="l00229"></a>00229           status = MSQ_TWO_PT_PLANE;
<a name="l00230"></a>00230           <span class="keywordflow">break</span>;
<a name="l00231"></a>00231         <span class="keywordflow">default</span>:
<a name="l00232"></a>00232           <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"Found 2 or more points in the rotation\n"</span>);
<a name="l00233"></a>00233             <span class="keywordflow">if</span> (fabs(pt_1) &gt; <a class="code" href="namespaceMesquite.html#27308dfd82a6c76f4c3075ac5af1b464">EPSILON</a>) inv_origin_slope = pt_2/pt_1;
<a name="l00234"></a>00234           <span class="keywordflow">switch</span>(rotate) {
<a name="l00235"></a>00235           <span class="keywordflow">case</span> <a class="code" href="namespaceMesquite.html#b08a3b2c2d4b869dc6b91498bf112c5f386e97e4eebb1f8daefda9375a376006">COUNTERCLOCKWISE</a>:
<a name="l00236"></a>00236             <span class="keywordflow">if</span> (inv_origin_slope &gt;= max_inv_slope) status=MSQ_NO_EQUIL;
<a name="l00237"></a>00237             <span class="keywordflow">else</span> status=MSQ_CHECK_TOP_DOWN;
<a name="l00238"></a>00238             <span class="keywordflow">break</span>;
<a name="l00239"></a>00239           <span class="keywordflow">case</span> <a class="code" href="namespaceMesquite.html#b08a3b2c2d4b869dc6b91498bf112c5f3c9f055c37d071417e2dc70fcb1b0d02">CLOCKWISE</a>:
<a name="l00240"></a>00240             <span class="keywordflow">if</span> (inv_origin_slope &lt;= min_inv_slope) status=MSQ_NO_EQUIL;
<a name="l00241"></a>00241             <span class="keywordflow">else</span> status=MSQ_CHECK_TOP_DOWN;
<a name="l00242"></a>00242           }
<a name="l00243"></a>00243         }
<a name="l00244"></a>00244         <span class="keywordflow">break</span>;
<a name="l00245"></a>00245       <span class="keywordflow">case</span> 2: <span class="comment">/* use these two points to define the plane */</span>
<a name="l00246"></a>00246         <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"Found two minimum points to define the plane\n"</span>);
<a name="l00247"></a>00247         pt1 = vec[ind[0]];
<a name="l00248"></a>00248         pt2 = vec[ind[1]];
<a name="l00249"></a>00249         status = MSQ_TWO_PT_PLANE;
<a name="l00250"></a>00250         <span class="keywordflow">break</span>;
<a name="l00251"></a>00251       <span class="keywordflow">default</span>: <span class="comment">/* check to see if all &gt; 0 */</span>
<a name="l00252"></a>00252         <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"Found 3 or more points in min plane %f\n"</span>,min);
<a name="l00253"></a>00253           <span class="keywordflow">if</span> (vec[ind[0]][dir1] &gt;= 0) status = MSQ_NO_EQUIL;
<a name="l00254"></a>00254           <span class="keywordflow">else</span> status = MSQ_CHECK_TOP_DOWN;
<a name="l00255"></a>00255     }
<a name="l00256"></a>00256     }
<a name="l00257"></a>00257 
<a name="l00258"></a>00258     <span class="comment">/***************************/</span>
<a name="l00259"></a>00259     <span class="comment">/*  failed to find any information, checking top/down this coord*/</span>
<a name="l00260"></a>00260     <span class="comment">/***************************/</span>
<a name="l00261"></a>00261 
<a name="l00262"></a>00262     <span class="keywordflow">if</span> (status == MSQ_CHECK_TOP_DOWN) {
<a name="l00263"></a>00263     <span class="comment">/* find the maximum points in dir1 starting at 1 */</span>
<a name="l00264"></a>00264     num_max = 0; ind[0]=-1; ind[1]=-1; ind[2]=-1; max=-1.0;
<a name="l00265"></a>00265     <span class="keywordflow">for</span> (i=0;i&lt;num_vec;i++) {
<a name="l00266"></a>00266       <span class="keywordflow">if</span> (vec[i][dir1] &gt; max) {
<a name="l00267"></a>00267         max = vec[i][dir1]; ind[0] = i; num_max = 1;
<a name="l00268"></a>00268       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fabs(vec[i][dir1] - max) &lt; <a class="code" href="namespaceMesquite.html#27308dfd82a6c76f4c3075ac5af1b464">EPSILON</a>) {
<a name="l00269"></a>00269         ind[num_max++] = i;
<a name="l00270"></a>00270       }
<a name="l00271"></a>00271     }
<a name="l00272"></a>00272     <span class="keywordflow">if</span> (max &lt;= 0) status = MSQ_NO_EQUIL;
<a name="l00273"></a>00273  
<a name="l00274"></a>00274     <span class="keywordflow">if</span> (status != MSQ_NO_EQUIL) {
<a name="l00275"></a>00275       <span class="keywordflow">switch</span>(num_max) {
<a name="l00276"></a>00276       <span class="keywordflow">case</span> 1: <span class="comment">/* rotate to find the next point */</span>
<a name="l00277"></a>00277         pt1 = vec[ind[0]];
<a name="l00278"></a>00278         pt_1 = pt1[dir1];  pt_2 = pt1[dir2];
<a name="l00279"></a>00279         <span class="keywordflow">if</span> (pt1[dir2] &lt; 0){rotate=<a class="code" href="namespaceMesquite.html#b08a3b2c2d4b869dc6b91498bf112c5f3c9f055c37d071417e2dc70fcb1b0d02">CLOCKWISE</a>; min_inv_slope=HUGE_VAL;}
<a name="l00280"></a>00280         <span class="keywordflow">if</span> (pt1[dir2] &gt;= 0){rotate=<a class="code" href="namespaceMesquite.html#b08a3b2c2d4b869dc6b91498bf112c5f386e97e4eebb1f8daefda9375a376006">COUNTERCLOCKWISE</a>; max_inv_slope=-HUGE_VAL;}
<a name="l00281"></a>00281         <span class="keywordflow">switch</span>(rotate) {
<a name="l00282"></a>00282         <span class="keywordflow">case</span> <a class="code" href="namespaceMesquite.html#b08a3b2c2d4b869dc6b91498bf112c5f386e97e4eebb1f8daefda9375a376006">COUNTERCLOCKWISE</a>:
<a name="l00283"></a>00283           <span class="keywordflow">for</span> (i=0;i&lt;num_vec;i++) {
<a name="l00284"></a>00284             <span class="keywordflow">if</span> (i!=ind[0]) {
<a name="l00285"></a>00285               inv_slope = (vec[i][dir2] - pt_2)/(vec[i][dir1]-pt_1);
<a name="l00286"></a>00286               <span class="keywordflow">if</span> (inv_slope&gt;max_inv_slope) {
<a name="l00287"></a>00287                 ind[1] = i; max_inv_slope=inv_slope; num_rotated = 1;
<a name="l00288"></a>00288               } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fabs(inv_slope - max_inv_slope) &lt; <a class="code" href="namespaceMesquite.html#27308dfd82a6c76f4c3075ac5af1b464">EPSILON</a>) {
<a name="l00289"></a>00289                 ind[2] = i; num_rotated++;
<a name="l00290"></a>00290               }
<a name="l00291"></a>00291             }
<a name="l00292"></a>00292           }
<a name="l00293"></a>00293           <span class="keywordflow">break</span>;
<a name="l00294"></a>00294         <span class="keywordflow">case</span> <a class="code" href="namespaceMesquite.html#b08a3b2c2d4b869dc6b91498bf112c5f3c9f055c37d071417e2dc70fcb1b0d02">CLOCKWISE</a>:
<a name="l00295"></a>00295           <span class="keywordflow">for</span> (i=0;i&lt;num_vec;i++) {
<a name="l00296"></a>00296             <span class="keywordflow">if</span> (i!=ind[0]) {
<a name="l00297"></a>00297               inv_slope = (vec[i][dir2] - pt_2)/(vec[i][dir1]-pt_1);
<a name="l00298"></a>00298               <span class="keywordflow">if</span> (inv_slope&lt;min_inv_slope) {
<a name="l00299"></a>00299                 ind[1] = i; min_inv_slope=inv_slope; num_rotated = 1;
<a name="l00300"></a>00300               } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fabs(inv_slope - min_inv_slope) &lt; <a class="code" href="namespaceMesquite.html#27308dfd82a6c76f4c3075ac5af1b464">EPSILON</a>) {
<a name="l00301"></a>00301                 ind[2] = i; num_rotated++;
<a name="l00302"></a>00302               }
<a name="l00303"></a>00303             }
<a name="l00304"></a>00304           }
<a name="l00305"></a>00305         }
<a name="l00306"></a>00306         <span class="keywordflow">switch</span>(num_rotated) {
<a name="l00307"></a>00307         <span class="keywordflow">case</span> 0:
<a name="l00308"></a>00308           <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"No points in the rotation ... odd\n"</span>);
<a name="l00309"></a>00309           status = MSQ_HULL_TEST_ERROR;
<a name="l00310"></a>00310           <span class="keywordflow">break</span>;
<a name="l00311"></a>00311         <span class="keywordflow">case</span> 1:
<a name="l00312"></a>00312           <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"Found a line in the convex hull\n"</span>);
<a name="l00313"></a>00313           pt2 = vec[ind[1]];
<a name="l00314"></a>00314           status = MSQ_TWO_PT_PLANE;
<a name="l00315"></a>00315           <span class="keywordflow">break</span>;
<a name="l00316"></a>00316         <span class="keywordflow">default</span>:
<a name="l00317"></a>00317           <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"Found 2 or more points in the rotation\n"</span>);
<a name="l00318"></a>00318             <span class="comment">/* check to see if rotation got past origin */</span>
<a name="l00319"></a>00319           inv_origin_slope = pt_2/pt_1;
<a name="l00320"></a>00320           <span class="keywordflow">switch</span>(rotate) {
<a name="l00321"></a>00321           <span class="keywordflow">case</span> <a class="code" href="namespaceMesquite.html#b08a3b2c2d4b869dc6b91498bf112c5f386e97e4eebb1f8daefda9375a376006">COUNTERCLOCKWISE</a>:
<a name="l00322"></a>00322             <span class="keywordflow">if</span> (inv_origin_slope &gt;= max_inv_slope) status=MSQ_NO_EQUIL;
<a name="l00323"></a>00323             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dir1 == 2) status=MSQ_CHECK_Y_COORD_DIRECTION;
<a name="l00324"></a>00324             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dir1 == 1) status=MSQ_CHECK_X_COORD_DIRECTION;
<a name="l00325"></a>00325             <span class="keywordflow">else</span> status=MSQ_EQUIL;
<a name="l00326"></a>00326             <span class="keywordflow">break</span>;
<a name="l00327"></a>00327           <span class="keywordflow">case</span> <a class="code" href="namespaceMesquite.html#b08a3b2c2d4b869dc6b91498bf112c5f3c9f055c37d071417e2dc70fcb1b0d02">CLOCKWISE</a>:
<a name="l00328"></a>00328             <span class="keywordflow">if</span> (inv_origin_slope &lt;= min_inv_slope) status=MSQ_NO_EQUIL;
<a name="l00329"></a>00329             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dir1 == 2) status=MSQ_CHECK_Y_COORD_DIRECTION;
<a name="l00330"></a>00330             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dir1 == 1) status=MSQ_CHECK_X_COORD_DIRECTION;
<a name="l00331"></a>00331             <span class="keywordflow">else</span> status=MSQ_EQUIL;
<a name="l00332"></a>00332           }
<a name="l00333"></a>00333         }
<a name="l00334"></a>00334         <span class="keywordflow">break</span>;
<a name="l00335"></a>00335       <span class="keywordflow">case</span> 2: <span class="comment">/* use these two points to define the plane */</span>
<a name="l00336"></a>00336         pt1 = vec[ind[0]];
<a name="l00337"></a>00337         pt2 = vec[ind[1]];
<a name="l00338"></a>00338         status = MSQ_TWO_PT_PLANE;
<a name="l00339"></a>00339         <span class="keywordflow">break</span>;
<a name="l00340"></a>00340       <span class="keywordflow">default</span>: <span class="comment">/* check to see if all &gt; 0 */</span>
<a name="l00341"></a>00341         <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"Found 3 in max plane %f\n"</span>,max);
<a name="l00342"></a>00342         <span class="keywordflow">if</span> (vec[ind[0]][dir1] &lt;= 0) status = MSQ_NO_EQUIL;
<a name="l00343"></a>00343         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dir1==2) status=MSQ_CHECK_Y_COORD_DIRECTION;
<a name="l00344"></a>00344         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dir1==1) status=MSQ_CHECK_X_COORD_DIRECTION;
<a name="l00345"></a>00345         <span class="keywordflow">else</span> status = MSQ_EQUIL;
<a name="l00346"></a>00346       }
<a name="l00347"></a>00347     }
<a name="l00348"></a>00348   }
<a name="l00349"></a>00349 
<a name="l00350"></a>00350 }
<a name="l00351"></a>00351 
<a name="l00352"></a>00352 <span class="keywordtype">void</span> NonSmoothDescent::search_direction( PatchData &amp;<span class="comment">/*pd*/</span>,
<a name="l00353"></a>00353                                          Vector3D&amp; mSearch,
<a name="l00354"></a>00354                                          MsqError &amp;err)
<a name="l00355"></a>00355 {
<a name="l00356"></a>00356    <span class="keywordtype">bool</span>       viable;
<a name="l00357"></a>00357    <span class="keywordtype">double</span>     a, b, c, denom;
<a name="l00358"></a>00358    std::vector&lt;Vector3D&gt; dir;
<a name="l00359"></a>00359    <span class="keywordtype">double</span>     R0, R1;
<a name="l00360"></a>00360    SymmetricMatrix <a class="code" href="namespaceMesquite.html#3cffb20433bc7e60128cfa831d0af983">P</a>;
<a name="l00361"></a>00361    <span class="keywordtype">double</span>     x[2];
<a name="l00362"></a>00362    <span class="keywordtype">double</span>     search_mag;
<a name="l00363"></a>00363 
<a name="l00364"></a>00364    <span class="keyword">const</span> <span class="keywordtype">int</span> num_active = mActive.<a class="code" href="structMesquite_1_1NonSmoothDescent_1_1ActiveSet.html#c2806c3f7b66fbe85f3382ad3e4c8fc9">active_ind</a>.size();;
<a name="l00365"></a>00365 
<a name="l00366"></a>00366    <span class="comment">//TODO This might be o.k. actually - i don't see any dependence</span>
<a name="l00367"></a>00367    <span class="comment">// on the element geometry here... try it and see if it works.</span>
<a name="l00368"></a>00368    <span class="comment">// if not, try taking all of the gradients in the active set</span>
<a name="l00369"></a>00369    <span class="comment">// and let the search direction be the average of those.</span>
<a name="l00370"></a>00370 <span class="comment">//   MSQ_FUNCTION_TIMER( "Search Direction" );</span>
<a name="l00371"></a>00371 
<a name="l00372"></a>00372    <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(2)(<span class="stringliteral">"\nIn Search Direction\n"</span>);
<a name="l00373"></a>00373    this-&gt;print_active_set(mActive, mFunction);
<a name="l00374"></a>00374    
<a name="l00375"></a>00375    <span class="keywordflow">if</span> (num_active==0) {
<a name="l00376"></a>00376        <a class="code" href="group__error.html#g2a2fbc6c2b94ad06a287ec11ea469868">MSQ_SETERR</a>(err)(<span class="stringliteral">"No active values in search"</span>,<a class="code" href="classMesquite_1_1MsqError.html#1d7c4cd95eccb8d09c39504ff0c2ec0b53898f70c932e78bfa7337a1956d0a15">MsqError::INVALID_STATE</a>);
<a name="l00377"></a>00377        <span class="keywordflow">return</span>;
<a name="l00378"></a>00378     }
<a name="l00379"></a>00379 
<a name="l00380"></a>00380     <span class="keywordflow">switch</span>(num_active) {
<a name="l00381"></a>00381     <span class="keywordflow">case</span> 1: 
<a name="l00382"></a>00382         mSearch = mGradient[mActive.<a class="code" href="structMesquite_1_1NonSmoothDescent_1_1ActiveSet.html#c2806c3f7b66fbe85f3382ad3e4c8fc9">active_ind</a>[0]];
<a name="l00383"></a>00383         mSteepest = mActive.<a class="code" href="structMesquite_1_1NonSmoothDescent_1_1ActiveSet.html#c2806c3f7b66fbe85f3382ad3e4c8fc9">active_ind</a>[0];
<a name="l00384"></a>00384         <span class="keywordflow">break</span>;
<a name="l00385"></a>00385     <span class="keywordflow">case</span> 2:
<a name="l00386"></a>00386         <span class="comment">/* if there are two active points, move in the direction of the</span>
<a name="l00387"></a>00387 <span class="comment">           intersection of the planes.  This is the steepest descent</span>
<a name="l00388"></a>00388 <span class="comment">           direction found by analytically solving the QP */</span>
<a name="l00389"></a>00389         
<a name="l00390"></a>00390         <span class="comment">/* set up the active gradient directions */</span>
<a name="l00391"></a>00391         this-&gt;get_active_directions(mGradient,dir,err); <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l00392"></a>00392 
<a name="l00393"></a>00393         <span class="comment">/* form the grammian */</span>
<a name="l00394"></a>00394         this-&gt;form_grammian(dir,err); <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l00395"></a>00395         this-&gt;form_PD_grammian(err); <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l00396"></a>00396 
<a name="l00397"></a>00397         denom = (mG(0,0) + mG(1,1) - 2*mG(0,1));
<a name="l00398"></a>00398         viable = <span class="keyword">true</span>;
<a name="l00399"></a>00399         <span class="keywordflow">if</span> (fabs(denom) &gt; <a class="code" href="namespaceMesquite.html#27308dfd82a6c76f4c3075ac5af1b464">EPSILON</a>) {
<a name="l00400"></a>00400           <span class="comment">/* gradients are LI, move along their intersection */</span>
<a name="l00401"></a>00401            b = (mG(0,0) - mG(0,1))/denom;  
<a name="l00402"></a>00402            a = 1 - b;
<a name="l00403"></a>00403            <span class="keywordflow">if</span> ((b &lt; 0) || (b &gt; 1)) viable=<span class="keyword">false</span>;  <span class="comment">/* 0 &lt; b &lt; 1 */</span>
<a name="l00404"></a>00404            <span class="keywordflow">if</span> (viable) {
<a name="l00405"></a>00405              mSearch = a*dir[0] + b*dir[1];
<a name="l00406"></a>00406            } <span class="keywordflow">else</span> {
<a name="l00407"></a>00407              <span class="comment">/* the gradients are dependent, move along one face */</span>
<a name="l00408"></a>00408              mSearch = dir[0];
<a name="l00409"></a>00409            }
<a name="l00410"></a>00410         } <span class="keywordflow">else</span> {
<a name="l00411"></a>00411            <span class="comment">/* the gradients are dependent, move along one face */</span>
<a name="l00412"></a>00412            mSearch = dir[0];
<a name="l00413"></a>00413         }
<a name="l00414"></a>00414         mSteepest = mActive.<a class="code" href="structMesquite_1_1NonSmoothDescent_1_1ActiveSet.html#c2806c3f7b66fbe85f3382ad3e4c8fc9">active_ind</a>[0];
<a name="l00415"></a>00415 
<a name="l00416"></a>00416         <span class="keywordflow">break</span>;
<a name="l00417"></a>00417     <span class="keywordflow">default</span>:
<a name="l00418"></a>00418         <span class="comment">/* as in case 2: solve the QP problem to find the steepest</span>
<a name="l00419"></a>00419 <span class="comment">           descent direction.  This can be done analytically - as</span>
<a name="l00420"></a>00420 <span class="comment">           is done in Gill, Murray and Wright </span>
<a name="l00421"></a>00421 <span class="comment">             for 3 active points in 3 directions - test PD of G</span>
<a name="l00422"></a>00422 <span class="comment">             otherwise we know it's SP SD so search edges and faces */</span>
<a name="l00423"></a>00423 
<a name="l00424"></a>00424         <span class="comment">/* get the active gradient directions */</span>
<a name="l00425"></a>00425         this-&gt;get_active_directions(mGradient,dir,err);  <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l00426"></a>00426 
<a name="l00427"></a>00427         <span class="comment">/* form the entries of the grammian matrix */</span>
<a name="l00428"></a>00428         this-&gt;form_grammian(dir,err); <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l00429"></a>00429         this-&gt;form_PD_grammian(err);  <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l00430"></a>00430 
<a name="l00431"></a>00431         <span class="keywordflow">if</span> (num_active == 3) {
<a name="l00432"></a>00432           <span class="keywordflow">if</span> (mG.<a class="code" href="classMesquite_1_1NonSmoothDescent_1_1SymmetricMatrix.html#f10201cca8744273bf8f5aae53b50f02">condition3x3</a>() &lt; 1e14) { <span class="comment">// if not singular</span>
<a name="l00433"></a>00433             <span class="comment">/* form the entries of P=Z^T G Z where Z = [-1...-1; I ] */</span>
<a name="l00434"></a>00434             this-&gt;form_reduced_matrix(P); 
<a name="l00435"></a>00435               <span class="comment">/* form  the RHS and solve the system for the coeffs */</span>
<a name="l00436"></a>00436             R0 = mG(0,0) - mG(1,0);  R1 = mG(0,0) - mG(2,0);
<a name="l00437"></a>00437             <span class="keywordtype">bool</span> ok = this-&gt;solve2x2(<a class="code" href="namespaceMesquite.html#3cffb20433bc7e60128cfa831d0af983">P</a>(0,0),<a class="code" href="namespaceMesquite.html#3cffb20433bc7e60128cfa831d0af983">P</a>(0,1),<a class="code" href="namespaceMesquite.html#3cffb20433bc7e60128cfa831d0af983">P</a>(1,0),<a class="code" href="namespaceMesquite.html#3cffb20433bc7e60128cfa831d0af983">P</a>(1,1),R0,R1,x,err); <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l00438"></a>00438             <span class="keywordflow">if</span> (ok) {
<a name="l00439"></a>00439               a = 1 - x[0] - x[1];  b = x[0];  c = x[1];
<a name="l00440"></a>00440               mSearch = a*dir[0] + b*dir[1] + c*dir[2];
<a name="l00441"></a>00441               mSteepest = mActive.<a class="code" href="structMesquite_1_1NonSmoothDescent_1_1ActiveSet.html#c2806c3f7b66fbe85f3382ad3e4c8fc9">active_ind</a>[0];
<a name="l00442"></a>00442             } 
<a name="l00443"></a>00443             <span class="keywordflow">else</span> { 
<a name="l00444"></a>00444               this-&gt;search_edges_faces(&amp;dir[0], mSearch, err); <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l00445"></a>00445             }
<a name="l00446"></a>00446           } 
<a name="l00447"></a>00447           <span class="keywordflow">else</span> {
<a name="l00448"></a>00448             this-&gt;search_edges_faces(&amp;dir[0], mSearch, err);  <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l00449"></a>00449           }
<a name="l00450"></a>00450         } 
<a name="l00451"></a>00451         <span class="keywordflow">else</span> {
<a name="l00452"></a>00452           this-&gt;search_edges_faces(&amp;dir[0], mSearch, err); <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l00453"></a>00453         }
<a name="l00454"></a>00454     }
<a name="l00455"></a>00455 
<a name="l00456"></a>00456     <span class="comment">/* if the search direction is essentially zero, equilibrium pt */</span>
<a name="l00457"></a>00457     search_mag = mSearch % mSearch;
<a name="l00458"></a>00458     <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"  Search Magnitude %g \n"</span>,search_mag);
<a name="l00459"></a>00459 
<a name="l00460"></a>00460     <span class="keywordflow">if</span> (fabs(search_mag)&lt;1E-13) 
<a name="l00461"></a>00461       optStatus = MSQ_ZERO_SEARCH;
<a name="l00462"></a>00462     <span class="keywordflow">else</span> 
<a name="l00463"></a>00463       mSearch /= std::sqrt(search_mag);
<a name="l00464"></a>00464     <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"  Search Direction %g %g  Steepest %lu\n"</span>,mSearch[0],mSearch[1],(<span class="keywordtype">unsigned</span> long)mSteepest);
<a name="l00465"></a>00465 }
<a name="l00466"></a>00466 
<a name="l00467"></a>00467 <span class="keywordtype">void</span> NonSmoothDescent::minmax_opt(PatchData &amp;pd, MsqError &amp;err)
<a name="l00468"></a>00468 {
<a name="l00469"></a>00469       <span class="keywordtype">bool</span> equilibriumPt = <span class="keyword">false</span>;
<a name="l00470"></a>00470       Vector3D mSearch(0,0,0);
<a name="l00471"></a>00471 
<a name="l00472"></a>00472 <span class="comment">//      int valid;</span>
<a name="l00473"></a>00473       <a class="code" href="MsqTimer_8hpp.html#605f98d565a626d6fba847fa56ea8a1e">MSQ_FUNCTION_TIMER</a>( <span class="stringliteral">"Minmax Opt"</span> );
<a name="l00474"></a>00474       <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(2)(<span class="stringliteral">"In minmax_opt\n"</span>);
<a name="l00475"></a>00475 
<a name="l00476"></a>00476       mFunction = originalFunction;
<a name="l00477"></a>00477       originalValue = mActive.<a class="code" href="structMesquite_1_1NonSmoothDescent_1_1ActiveSet.html#cab79bbe0e22621d5db7fbbe2e88c4df">true_active_value</a>;
<a name="l00478"></a>00478 
<a name="l00479"></a>00479       <span class="keywordtype">int</span> iterCount = 0;
<a name="l00480"></a>00480       <span class="keywordtype">int</span> optIterCount = 0;
<a name="l00481"></a>00481 
<a name="l00482"></a>00482       <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"Done copying original function to function\n"</span>);
<a name="l00483"></a>00483 
<a name="l00484"></a>00484       this-&gt;find_active_set(mFunction, mActive);
<a name="l00485"></a>00485       prevActiveValues.clear();
<a name="l00486"></a>00486       prevActiveValues.push_back( mActive.<a class="code" href="structMesquite_1_1NonSmoothDescent_1_1ActiveSet.html#cab79bbe0e22621d5db7fbbe2e88c4df">true_active_value</a> );
<a name="l00487"></a>00487 
<a name="l00488"></a>00488      <span class="comment">/* check for equilibrium point */</span>
<a name="l00489"></a>00489      <span class="comment">/* compute the gradient */</span>
<a name="l00490"></a>00490      this-&gt;compute_gradient(&amp;pd, mGradient, err); <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l00491"></a>00491      
<a name="l00492"></a>00492      <span class="keywordflow">if</span> (mActive.<a class="code" href="structMesquite_1_1NonSmoothDescent_1_1ActiveSet.html#c2806c3f7b66fbe85f3382ad3e4c8fc9">active_ind</a>.size() &gt;= 2) {
<a name="l00493"></a>00493         <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"Testing for an equilibrium point \n"</span>);
<a name="l00494"></a>00494         equilibriumPt = this-&gt;check_equilibrium( optStatus, err); <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l00495"></a>00495 
<a name="l00496"></a>00496         <span class="keywordflow">if</span> (<a class="code" href="group__debug.html#gc1381de59ecf54ee1f54fdd351c4f726">MSQ_DBG</a>(2) &amp;&amp; equilibriumPt ) 
<a name="l00497"></a>00497           <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(2)(<span class="stringliteral">"Optimization Exiting: An equilibrium point \n"</span>);
<a name="l00498"></a>00498      }
<a name="l00499"></a>00499 
<a name="l00500"></a>00500     <span class="comment">/* terminate if we have found an equilibrium point or if the step is</span>
<a name="l00501"></a>00501 <span class="comment">       too small to be worthwhile continuing */</span>
<a name="l00502"></a>00502     <span class="keywordflow">while</span> ((optStatus != MSQ_EQUILIBRIUM) &amp;&amp; 
<a name="l00503"></a>00503            (optStatus != MSQ_STEP_TOO_SMALL) &amp;&amp;
<a name="l00504"></a>00504            (optStatus != MSQ_IMP_TOO_SMALL) &amp;&amp;
<a name="l00505"></a>00505            (optStatus != MSQ_FLAT_NO_IMP) &amp;&amp;
<a name="l00506"></a>00506            (optStatus != MSQ_ZERO_SEARCH) &amp;&amp;
<a name="l00507"></a>00507            (optStatus != MSQ_MAX_ITER_EXCEEDED)) {
<a name="l00508"></a>00508 
<a name="l00509"></a>00509         <span class="comment">/* increase the iteration count by one */</span>
<a name="l00510"></a>00510         <span class="comment">/* smooth_param-&gt;iter_count += 1; */</span>
<a name="l00511"></a>00511         iterCount += 1;
<a name="l00512"></a>00512         optIterCount += 1;
<a name="l00513"></a>00513         <span class="keywordflow">if</span> (iterCount &gt; <a class="code" href="namespaceMesquite.html#36d95041ba906e07b70bb395358e4443">MSQ_MAX_OPT_ITER</a>) optStatus = MSQ_MAX_ITER_EXCEEDED;
<a name="l00514"></a>00514 
<a name="l00515"></a>00515         <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"\nITERATION %d \n"</span>,iterCount);
<a name="l00516"></a>00516             
<a name="l00517"></a>00517         <span class="comment">/* compute the gradient */</span>
<a name="l00518"></a>00518         this-&gt;compute_gradient(&amp;pd, mGradient, err); <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l00519"></a>00519         
<a name="l00520"></a>00520         <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"Computing the search direction \n"</span>);
<a name="l00521"></a>00521         this-&gt;search_direction(pd, mSearch, err); <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l00522"></a>00522 
<a name="l00523"></a>00523         <span class="comment">/* if there are viable directions to search */</span>
<a name="l00524"></a>00524         <span class="keywordflow">if</span> ((optStatus != MSQ_ZERO_SEARCH) &amp;&amp;
<a name="l00525"></a>00525             (optStatus != MSQ_MAX_ITER_EXCEEDED)) {
<a name="l00526"></a>00526 
<a name="l00527"></a>00527             <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"Computing the projections of the gradients \n"</span>);
<a name="l00528"></a>00528             this-&gt;get_gradient_projections(mSearch, err); <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l00529"></a>00529 
<a name="l00530"></a>00530             <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"Computing the initial step size \n"</span>);
<a name="l00531"></a>00531             this-&gt;compute_alpha(err); <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l00532"></a>00532 
<a name="l00533"></a>00533             <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"Testing whether to accept this step \n"</span>);
<a name="l00534"></a>00534             this-&gt;step_acceptance(pd, iterCount, mSearch, err); <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l00535"></a>00535             <span class="comment">//MSQ_PRINT(3)("The new free vertex position is %f %f %f\n",</span>
<a name="l00536"></a>00536             <span class="comment">//  mCoords[freeVertexIndex][0],mCoords[freeVertexIndex][1],mCoords[freeVertexIndex][2]);</span>
<a name="l00537"></a>00537 
<a name="l00538"></a>00538             <span class="keywordflow">if</span> (<a class="code" href="group__debug.html#gc1381de59ecf54ee1f54fdd351c4f726">MSQ_DBG</a>(3)) {
<a name="l00539"></a>00539                 <span class="comment">/* Print the active set */</span>
<a name="l00540"></a>00540                 this-&gt;print_active_set(mActive, mFunction);
<a name="l00541"></a>00541             }
<a name="l00542"></a>00542 
<a name="l00543"></a>00543             <span class="comment">/* check for equilibrium point */</span>
<a name="l00544"></a>00544             <span class="keywordflow">if</span> (mActive.<a class="code" href="structMesquite_1_1NonSmoothDescent_1_1ActiveSet.html#c2806c3f7b66fbe85f3382ad3e4c8fc9">active_ind</a>.size() &gt;= 2) {
<a name="l00545"></a>00545                 <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"Testing for an equilibrium point \n"</span>);
<a name="l00546"></a>00546                 equilibriumPt = this-&gt;check_equilibrium(optStatus, err); <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l00547"></a>00547 
<a name="l00548"></a>00548                 <span class="keywordflow">if</span> (<a class="code" href="group__debug.html#gc1381de59ecf54ee1f54fdd351c4f726">MSQ_DBG</a>(2) &amp;&amp; equilibriumPt) 
<a name="l00549"></a>00549                     <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(2)(<span class="stringliteral">"Optimization Exiting: An equilibrium point \n"</span>);
<a name="l00550"></a>00550             }
<a name="l00551"></a>00551 
<a name="l00552"></a>00552             <span class="comment">/* record the values */</span>
<a name="l00553"></a>00553             prevActiveValues.push_back( mActive.<a class="code" href="structMesquite_1_1NonSmoothDescent_1_1ActiveSet.html#cab79bbe0e22621d5db7fbbe2e88c4df">true_active_value</a> );
<a name="l00554"></a>00554 
<a name="l00555"></a>00555         } <span class="keywordflow">else</span> {
<a name="l00556"></a>00556             <span class="comment">/* decrease the iteration count by one */</span>
<a name="l00557"></a>00557             <span class="comment">/* smooth_param-&gt;iter_count -= 1; */</span>
<a name="l00558"></a>00558             iterCount -= 1;
<a name="l00559"></a>00559             <span class="keywordflow">if</span> (<a class="code" href="group__debug.html#gc1381de59ecf54ee1f54fdd351c4f726">MSQ_DBG</a>(2)) {
<a name="l00560"></a>00560                 <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(2)(<span class="stringliteral">"Optimization Exiting: No viable directions; equilibrium point \n"</span>);
<a name="l00561"></a>00561                 <span class="comment">/* Print the old active set */</span>
<a name="l00562"></a>00562                 this-&gt;print_active_set(mActive,mFunction);
<a name="l00563"></a>00563             }
<a name="l00564"></a>00564         }
<a name="l00565"></a>00565       }
<a name="l00566"></a>00566 
<a name="l00567"></a>00567       <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(2)(<span class="stringliteral">"Checking the validity of the mesh\n"</span>);
<a name="l00568"></a>00568       <span class="keywordflow">if</span> (!this-&gt;validity_check(pd,err)) <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(2)(<span class="stringliteral">"The final mesh is not valid\n"</span>);
<a name="l00569"></a>00569       <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l00570"></a>00570 
<a name="l00571"></a>00571       <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(2)(<span class="stringliteral">"Number of optimization iterations %d\n"</span>, iterCount);
<a name="l00572"></a>00572  
<a name="l00573"></a>00573       <span class="keywordflow">switch</span>(optStatus) {
<a name="l00574"></a>00574         <span class="keywordflow">default</span>:
<a name="l00575"></a>00575           <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(2)(<span class="stringliteral">"Optimization Termination OptStatus: Invalid early termination\n"</span>); <span class="keywordflow">break</span>;
<a name="l00576"></a>00576         <span class="keywordflow">case</span> MSQ_EQUILIBRIUM:
<a name="l00577"></a>00577           <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(2)(<span class="stringliteral">"Optimization Termination OptStatus: Equilibrium\n"</span>); <span class="keywordflow">break</span>;
<a name="l00578"></a>00578         <span class="keywordflow">case</span> MSQ_STEP_TOO_SMALL:
<a name="l00579"></a>00579           <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(2)(<span class="stringliteral">"Optimization Termination OptStatus: Step Too Small\n"</span>); <span class="keywordflow">break</span>;
<a name="l00580"></a>00580         <span class="keywordflow">case</span> MSQ_IMP_TOO_SMALL:
<a name="l00581"></a>00581           <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(2)(<span class="stringliteral">"Optimization Termination OptStatus: Improvement Too Small\n"</span>); <span class="keywordflow">break</span>;
<a name="l00582"></a>00582         <span class="keywordflow">case</span> MSQ_FLAT_NO_IMP:
<a name="l00583"></a>00583           <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(2)(<span class="stringliteral">"Optimization Termination OptStatus: Flat No Improvement\n"</span>); <span class="keywordflow">break</span>;
<a name="l00584"></a>00584         <span class="keywordflow">case</span> MSQ_ZERO_SEARCH:
<a name="l00585"></a>00585           <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(2)(<span class="stringliteral">"Optimization Termination OptStatus: Zero Search\n"</span>); <span class="keywordflow">break</span>;
<a name="l00586"></a>00586         <span class="keywordflow">case</span> MSQ_MAX_ITER_EXCEEDED:
<a name="l00587"></a>00587           <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(2)(<span class="stringliteral">"Optimization Termination OptStatus: Max Iter Exceeded\n"</span>); <span class="keywordflow">break</span>;
<a name="l00588"></a>00588       }
<a name="l00589"></a>00589 }
<a name="l00590"></a>00590 
<a name="l00591"></a>00591 
<a name="l00592"></a>00592 <span class="keywordtype">void</span> NonSmoothDescent::step_acceptance( PatchData &amp;pd, 
<a name="l00593"></a>00593                                         <span class="keywordtype">int</span> iterCount, 
<a name="l00594"></a>00594                                         <span class="keyword">const</span> Vector3D&amp; mSearch, 
<a name="l00595"></a>00595                                         MsqError &amp;err )
<a name="l00596"></a>00596 {
<a name="l00597"></a>00597   <span class="keyword">const</span> <span class="keywordtype">double</span> minAcceptableImprovement = 1e-6;
<a name="l00598"></a>00598 
<a name="l00599"></a>00599 <span class="comment">//  int        ierr;</span>
<a name="l00600"></a>00600 <span class="comment">//  int        num_values;</span>
<a name="l00601"></a>00601   <span class="keywordtype">bool</span>       step_done;
<a name="l00602"></a>00602   <span class="keywordtype">bool</span>       valid = <span class="keyword">true</span>, accept_alpha;
<a name="l00603"></a>00603   <span class="keywordtype">double</span>     estimated_improvement;
<a name="l00604"></a>00604   <span class="keywordtype">double</span>     current_improvement = HUGE_VAL;
<a name="l00605"></a>00605   <span class="keywordtype">double</span>     previous_improvement = HUGE_VAL;
<a name="l00606"></a>00606   <span class="keywordtype">double</span>     current_percent_diff = HUGE_VAL;
<a name="l00607"></a>00607   Vector3D   original_point;
<a name="l00608"></a>00608 
<a name="l00609"></a>00609 <span class="comment">//  MSQ_FUNCTION_TIMER( "Step Acceptance" );</span>
<a name="l00610"></a>00610 <span class="comment">//  num_values = qmHandles.size();</span>
<a name="l00611"></a>00611 
<a name="l00612"></a>00612   optStatus = MSQ_NO_STATUS;
<a name="l00613"></a>00613 
<a name="l00614"></a>00614   <span class="keywordflow">if</span> (mAlpha &lt; minStepSize) {
<a name="l00615"></a>00615       optStatus = MSQ_IMP_TOO_SMALL;
<a name="l00616"></a>00616       step_done = <span class="keyword">true</span>;
<a name="l00617"></a>00617       <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"Alpha starts too small, no improvement\n"</span>);
<a name="l00618"></a>00618   }
<a name="l00619"></a>00619 
<a name="l00620"></a>00620   <span class="keyword">const</span> MsqVertex* coords = pd.get_vertex_array(err);
<a name="l00621"></a>00621 
<a name="l00622"></a>00622   <span class="comment">/* save the original function and active set */</span>
<a name="l00623"></a>00623   original_point = coords[freeVertexIndex];
<a name="l00624"></a>00624   originalFunction = mFunction;
<a name="l00625"></a>00625   originalActive = mActive;
<a name="l00626"></a>00626 
<a name="l00627"></a>00627   step_done = <span class="keyword">false</span>;
<a name="l00628"></a>00628   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_steps = 0; !step_done &amp;&amp; num_steps &lt; 100; ++num_steps) {
<a name="l00629"></a>00629     accept_alpha = <span class="keyword">false</span>;
<a name="l00630"></a>00630 
<a name="l00631"></a>00631     <span class="keywordflow">while</span> (!accept_alpha &amp;&amp; mAlpha&gt;minStepSize) {
<a name="l00632"></a>00632  
<a name="l00633"></a>00633       <span class="comment">/* make the step */</span>
<a name="l00634"></a>00634       pd.move_vertex( -mAlpha*mSearch, freeVertexIndex, err );
<a name="l00635"></a>00635         <span class="comment">//pd.set_coords_array_element(coords[freeVertexIndex],0,err);</span>
<a name="l00636"></a>00636 
<a name="l00637"></a>00637       <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(2)(<span class="stringliteral">"search direction %f %f \n"</span>,mSearch[0],mSearch[1]); 
<a name="l00638"></a>00638       <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(2)(<span class="stringliteral">"new vertex position %f %f \n"</span>,coords[freeVertexIndex][0],coords[freeVertexIndex][1]); 
<a name="l00639"></a>00639 
<a name="l00640"></a>00640       <span class="comment">/* assume alpha is acceptable */</span>
<a name="l00641"></a>00641       accept_alpha=<span class="keyword">true</span>;
<a name="l00642"></a>00642 
<a name="l00643"></a>00643       <span class="comment">/* never take a step that makes a valid mesh invalid or worsens the quality */</span>
<a name="l00644"></a>00644       <span class="comment">// TODO Validity check revision -- do the compute function up here</span>
<a name="l00645"></a>00645       <span class="comment">// and then the rest based on validity</span>
<a name="l00646"></a>00646       valid = validity_check(pd,err); <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l00647"></a>00647       <span class="keywordflow">if</span> (valid) {
<a name="l00648"></a>00648         valid = improvement_check(err); <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l00649"></a>00649       }
<a name="l00650"></a>00650       <span class="keywordflow">if</span> (!valid) {
<a name="l00651"></a>00651           accept_alpha=<span class="keyword">false</span>;
<a name="l00652"></a>00652           pd.move_vertex( mAlpha * mSearch, freeVertexIndex, err );
<a name="l00653"></a>00653             <span class="comment">//pd.set_coords_array_element(coords[freeVertexIndex],0,err);</span>
<a name="l00654"></a>00654           mAlpha = mAlpha/2;
<a name="l00655"></a>00655           <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(2)(<span class="stringliteral">"Step not accepted, the new alpha %f\n"</span>,mAlpha); 
<a name="l00656"></a>00656 
<a name="l00657"></a>00657           <span class="keywordflow">if</span> (mAlpha &lt; minStepSize) {
<a name="l00658"></a>00658                 optStatus = MSQ_STEP_TOO_SMALL;
<a name="l00659"></a>00659                 step_done = <span class="keyword">true</span>;
<a name="l00660"></a>00660                 <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(2)(<span class="stringliteral">"Step too small\n"</span>);
<a name="l00661"></a>00661                 <span class="comment">/* get back the original point, mFunction, and active set */</span>
<a name="l00662"></a>00662                 pd.set_vertex_coordinates( original_point, freeVertexIndex, err );
<a name="l00663"></a>00663                 mFunction = originalFunction;
<a name="l00664"></a>00664                 mActive = originalActive;
<a name="l00665"></a>00665           }
<a name="l00666"></a>00666        }
<a name="l00667"></a>00667     } 
<a name="l00668"></a>00668          
<a name="l00669"></a>00669     <span class="keywordflow">if</span> (valid  &amp;&amp; (mAlpha &gt; minStepSize)) {
<a name="l00670"></a>00670       <span class="comment">/* compute the new function and active set */</span>
<a name="l00671"></a>00671       this-&gt;compute_function(&amp;pd, mFunction, err); <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l00672"></a>00672       this-&gt;find_active_set(mFunction, mActive);
<a name="l00673"></a>00673         
<a name="l00674"></a>00674       <span class="comment">/* estimate the minimum improvement by taking this step */</span>
<a name="l00675"></a>00675       this-&gt;get_min_estimate(&amp;estimated_improvement, err); <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l00676"></a>00676       <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(2)(<span class="stringliteral">"The estimated improvement for this step: %f\n"</span>,
<a name="l00677"></a>00677                    estimated_improvement); 
<a name="l00678"></a>00678         
<a name="l00679"></a>00679       <span class="comment">/* calculate the actual increase */</span>
<a name="l00680"></a>00680       current_improvement = mActive.<a class="code" href="structMesquite_1_1NonSmoothDescent_1_1ActiveSet.html#cab79bbe0e22621d5db7fbbe2e88c4df">true_active_value</a> - prevActiveValues[iterCount-1];
<a name="l00681"></a>00681 
<a name="l00682"></a>00682       <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"Actual improvement %f\n"</span>,current_improvement);
<a name="l00683"></a>00683 
<a name="l00684"></a>00684       <span class="comment">/* calculate the percent difference from estimated increase */</span>
<a name="l00685"></a>00685       current_percent_diff = fabs(current_improvement-estimated_improvement)/
<a name="l00686"></a>00686         fabs(estimated_improvement);
<a name="l00687"></a>00687 
<a name="l00688"></a>00688       <span class="comment">/* determine whether to accept a step */</span>
<a name="l00689"></a>00689       <span class="keywordflow">if</span> ((fabs(previous_improvement) &gt; fabs(current_improvement)) &amp;&amp; 
<a name="l00690"></a>00690           (previous_improvement &lt; 0)) {
<a name="l00691"></a>00691         <span class="comment">/* accept the previous step - it was better */</span>
<a name="l00692"></a>00692              <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(2)(<span class="stringliteral">"Accepting the previous step\n"</span>);
<a name="l00693"></a>00693  
<a name="l00694"></a>00694         <span class="comment">/* subtract alpha in again (previous step) */</span>
<a name="l00695"></a>00695         pd.move_vertex( -mAlpha * mSearch, freeVertexIndex, err );
<a name="l00696"></a>00696             <span class="comment">//pd.set_coords_array_element(coords[freeVertexIndex],0,err);</span>
<a name="l00697"></a>00697 
<a name="l00698"></a>00698         <span class="comment">/* does this make an invalid mesh valid? */</span>
<a name="l00699"></a>00699    <span class="comment">//TODO Validity check revisison</span>
<a name="l00700"></a>00700         valid = validity_check(pd,err); <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l00701"></a>00701         <span class="keywordflow">if</span> (valid) valid=improvement_check(err); <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l00702"></a>00702 
<a name="l00703"></a>00703         <span class="comment">/* copy test function and active set */</span>
<a name="l00704"></a>00704         mFunction = testFunction;
<a name="l00705"></a>00705         mActive = testActive;
<a name="l00706"></a>00706  
<a name="l00707"></a>00707         optStatus = MSQ_STEP_ACCEPTED;  step_done = <span class="keyword">true</span>;
<a name="l00708"></a>00708             
<a name="l00709"></a>00709         <span class="comment">/* check to see that we're still making good improvements */</span>
<a name="l00710"></a>00710         <span class="keywordflow">if</span> (fabs(previous_improvement) &lt; minAcceptableImprovement) {
<a name="l00711"></a>00711           optStatus = MSQ_IMP_TOO_SMALL; step_done = <span class="keyword">true</span>;
<a name="l00712"></a>00712           <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(2)(<span class="stringliteral">"Optimization Exiting: Improvement too small\n"</span>);
<a name="l00713"></a>00713         }
<a name="l00714"></a>00714 
<a name="l00715"></a>00715       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (((fabs(current_improvement) &gt; fabs(estimated_improvement)) ||
<a name="l00716"></a>00716                   (current_percent_diff &lt; .1)) &amp;&amp; (current_improvement&lt;0)) {
<a name="l00717"></a>00717         <span class="comment">/* accept this step, exceeded estimated increase or was close */</span>
<a name="l00718"></a>00718         optStatus = MSQ_STEP_ACCEPTED;  step_done = <span class="keyword">true</span>;
<a name="l00719"></a>00719 
<a name="l00720"></a>00720         <span class="comment">/* check to see that we're still making good improvements */</span>
<a name="l00721"></a>00721         <span class="keywordflow">if</span> (fabs(current_improvement) &lt; minAcceptableImprovement) {
<a name="l00722"></a>00722           <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(2)(<span class="stringliteral">"Optimization Exiting: Improvement too small\n"</span>);
<a name="l00723"></a>00723           optStatus = MSQ_IMP_TOO_SMALL; step_done = <span class="keyword">true</span>;
<a name="l00724"></a>00724         }
<a name="l00725"></a>00725 
<a name="l00726"></a>00726       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((current_improvement &gt; 0) &amp;&amp; (previous_improvement &gt; 0) &amp;&amp;
<a name="l00727"></a>00727                  (fabs(current_improvement) &lt; minAcceptableImprovement) &amp;&amp;
<a name="l00728"></a>00728                  (fabs(previous_improvement) &lt; minAcceptableImprovement)) {
<a name="l00729"></a>00729 
<a name="l00730"></a>00730         <span class="comment">/* we are making no progress, quit */</span>
<a name="l00731"></a>00731         optStatus = MSQ_FLAT_NO_IMP; step_done = <span class="keyword">true</span>;
<a name="l00732"></a>00732         <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(2)(<span class="stringliteral">"Opimization Exiting: Flat no improvement\n"</span>);
<a name="l00733"></a>00733            
<a name="l00734"></a>00734         <span class="comment">/* get back the original point, function, and active set */</span>
<a name="l00735"></a>00735         pd.set_vertex_coordinates( original_point, freeVertexIndex, err ); <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l00736"></a>00736         mFunction = originalFunction;
<a name="l00737"></a>00737         mActive = originalActive;
<a name="l00738"></a>00738       }
<a name="l00739"></a>00739       <span class="keywordflow">else</span>
<a name="l00740"></a>00740       {
<a name="l00741"></a>00741         <span class="comment">/* halve alpha and try again */</span>
<a name="l00742"></a>00742         <span class="comment">/* add out the old step */</span>
<a name="l00743"></a>00743         pd.move_vertex( mAlpha * mSearch, freeVertexIndex, err );
<a name="l00744"></a>00744             <span class="comment">//pd.set_coords_array_element(coords[freeVertexIndex],0,err);</span>
<a name="l00745"></a>00745 
<a name="l00746"></a>00746         <span class="comment">/* halve step size */</span>
<a name="l00747"></a>00747         mAlpha = mAlpha/2; 
<a name="l00748"></a>00748         <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"Step not accepted, the new alpha %f\n"</span>,mAlpha);
<a name="l00749"></a>00749 
<a name="l00750"></a>00750         <span class="keywordflow">if</span> (mAlpha &lt; minStepSize)
<a name="l00751"></a>00751           {
<a name="l00752"></a>00752           <span class="comment">/* get back the original point, function, and active set */</span>
<a name="l00753"></a>00753           <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(2)(<span class="stringliteral">"Optimization Exiting: Step too small\n"</span>);
<a name="l00754"></a>00754           pd.set_vertex_coordinates( original_point, freeVertexIndex, err ); <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l00755"></a>00755           mFunction = originalFunction;
<a name="l00756"></a>00756           mActive = originalActive;
<a name="l00757"></a>00757           optStatus = MSQ_STEP_TOO_SMALL;  step_done = <span class="keyword">true</span>;
<a name="l00758"></a>00758         }
<a name="l00759"></a>00759         <span class="keywordflow">else</span>
<a name="l00760"></a>00760         {
<a name="l00761"></a>00761           testFunction = mFunction;
<a name="l00762"></a>00762           testActive = mActive;
<a name="l00763"></a>00763           previous_improvement = current_improvement;
<a name="l00764"></a>00764         }
<a name="l00765"></a>00765       }
<a name="l00766"></a>00766     }
<a name="l00767"></a>00767   }
<a name="l00768"></a>00768   <span class="keywordflow">if</span> (current_improvement&gt;0 &amp;&amp; optStatus==MSQ_STEP_ACCEPTED) {
<a name="l00769"></a>00769     <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(2)(<span class="stringliteral">"Accepted a negative step %f \n"</span>,current_improvement);
<a name="l00770"></a>00770   }
<a name="l00771"></a>00771 
<a name="l00772"></a>00772 }
<a name="l00773"></a>00773 
<a name="l00774"></a>00774 
<a name="l00775"></a>00775 <span class="keywordtype">bool</span> NonSmoothDescent::compute_function(PatchData *patch_data, std::vector&lt;double&gt;&amp; func, MsqError &amp;err)
<a name="l00776"></a>00776 {
<a name="l00777"></a>00777   <span class="comment">// NEED 1.0/FUNCTION WHICH IS ONLY TRUE OF CONDITION NUMBER</span>
<a name="l00778"></a>00778 
<a name="l00779"></a>00779   func.resize(qmHandles.size());
<a name="l00780"></a>00780   <span class="keywordtype">bool</span> valid_bool=<span class="keyword">true</span>;
<a name="l00781"></a>00781   <span class="keywordflow">for</span> (size_t i = 0; i &lt; qmHandles.size(); i++) {
<a name="l00782"></a>00782     valid_bool = valid_bool &amp;&amp;
<a name="l00783"></a>00783          currentQM-&gt;evaluate(*patch_data, qmHandles[i], func[i], err); <a class="code" href="group__error.html#g22b7ffc87a1a5cc19de2991d26bbc909">MSQ_ERRZERO</a>(err);
<a name="l00784"></a>00784   }
<a name="l00785"></a>00785 
<a name="l00786"></a>00786   <span class="keywordflow">return</span> valid_bool;
<a name="l00787"></a>00787 }
<a name="l00788"></a>00788 
<a name="l00789"></a>00789 
<a name="l00790"></a>00790 <span class="keywordtype">bool</span> NonSmoothDescent::compute_gradient(PatchData *patch_data, 
<a name="l00791"></a>00791                                         std::vector&lt;Vector3D&gt;&amp; gradient_out,
<a name="l00792"></a>00792                                         MsqError &amp;err)
<a name="l00793"></a>00793 {
<a name="l00794"></a>00794   <a class="code" href="group__debug.html#gc1fb4ac3396b35008642ebd22e1b4d02">MSQ_DBGOUT</a>(2) &lt;&lt; <span class="stringliteral">"Computing Gradient\n"</span>;
<a name="l00795"></a>00795 
<a name="l00796"></a>00796   <span class="keywordtype">bool</span> valid = <span class="keyword">true</span>;
<a name="l00797"></a>00797 
<a name="l00798"></a>00798 <span class="preprocessor">#ifdef NUMERICAL_GRADIENT</span>
<a name="l00799"></a>00799 <span class="preprocessor"></span>
<a name="l00800"></a>00800   <span class="keyword">const</span> <span class="keywordtype">double</span> delta = 10e-6;
<a name="l00801"></a>00801   std::vector&lt;double&gt; func(qmHandles.size()), fdelta(qmHandles.size());
<a name="l00802"></a>00802 
<a name="l00803"></a>00803   valid = this-&gt;compute_function(patch_data, func, err); <a class="code" href="group__error.html#g22b7ffc87a1a5cc19de2991d26bbc909">MSQ_ERRZERO</a>(err);
<a name="l00804"></a>00804 
<a name="l00805"></a>00805   <span class="comment">/* gradient in the x, y, z direction */</span>
<a name="l00806"></a>00806 
<a name="l00807"></a>00807   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;3;j++) {
<a name="l00808"></a>00808 
<a name="l00809"></a>00809     <span class="comment">// perturb the coordinates of the free vertex in the j direction by delta</span>
<a name="l00810"></a>00810     Vector3D delta_3( 0, 0, 0 );
<a name="l00811"></a>00811     Vector3D orig_pos = patch_data-&gt;vertex_by_index(freeVertexIndex);
<a name="l00812"></a>00812     delta_3[j] = delta;
<a name="l00813"></a>00813     patch_data-&gt;move_vertex( delta_3, freeVertexIndex, err ); 
<a name="l00814"></a>00814  
<a name="l00815"></a>00815     <span class="comment">//compute the function at the perturbed point location</span>
<a name="l00816"></a>00816     valid = valid &amp;&amp; this-&gt;compute_function(patch_data, fdelta, err);  <a class="code" href="group__error.html#g22b7ffc87a1a5cc19de2991d26bbc909">MSQ_ERRZERO</a>(err);
<a name="l00817"></a>00817 
<a name="l00818"></a>00818     <span class="comment">//compute the numerical gradient</span>
<a name="l00819"></a>00819     <span class="keywordflow">for</span> (size_t i=0;i&lt;qmHandles.size();i++) {
<a name="l00820"></a>00820        mGradient[i][j] = (fdelta[i] - func[i])/delta;
<a name="l00821"></a>00821        <span class="comment">// MSQ_DEBUG_ACTION(3,{fprintf(stdout,"  Gradient value[%d][%d]=%g\n",i,j,mGradient[i][j]);});</span>
<a name="l00822"></a>00822     }
<a name="l00823"></a>00823 
<a name="l00824"></a>00824     <span class="comment">// put the coordinates back where they belong</span>
<a name="l00825"></a>00825     patch_data-&gt;set_vertex_coordinates( orig_pos, freeVertexIndex, err );
<a name="l00826"></a>00826   }
<a name="l00827"></a>00827 
<a name="l00828"></a>00828 <span class="preprocessor">#else</span>
<a name="l00829"></a>00829 <span class="preprocessor"></span>  <span class="keywordtype">double</span> value;
<a name="l00830"></a>00830   gradient_out.resize( qmHandles.size() );
<a name="l00831"></a>00831   <span class="keywordflow">for</span> (size_t i = 0; i &lt; qmHandles.size(); i++) {
<a name="l00832"></a>00832     valid = valid &amp;&amp;
<a name="l00833"></a>00833          currentQM-&gt;evaluate_with_gradient(*patch_data, qmHandles[i], value, tmpIdx, tmpGrad, err); <a class="code" href="group__error.html#g22b7ffc87a1a5cc19de2991d26bbc909">MSQ_ERRZERO</a>(err);
<a name="l00834"></a>00834     assert(tmpIdx.size() == 1 &amp;&amp; tmpIdx[0] == freeVertexIndex);
<a name="l00835"></a>00835     gradient_out[i] = tmpGrad[0];
<a name="l00836"></a>00836   }
<a name="l00837"></a>00837 <span class="preprocessor">#endif</span>
<a name="l00838"></a>00838 <span class="preprocessor"></span>
<a name="l00839"></a>00839   <span class="keywordflow">return</span> valid;
<a name="l00840"></a>00840 }
<a name="l00841"></a>00841 
<a name="l00842"></a>00842 <span class="keywordtype">void</span> NonSmoothDescent::find_active_set( <span class="keyword">const</span> std::vector&lt;double&gt;&amp; function,
<a name="l00843"></a>00843                                         ActiveSet&amp; active_set )
<a name="l00844"></a>00844 { 
<a name="l00845"></a>00845   <span class="comment">// local parameter initialization</span>
<a name="l00846"></a>00846   <span class="keyword">const</span> <span class="keywordtype">double</span> activeEpsilon = .3e-4;
<a name="l00847"></a>00847   <span class="comment">//  activeEpsilon = .3e-8;</span>
<a name="l00848"></a>00848 
<a name="l00849"></a>00849     <span class="keywordtype">double</span>      function_val;
<a name="l00850"></a>00850     <span class="keywordtype">double</span>      active_value0;
<a name="l00851"></a>00851     <span class="keywordtype">double</span>      temp;
<a name="l00852"></a>00852 
<a name="l00853"></a>00853 <span class="comment">//    FUNCTION_TIMER_START("Find Active Set");</span>
<a name="l00854"></a>00854     <a class="code" href="group__debug.html#gc1fb4ac3396b35008642ebd22e1b4d02">MSQ_DBGOUT</a>(2) &lt;&lt; <span class="stringliteral">"\nFinding the active set\n"</span>;
<a name="l00855"></a>00855 
<a name="l00856"></a>00856     <span class="comment">/* the first function value is our initial active value */</span>
<a name="l00857"></a>00857     active_set.set( 0 );
<a name="l00858"></a>00858     active_set.true_active_value = function[0]; 
<a name="l00859"></a>00859     <span class="comment">//    MSQ_DEBUG_ACTION(3,{fprintf(stdout,"  function value[0]: %g\n",function[0]);});</span>
<a name="l00860"></a>00860 
<a name="l00861"></a>00861     <span class="comment">/* first sort out the active set... </span>
<a name="l00862"></a>00862 <span class="comment">       all vals within active_epsilon of largest val */</span>
<a name="l00863"></a>00863 
<a name="l00864"></a>00864     <span class="keywordflow">for</span> (size_t i = 1; i &lt; qmHandles.size(); i++) {
<a name="l00865"></a>00865         function_val = function[i];
<a name="l00866"></a>00866         <span class="keywordflow">if</span> (active_set.true_active_value &lt; function_val)
<a name="l00867"></a>00867           active_set.true_active_value = function_val;
<a name="l00868"></a>00868         active_value0 = function[active_set.active_ind[0]];
<a name="l00869"></a>00869         temp = fabs(function_val - active_value0);
<a name="l00870"></a>00870         <span class="comment">//        MSQ_DEBUG_ACTION(3,{fprintf(stdout,"  function value[%d]: %g\n",i,function[i]);});</span>
<a name="l00871"></a>00871         <span class="keywordflow">if</span> ( function_val &gt; active_value0 ) {  <span class="comment">// seek max_i function[i]</span>
<a name="l00872"></a>00872             <span class="keywordflow">if</span> ( temp &gt;= activeEpsilon) {
<a name="l00873"></a>00873                 active_set.set( i );   <span class="comment">// new max</span>
<a name="l00874"></a>00874             } 
<a name="l00875"></a>00875             <span class="keywordflow">else</span> {
<a name="l00876"></a>00876                 active_set.add( i, fabs(function_val - active_value0) &lt; <a class="code" href="namespaceMesquite.html#27308dfd82a6c76f4c3075ac5af1b464">EPSILON</a> );
<a name="l00877"></a>00877             }
<a name="l00878"></a>00878         } <span class="keywordflow">else</span> {
<a name="l00879"></a>00879             <span class="keywordflow">if</span> (temp &lt; activeEpsilon) {
<a name="l00880"></a>00880                 active_set.add( i, fabs(function_val - active_value0) &lt; <a class="code" href="namespaceMesquite.html#27308dfd82a6c76f4c3075ac5af1b464">EPSILON</a> );
<a name="l00881"></a>00881             }
<a name="l00882"></a>00882         }
<a name="l00883"></a>00883     }
<a name="l00884"></a>00884 
<a name="l00885"></a>00885 }
<a name="l00886"></a>00886 
<a name="l00887"></a>00887 
<a name="l00888"></a>00888 <span class="keywordtype">bool</span> NonSmoothDescent::validity_check(PatchData&amp; pd, MsqError &amp;err)
<a name="l00889"></a>00889         
<a name="l00890"></a>00890 {
<a name="l00891"></a>00891 <span class="comment">//  FUNCTION_TIMER_START("Validity Check");</span>
<a name="l00892"></a>00892 
<a name="l00893"></a>00893   <span class="comment">// ONLY FOR SIMPLICIAL MESHES - THERE SHOULD BE A VALIDITY CHECKER ASSOCIATED</span>
<a name="l00894"></a>00894   <span class="comment">// WITH MSQ ELEMENTS</span>
<a name="l00895"></a>00895   
<a name="l00896"></a>00896   <span class="comment">/* check that the simplicial mesh is still valid, based on right handedness. </span>
<a name="l00897"></a>00897 <span class="comment">       Returns a 1 or a 0 */</span>
<a name="l00898"></a>00898 
<a name="l00899"></a>00899   <span class="comment">// TODO as a first step we can switch this over to the function</span>
<a name="l00900"></a>00900   <span class="comment">// evaluation and use the rest of the code as is</span>
<a name="l00901"></a>00901   <span class="keywordtype">bool</span> valid = <span class="keyword">true</span>;
<a name="l00902"></a>00902   <span class="keywordtype">double</span> dEps = 1.e-13;
<a name="l00903"></a>00903 
<a name="l00904"></a>00904   <span class="keywordtype">double</span> x1, x2, x3, x4, y1, y2, y3, y4, z1, z2, z3, z4;
<a name="l00905"></a>00905   <span class="keyword">const</span> MsqVertex* coords = pd.get_vertex_array(err);
<a name="l00906"></a>00906 
<a name="l00907"></a>00907   <span class="keywordflow">for</span> (size_t i=0;i&lt;pd.num_elements();i++)
<a name="l00908"></a>00908   {
<a name="l00909"></a>00909     <span class="keyword">const</span> size_t* conn = pd.element_by_index(i).get_vertex_index_array();
<a name="l00910"></a>00910     coords[conn[0]].get_coordinates(x1, y1, z1);
<a name="l00911"></a>00911     coords[conn[1]].get_coordinates(x2, y2, z2);
<a name="l00912"></a>00912     coords[conn[2]].get_coordinates(x3, y3, z3);
<a name="l00913"></a>00913     coords[conn[3]].get_coordinates(x4, y4, z4);
<a name="l00914"></a>00914 
<a name="l00915"></a>00915     <span class="keywordtype">double</span> dDX2 = x2 - x1;
<a name="l00916"></a>00916     <span class="keywordtype">double</span> dDX3 = x3 - x1;
<a name="l00917"></a>00917     <span class="keywordtype">double</span> dDX4 = x4 - x1;
<a name="l00918"></a>00918 
<a name="l00919"></a>00919     <span class="keywordtype">double</span> dDY2 = y2 - y1;
<a name="l00920"></a>00920     <span class="keywordtype">double</span> dDY3 = y3 - y1;
<a name="l00921"></a>00921     <span class="keywordtype">double</span> dDY4 = y4 - y1;
<a name="l00922"></a>00922 
<a name="l00923"></a>00923     <span class="keywordtype">double</span> dDZ2 = z2 - z1;
<a name="l00924"></a>00924     <span class="keywordtype">double</span> dDZ3 = z3 - z1;
<a name="l00925"></a>00925     <span class="keywordtype">double</span> dDZ4 = z4 - z1;
<a name="l00926"></a>00926 
<a name="l00927"></a>00927       <span class="comment">/* dDet is proportional to the cell volume */</span>
<a name="l00928"></a>00928     <span class="keywordtype">double</span> dDet = dDX2*dDY3*dDZ4 + dDX3*dDY4*dDZ2 + dDX4*dDY2*dDZ3
<a name="l00929"></a>00929       - dDZ2*dDY3*dDX4 - dDZ3*dDY4*dDX2 - dDZ4*dDY2*dDX3 ;
<a name="l00930"></a>00930 
<a name="l00931"></a>00931       <span class="comment">/* Compute a length scale based on edge lengths. */</span>
<a name="l00932"></a>00932     <span class="keywordtype">double</span> dScale = ( sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) +
<a name="l00933"></a>00933                            (z1-z2)*(z1-z2)) +
<a name="l00934"></a>00934                       sqrt((x1-x3)*(x1-x3) + (y1-y3)*(y1-y3) +
<a name="l00935"></a>00935                            (z1-z3)*(z1-z3)) +
<a name="l00936"></a>00936                       sqrt((x1-x4)*(x1-x4) + (y1-y4)*(y1-y4) +
<a name="l00937"></a>00937                            (z1-z4)*(z1-z4)) +
<a name="l00938"></a>00938                       sqrt((x2-x3)*(x2-x3) + (y2-y3)*(y2-y3) +
<a name="l00939"></a>00939                            (z2-z3)*(z2-z3)) +
<a name="l00940"></a>00940                       sqrt((x2-x4)*(x2-x4) + (y2-y4)*(y2-y4) +
<a name="l00941"></a>00941                            (z2-z4)*(z2-z4)) +
<a name="l00942"></a>00942                       sqrt((x3-x4)*(x3-x4) + (y3-y4)*(y3-y4) +
<a name="l00943"></a>00943                            (z3-z4)*(z3-z4)) ) / 6.;
<a name="l00944"></a>00944 
<a name="l00945"></a>00945       <span class="comment">/* Use the length scale to get a better idea if the tet is flat or</span>
<a name="l00946"></a>00946 <span class="comment">         just really small. */</span>
<a name="l00947"></a>00947     <span class="keywordflow">if</span> (fabs(dScale) &lt; <a class="code" href="namespaceMesquite.html#27308dfd82a6c76f4c3075ac5af1b464">EPSILON</a>)
<a name="l00948"></a>00948     {
<a name="l00949"></a>00949       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00950"></a>00950     }
<a name="l00951"></a>00951     <span class="keywordflow">else</span>
<a name="l00952"></a>00952     {
<a name="l00953"></a>00953       dDet /= (dScale*dScale*dScale);
<a name="l00954"></a>00954     }
<a name="l00955"></a>00955 
<a name="l00956"></a>00956     <span class="keywordflow">if</span> (dDet &gt; dEps)
<a name="l00957"></a>00957     {
<a name="l00958"></a>00958       valid = <span class="keyword">true</span>;
<a name="l00959"></a>00959     }
<a name="l00960"></a>00960     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dDet &lt; -dEps)
<a name="l00961"></a>00961     {
<a name="l00962"></a>00962       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00963"></a>00963     }
<a name="l00964"></a>00964     <span class="keywordflow">else</span>
<a name="l00965"></a>00965     {
<a name="l00966"></a>00966       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00967"></a>00967     }
<a name="l00968"></a>00968   }  <span class="comment">// end for i=1,numElements</span>
<a name="l00969"></a>00969   
<a name="l00970"></a>00970   <span class="comment">//  MSQ_DEBUG_ACTION(2,{fprintf(stdout,"Mesh Validity is: %d \n",valid);});</span>
<a name="l00971"></a>00971   
<a name="l00972"></a>00972 <span class="comment">//  FUNCTION_TIMER_END();</span>
<a name="l00973"></a>00973   <span class="keywordflow">return</span>(valid);
<a name="l00974"></a>00974 }
<a name="l00975"></a>00975 
<a name="l00976"></a>00976 
<a name="l00977"></a>00977 <span class="keywordtype">void</span> NonSmoothDescent::get_active_directions( <span class="keyword">const</span> std::vector&lt;Vector3D&gt;&amp; mGradient, 
<a name="l00978"></a>00978                                               std::vector&lt;Vector3D&gt;&amp; dir,
<a name="l00979"></a>00979                                               MsqError &amp;<span class="comment">/*err*/</span>)
<a name="l00980"></a>00980 {
<a name="l00981"></a>00981     <span class="keyword">const</span> size_t num_active = mActive.<a class="code" href="structMesquite_1_1NonSmoothDescent_1_1ActiveSet.html#c2806c3f7b66fbe85f3382ad3e4c8fc9">active_ind</a>.size();
<a name="l00982"></a>00982     dir.resize(num_active);
<a name="l00983"></a>00983     <span class="keywordflow">for</span> (size_t i = 0; i &lt; num_active; i++) {
<a name="l00984"></a>00984       dir[i] = mGradient[mActive.<a class="code" href="structMesquite_1_1NonSmoothDescent_1_1ActiveSet.html#c2806c3f7b66fbe85f3382ad3e4c8fc9">active_ind</a>[i]];
<a name="l00985"></a>00985     }
<a name="l00986"></a>00986 }
<a name="l00987"></a>00987 
<a name="l00988"></a>00988 
<a name="l00989"></a>00989 <span class="keywordtype">bool</span> NonSmoothDescent::check_vector_dots( <span class="keyword">const</span> std::vector&lt;Vector3D&gt;&amp; vec,
<a name="l00990"></a>00990                                           <span class="keyword">const</span> Vector3D&amp; normal,
<a name="l00991"></a>00991                                           MsqError &amp;<span class="comment">/*err*/</span>)
<a name="l00992"></a>00992 {
<a name="l00993"></a>00993     <span class="keywordtype">double</span> test_dot = vec[0] % normal;
<a name="l00994"></a>00994     <span class="keywordtype">unsigned</span> ind = 1;
<a name="l00995"></a>00995     <span class="keywordflow">while</span> ( (fabs(test_dot) &lt; <a class="code" href="namespaceMesquite.html#27308dfd82a6c76f4c3075ac5af1b464">EPSILON</a>) &amp;&amp; (ind &lt; vec.size()) ) {
<a name="l00996"></a>00996       test_dot = vec[ind] % normal;
<a name="l00997"></a>00997       ind++;
<a name="l00998"></a>00998     }
<a name="l00999"></a>00999       
<a name="l01000"></a>01000     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=ind;i&lt;vec.size();i++) {
<a name="l01001"></a>01001        <span class="keywordtype">double</span> dot = vec[i] % normal;
<a name="l01002"></a>01002        <span class="keywordflow">if</span> ( ((dot&gt;0 &amp;&amp; test_dot&lt;0) || (dot&lt;0 &amp;&amp; test_dot&gt;0)) &amp;&amp;
<a name="l01003"></a>01003             (fabs(dot)&gt;<a class="code" href="namespaceMesquite.html#27308dfd82a6c76f4c3075ac5af1b464">EPSILON</a>)) {
<a name="l01004"></a>01004           <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01005"></a>01005 
<a name="l01006"></a>01006        }
<a name="l01007"></a>01007     }
<a name="l01008"></a>01008     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01009"></a>01009 }
<a name="l01010"></a>01010 
<a name="l01011"></a>01011 
<a name="l01012"></a>01012 
<a name="l01013"></a>01013 <span class="keywordtype">bool</span> NonSmoothDescent::convex_hull_test(<span class="keyword">const</span> std::vector&lt;Vector3D&gt;&amp; vec, MsqError &amp;err)
<a name="l01014"></a>01014 {
<a name="l01015"></a>01015 <span class="comment">//    int ierr;</span>
<a name="l01016"></a>01016     <span class="keywordtype">bool</span> equil = <span class="keyword">false</span>;
<a name="l01017"></a>01017     Direction dir_done;
<a name="l01018"></a>01018     Status status = MSQ_CHECK_Z_COORD_DIRECTION;
<a name="l01019"></a>01019     Vector3D pt1, pt2, pt3, normal;
<a name="l01020"></a>01020 
<a name="l01021"></a>01021     <span class="comment">/* tries to determine equilibrium for the 3D case */</span>
<a name="l01022"></a>01022 
<a name="l01023"></a>01023     <span class="keywordflow">if</span> (vec.size() &lt;= 2) status = MSQ_NO_EQUIL;
<a name="l01024"></a>01024 
<a name="l01025"></a>01025     <span class="keywordflow">while</span> ((status != MSQ_EQUIL) &amp;&amp; (status != MSQ_NO_EQUIL) &amp;&amp; 
<a name="l01026"></a>01026            (status != MSQ_HULL_TEST_ERROR)) {
<a name="l01027"></a>01027        <span class="keywordflow">if</span> (status == MSQ_CHECK_Z_COORD_DIRECTION) {
<a name="l01028"></a>01028           this-&gt;find_plane_points(MSQ_ZDIR, MSQ_YDIR, 
<a name="l01029"></a>01029                           vec, pt1, pt2, pt3, status, err);
<a name="l01030"></a>01030           dir_done = MSQ_ZDIR;
<a name="l01031"></a>01031        }
<a name="l01032"></a>01032        <span class="keywordflow">if</span> (status == MSQ_CHECK_Y_COORD_DIRECTION) {
<a name="l01033"></a>01033           this-&gt;find_plane_points(MSQ_YDIR, MSQ_XDIR, 
<a name="l01034"></a>01034                           vec, pt1, pt2, pt3, status, err);
<a name="l01035"></a>01035           dir_done = MSQ_YDIR;
<a name="l01036"></a>01036        }
<a name="l01037"></a>01037        <span class="keywordflow">if</span> (status == MSQ_CHECK_X_COORD_DIRECTION) {
<a name="l01038"></a>01038           this-&gt;find_plane_points(MSQ_XDIR, MSQ_ZDIR, 
<a name="l01039"></a>01039                           vec, pt1, pt2, pt3, status, err);
<a name="l01040"></a>01040           dir_done = MSQ_XDIR;
<a name="l01041"></a>01041        }
<a name="l01042"></a>01042        <span class="keywordflow">if</span> (status == MSQ_TWO_PT_PLANE) {
<a name="l01043"></a>01043           pt3 = Vector3D(0,0,0);
<a name="l01044"></a>01044        }
<a name="l01045"></a>01045        <span class="keywordflow">if</span> ((status == MSQ_TWO_PT_PLANE) || (status == MSQ_THREE_PT_PLANE)){
<a name="l01046"></a>01046            this-&gt;find_plane_normal(pt1,pt2,pt3,normal,err); 
<a name="l01047"></a>01047            equil = this-&gt;check_vector_dots(vec,normal,err); 
<a name="l01048"></a>01048            <span class="keywordflow">if</span> (equil) {
<a name="l01049"></a>01049              <span class="keywordflow">switch</span>(dir_done){
<a name="l01050"></a>01050              <span class="keywordflow">case</span> MSQ_ZDIR:
<a name="l01051"></a>01051                equil = <span class="keyword">false</span>; status = MSQ_CHECK_Y_COORD_DIRECTION;
<a name="l01052"></a>01052                <span class="keywordflow">break</span>;
<a name="l01053"></a>01053              <span class="keywordflow">case</span> MSQ_YDIR:
<a name="l01054"></a>01054                equil = <span class="keyword">false</span>; status = MSQ_CHECK_X_COORD_DIRECTION;
<a name="l01055"></a>01055                <span class="keywordflow">break</span>;
<a name="l01056"></a>01056              <span class="keywordflow">case</span> MSQ_XDIR:
<a name="l01057"></a>01057                equil = <span class="keyword">true</span>; status = MSQ_EQUIL;
<a name="l01058"></a>01058              }
<a name="l01059"></a>01059            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (equil == 0) {
<a name="l01060"></a>01060                status = MSQ_NO_EQUIL;
<a name="l01061"></a>01061            } <span class="keywordflow">else</span> {
<a name="l01062"></a>01062               <a class="code" href="group__error.html#g2a2fbc6c2b94ad06a287ec11ea469868">MSQ_SETERR</a>(err)(<span class="stringliteral">"equil flag not set to 0 or 1"</span>,<a class="code" href="classMesquite_1_1MsqError.html#1d7c4cd95eccb8d09c39504ff0c2ec0b53898f70c932e78bfa7337a1956d0a15">MsqError::INVALID_STATE</a>);
<a name="l01063"></a>01063            }
<a name="l01064"></a>01064        }
<a name="l01065"></a>01065     }
<a name="l01066"></a>01066     <span class="keywordflow">switch</span> (status){
<a name="l01067"></a>01067     <span class="keywordflow">case</span> MSQ_NO_EQUIL:
<a name="l01068"></a>01068       <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"Not an equilibrium point\n"</span>);
<a name="l01069"></a>01069       equil = <span class="keyword">false</span>; 
<a name="l01070"></a>01070       <span class="keywordflow">break</span>;
<a name="l01071"></a>01071     <span class="keywordflow">case</span> MSQ_EQUIL:
<a name="l01072"></a>01072       <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"An equilibrium point\n"</span>);
<a name="l01073"></a>01073       equil = <span class="keyword">true</span>;
<a name="l01074"></a>01074       <span class="keywordflow">break</span>;
<a name="l01075"></a>01075     <span class="keywordflow">default</span>:
<a name="l01076"></a>01076       <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"Failed to determine equil or not; status = %d\n"</span>,status);
<a name="l01077"></a>01077     }
<a name="l01078"></a>01078 <span class="comment">//    FUNCTION_TIMER_END();</span>
<a name="l01079"></a>01079     <span class="keywordflow">return</span> (equil);
<a name="l01080"></a>01080 }
<a name="l01081"></a>01081 
<a name="l01082"></a>01082 <span class="keywordtype">void</span> NonSmoothDescent::form_grammian(<span class="keyword">const</span> std::vector&lt;Vector3D&gt;&amp; vec, MsqError &amp;err)
<a name="l01083"></a>01083 {
<a name="l01084"></a>01084    <span class="comment">/* form the grammian with the dot products of the gradients */</span>
<a name="l01085"></a>01085    <span class="keyword">const</span> size_t num_active = mActive.<a class="code" href="structMesquite_1_1NonSmoothDescent_1_1ActiveSet.html#c2806c3f7b66fbe85f3382ad3e4c8fc9">active_ind</a>.size();
<a name="l01086"></a>01086    mG.<a class="code" href="classMesquite_1_1NonSmoothDescent_1_1SymmetricMatrix.html#c59dc32bcef95cebe5bcea6e09353767">resize</a>( num_active );
<a name="l01087"></a>01087    <span class="keywordflow">for</span> (size_t i = 0; i &lt; num_active; i++) 
<a name="l01088"></a>01088       <span class="keywordflow">for</span> (size_t j = i; j &lt; num_active; j++) 
<a name="l01089"></a>01089          mG(i,j) = vec[i] % vec[j];
<a name="l01090"></a>01090 }
<a name="l01091"></a>01091 
<a name="l01092"></a>01092 <span class="keywordtype">bool</span> NonSmoothDescent::check_equilibrium(OptStatus&amp; status, MsqError &amp;err)
<a name="l01093"></a>01093 {
<a name="l01094"></a>01094     std::vector&lt;Vector3D&gt; dir;
<a name="l01095"></a>01095  
<a name="l01096"></a>01096     <span class="comment">//TODO - this subroutine is no longer clear to me... is it still</span>
<a name="l01097"></a>01097     <span class="comment">// appropriate for quads and hexes?  I think it might be in 2D, but</span>
<a name="l01098"></a>01098     <span class="comment">// 3D is less clear.  Is there a more general algorithm to use?</span>
<a name="l01099"></a>01099     <span class="comment">// ask Todd/check in numerical optimization</span>
<a name="l01100"></a>01100 
<a name="l01101"></a>01101     <span class="keywordtype">bool</span> equil = <span class="keyword">false</span>;
<a name="l01102"></a>01102     <span class="keyword">const</span> size_t num_active = mActive.<a class="code" href="structMesquite_1_1NonSmoothDescent_1_1ActiveSet.html#c2806c3f7b66fbe85f3382ad3e4c8fc9">active_ind</a>.size();;
<a name="l01103"></a>01103 
<a name="l01104"></a>01104     <span class="keywordflow">if</span> (num_active == qmHandles.size())
<a name="l01105"></a>01105     {
<a name="l01106"></a>01106          equil = <span class="keyword">true</span>; 
<a name="l01107"></a>01107          status = MSQ_EQUILIBRIUM;
<a name="l01108"></a>01108          <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"All the function values are in the active set\n"</span>); 
<a name="l01109"></a>01109     }
<a name="l01110"></a>01110 
<a name="l01111"></a>01111     <span class="comment">/* set up the active mGradient directions */</span>
<a name="l01112"></a>01112     this-&gt;get_active_directions(mGradient,dir,err); <a class="code" href="group__error.html#g22b7ffc87a1a5cc19de2991d26bbc909">MSQ_ERRZERO</a>(err);
<a name="l01113"></a>01113 
<a name="l01114"></a>01114     <span class="comment">/* normalize the active directions */</span>
<a name="l01115"></a>01115     <span class="keywordflow">for</span> (size_t j=0;j&lt;num_active;j++)
<a name="l01116"></a>01116       dir[j] /= dir[j].<a class="code" href="namespaceMesquite.html#de029f9ffa0ccacd817155a2fea670e4">length</a>();
<a name="l01117"></a>01117  
<a name="l01118"></a>01118     equil = this-&gt;convex_hull_test(dir,err);
<a name="l01119"></a>01119     <span class="keywordflow">if</span> (equil) 
<a name="l01120"></a>01120       status = MSQ_EQUILIBRIUM;
<a name="l01121"></a>01121     
<a name="l01122"></a>01122     <span class="keywordflow">return</span> equil;
<a name="l01123"></a>01123 }
<a name="l01124"></a>01124 
<a name="l01125"></a>01125 
<a name="l01126"></a>01126 <span class="keyword">static</span> <span class="keywordtype">double</span> condition3x3(<span class="keyword">const</span> <span class="keywordtype">double</span> A[9]) 
<a name="l01127"></a>01127 {
<a name="l01128"></a>01128 <span class="comment">//   int ierr;</span>
<a name="l01129"></a>01129    <span class="keywordtype">double</span> a11, a12, a13;
<a name="l01130"></a>01130    <span class="keywordtype">double</span> a21, a22, a23;
<a name="l01131"></a>01131    <span class="keywordtype">double</span> a31, a32, a33;
<a name="l01132"></a>01132 <span class="comment">//   double s1, s2, s4, s3, t0;</span>
<a name="l01133"></a>01133    <span class="keywordtype">double</span> s1, s2, s3;
<a name="l01134"></a>01134    <span class="keywordtype">double</span> denom;
<a name="l01135"></a>01135 <span class="comment">//   double one = 1.0;</span>
<a name="l01136"></a>01136    <span class="keywordtype">double</span> temp;
<a name="l01137"></a>01137    <span class="keywordtype">bool</span> zero_denom = <span class="keyword">true</span>;
<a name="l01138"></a>01138 
<a name="l01139"></a>01139    a11 = A[0]; a12=A[1]; a13=A[2];
<a name="l01140"></a>01140    a21 = A[3]; a22=A[4]; a23=A[5];
<a name="l01141"></a>01141    a31 = A[6]; a32=A[7]; a33=A[8];
<a name="l01142"></a>01142 
<a name="l01143"></a>01143 
<a name="l01144"></a>01144    denom = -a11*a22*a33+a11*a23*a32+a21*a12*a33-a21*a13*a32-
<a name="l01145"></a>01145             a31*a12*a23+a31*a13*a22;
<a name="l01146"></a>01146 
<a name="l01147"></a>01147    <span class="keywordflow">if</span> ( (fabs(a11) &gt; <a class="code" href="namespaceMesquite.html#27308dfd82a6c76f4c3075ac5af1b464">EPSILON</a>) &amp;&amp; 
<a name="l01148"></a>01148         (fabs(denom/a11) &gt; <a class="code" href="namespaceMesquite.html#27308dfd82a6c76f4c3075ac5af1b464">EPSILON</a>)) {
<a name="l01149"></a>01149          zero_denom = <span class="keyword">false</span>;
<a name="l01150"></a>01150    }
<a name="l01151"></a>01151    <span class="keywordflow">if</span> ( (fabs(a22) &gt; <a class="code" href="namespaceMesquite.html#27308dfd82a6c76f4c3075ac5af1b464">EPSILON</a>) &amp;&amp; 
<a name="l01152"></a>01152         (fabs(denom/a22) &gt; <a class="code" href="namespaceMesquite.html#27308dfd82a6c76f4c3075ac5af1b464">EPSILON</a>)) {
<a name="l01153"></a>01153          zero_denom = <span class="keyword">false</span>;
<a name="l01154"></a>01154    }       
<a name="l01155"></a>01155    <span class="keywordflow">if</span> ( (fabs(a33) &gt; <a class="code" href="namespaceMesquite.html#27308dfd82a6c76f4c3075ac5af1b464">EPSILON</a>) &amp;&amp; 
<a name="l01156"></a>01156         (fabs(denom/a33) &gt; <a class="code" href="namespaceMesquite.html#27308dfd82a6c76f4c3075ac5af1b464">EPSILON</a>)) {
<a name="l01157"></a>01157          zero_denom = <span class="keyword">false</span>;
<a name="l01158"></a>01158    }
<a name="l01159"></a>01159 
<a name="l01160"></a>01160    <span class="keywordflow">if</span> (zero_denom) {
<a name="l01161"></a>01161      <span class="keywordflow">return</span> HUGE_VAL;
<a name="l01162"></a>01162    } 
<a name="l01163"></a>01163    <span class="keywordflow">else</span> {
<a name="l01164"></a>01164      s1 = sqrt(a11*a11 + a12*a12 + a13*a13 + 
<a name="l01165"></a>01165                a21*a21 + a22*a22 + a23*a23 + 
<a name="l01166"></a>01166                a31*a31 + a32*a32 + a33*a33);
<a name="l01167"></a>01167 
<a name="l01168"></a>01168 
<a name="l01169"></a>01169      temp = (-a22*a33+a23*a32)/denom;
<a name="l01170"></a>01170      s3 = temp*temp;
<a name="l01171"></a>01171      temp =(a12*a33-a13*a32)/denom;
<a name="l01172"></a>01172      s3 += temp*temp;
<a name="l01173"></a>01173      temp = (a12*a23-a13*a22)/denom;
<a name="l01174"></a>01174      s3 += temp*temp;
<a name="l01175"></a>01175      temp = (a21*a33-a23*a31)/denom;
<a name="l01176"></a>01176      s3 += temp*temp;
<a name="l01177"></a>01177      temp = (a11*a33-a13*a31)/denom;
<a name="l01178"></a>01178      s3 += temp*temp;
<a name="l01179"></a>01179      temp = (a11*a23-a13*a21)/denom;
<a name="l01180"></a>01180      s3 += temp*temp;
<a name="l01181"></a>01181      temp = (a21*a32-a22*a31)/denom;
<a name="l01182"></a>01182      s3 += temp*temp;
<a name="l01183"></a>01183      temp = (-a11*a32+a12*a31)/denom;
<a name="l01184"></a>01184      s3 += temp*temp;
<a name="l01185"></a>01185      temp = (-a11*a22+a12*a21)/denom;
<a name="l01186"></a>01186      s3 += temp*temp;
<a name="l01187"></a>01187 
<a name="l01188"></a>01188 
<a name="l01189"></a>01189      s2 = sqrt(s3);
<a name="l01190"></a>01190      <span class="keywordflow">return</span> s1*s2;
<a name="l01191"></a>01191    }
<a name="l01192"></a>01192 }
<a name="l01193"></a>01193 
<a name="l01194"></a><a class="code" href="classMesquite_1_1NonSmoothDescent_1_1SymmetricMatrix.html#f10201cca8744273bf8f5aae53b50f02">01194</a> <span class="keywordtype">double</span> <a class="code" href="classMesquite_1_1NonSmoothDescent_1_1SymmetricMatrix.html#f10201cca8744273bf8f5aae53b50f02">NonSmoothDescent::SymmetricMatrix::condition3x3</a>()<span class="keyword"> const</span>
<a name="l01195"></a>01195 <span class="keyword"></span>{
<a name="l01196"></a>01196   <span class="keywordtype">double</span> values[9] = { 
<a name="l01197"></a>01197     <a class="code" href="classMesquite_1_1NonSmoothDescent_1_1SymmetricMatrix.html#9ee24aa38fbccec95ecc89d9b8545739">operator()</a>(0,0), <a class="code" href="classMesquite_1_1NonSmoothDescent_1_1SymmetricMatrix.html#9ee24aa38fbccec95ecc89d9b8545739">operator()</a>(0,1), <a class="code" href="classMesquite_1_1NonSmoothDescent_1_1SymmetricMatrix.html#9ee24aa38fbccec95ecc89d9b8545739">operator()</a>(0,2),
<a name="l01198"></a>01198     <a class="code" href="classMesquite_1_1NonSmoothDescent_1_1SymmetricMatrix.html#9ee24aa38fbccec95ecc89d9b8545739">operator()</a>(1,0), <a class="code" href="classMesquite_1_1NonSmoothDescent_1_1SymmetricMatrix.html#9ee24aa38fbccec95ecc89d9b8545739">operator()</a>(1,1), <a class="code" href="classMesquite_1_1NonSmoothDescent_1_1SymmetricMatrix.html#9ee24aa38fbccec95ecc89d9b8545739">operator()</a>(1,2),
<a name="l01199"></a>01199     <a class="code" href="classMesquite_1_1NonSmoothDescent_1_1SymmetricMatrix.html#9ee24aa38fbccec95ecc89d9b8545739">operator()</a>(2,0), <a class="code" href="classMesquite_1_1NonSmoothDescent_1_1SymmetricMatrix.html#9ee24aa38fbccec95ecc89d9b8545739">operator()</a>(2,1), <a class="code" href="classMesquite_1_1NonSmoothDescent_1_1SymmetricMatrix.html#9ee24aa38fbccec95ecc89d9b8545739">operator()</a>(2,2)
<a name="l01200"></a>01200   };
<a name="l01201"></a>01201   <span class="keywordflow">return</span> Mesquite::condition3x3( values );
<a name="l01202"></a>01202 }
<a name="l01203"></a>01203 
<a name="l01204"></a>01204 <span class="keywordtype">void</span> NonSmoothDescent::singular_test(<span class="keywordtype">int</span> n, <span class="keyword">const</span> <a class="code" href="classMesquite_1_1Matrix3D.html">Matrix3D</a>&amp;  A, <span class="keywordtype">bool</span>&amp; singular, <a class="code" href="classMesquite_1_1MsqError.html">MsqError</a> &amp;err) 
<a name="l01205"></a>01205 {
<a name="l01206"></a>01206 <span class="comment">//    int test;</span>
<a name="l01207"></a>01207 <span class="comment">//    double determinant;</span>
<a name="l01208"></a>01208     <span class="keywordtype">double</span> cond;
<a name="l01209"></a>01209 
<a name="l01210"></a>01210     <span class="keywordflow">if</span> ((n&gt;3) || (n&lt;1)) {
<a name="l01211"></a>01211       <a class="code" href="group__error.html#g2a2fbc6c2b94ad06a287ec11ea469868">MSQ_SETERR</a>(err)(<span class="stringliteral">"Singular test works only for n=1 to n=3"</span>,<a class="code" href="classMesquite_1_1MsqError.html#1d7c4cd95eccb8d09c39504ff0c2ec0bb8acffa94cfc8084595d01a9aae197b6">MsqError::INVALID_ARG</a>);
<a name="l01212"></a>01212       <span class="keywordflow">return</span>;
<a name="l01213"></a>01213     }
<a name="l01214"></a>01214 
<a name="l01215"></a>01215     singular = <span class="keyword">true</span>;
<a name="l01216"></a>01216     <span class="keywordflow">switch</span>(n) {
<a name="l01217"></a>01217     <span class="keywordflow">case</span> 1:
<a name="l01218"></a>01218         <span class="keywordflow">if</span> (A[0][0] &gt; 0) singular = <span class="keyword">false</span>;
<a name="l01219"></a>01219         <span class="keywordflow">break</span>;
<a name="l01220"></a>01220     <span class="keywordflow">case</span> 2:
<a name="l01221"></a>01221         <span class="keywordflow">if</span> (fabs(A[0][0]*A[1][1] - A[0][1]*A[1][0]) &gt; <a class="code" href="namespaceMesquite.html#27308dfd82a6c76f4c3075ac5af1b464">EPSILON</a>)           
<a name="l01222"></a>01222             singular = <span class="keyword">false</span>;
<a name="l01223"></a>01223         <span class="keywordflow">break</span>;
<a name="l01224"></a>01224     <span class="keywordflow">case</span> 3:
<a name="l01225"></a>01225        <span class="comment">/* calculate the condition number */</span>
<a name="l01226"></a>01226         cond = <a class="code" href="classMesquite_1_1NonSmoothDescent_1_1SymmetricMatrix.html#f10201cca8744273bf8f5aae53b50f02">condition3x3</a>(A[0]); 
<a name="l01227"></a>01227         <span class="keywordflow">if</span> (cond &lt; 1E14) singular=<span class="keyword">false</span>;
<a name="l01228"></a>01228         <span class="keywordflow">break</span>;
<a name="l01229"></a>01229     }
<a name="l01230"></a>01230 }
<a name="l01231"></a>01231 
<a name="l01232"></a>01232 
<a name="l01233"></a>01233 <span class="keywordtype">void</span> NonSmoothDescent::form_PD_grammian(MsqError &amp;err)
<a name="l01234"></a>01234 {
<a name="l01235"></a>01235     <span class="keywordtype">int</span>  i,j,k;
<a name="l01236"></a>01236     <span class="keywordtype">int</span>  g_ind_1;
<a name="l01237"></a>01237     <span class="keywordtype">bool</span>  singular = <span class="keyword">false</span>;
<a name="l01238"></a>01238 
<a name="l01239"></a>01239     <span class="keyword">const</span> <span class="keywordtype">int</span> num_active = mActive.active_ind.size();
<a name="l01240"></a>01240         
<a name="l01241"></a>01241     <span class="comment">/* this assumes the grammian has been formed */</span>
<a name="l01242"></a>01242     <span class="keywordflow">for</span> (i=0;i&lt;num_active;i++) {
<a name="l01243"></a>01243       <span class="keywordflow">for</span> (j=i;j&lt;num_active;j++) {
<a name="l01244"></a>01244         <span class="keywordflow">if</span> (mG(i,j)==-1) {
<a name="l01245"></a>01245           <a class="code" href="group__error.html#g2a2fbc6c2b94ad06a287ec11ea469868">MSQ_SETERR</a>(err)(<span class="stringliteral">"Grammian not computed properly"</span>,<a class="code" href="classMesquite_1_1MsqError.html#1d7c4cd95eccb8d09c39504ff0c2ec0b53898f70c932e78bfa7337a1956d0a15">MsqError::INVALID_STATE</a>);
<a name="l01246"></a>01246           <span class="keywordflow">return</span>;
<a name="l01247"></a>01247         }
<a name="l01248"></a>01248       }
<a name="l01249"></a>01249     }
<a name="l01250"></a>01250 
<a name="l01251"></a>01251     <span class="comment">/* use the first gradient in the active set */</span>
<a name="l01252"></a>01252     g_ind_1 = 0;
<a name="l01253"></a>01253     mPDG[0][0] = mG(0,0);
<a name="l01254"></a>01254     pdgInd[0] = mActive.active_ind[0];
<a name="l01255"></a>01255 
<a name="l01256"></a>01256     <span class="comment">/* test the rest and add them as appropriate */</span>
<a name="l01257"></a>01257     k = 1; i = 1;
<a name="l01258"></a>01258     <span class="keywordflow">while</span>( (k&lt;3) &amp;&amp; (i &lt; num_active) ) {
<a name="l01259"></a>01259         mPDG[0][k] = mPDG[k][0] = mG(0,i);
<a name="l01260"></a>01260         mPDG[k][k] = mG(i,i);
<a name="l01261"></a>01261         <span class="keywordflow">if</span> ( k == 2) { <span class="comment">/* add the dot product of g1 and g2 */</span>
<a name="l01262"></a>01262            mPDG[1][k] = mPDG[k][1] = mG(g_ind_1,i);
<a name="l01263"></a>01263         }
<a name="l01264"></a>01264         this-&gt;singular_test(k+1,mPDG,singular,err);
<a name="l01265"></a>01265         <span class="keywordflow">if</span> (!singular) {
<a name="l01266"></a>01266            pdgInd[k] = mActive.active_ind[i];
<a name="l01267"></a>01267            <span class="keywordflow">if</span> (k==1) g_ind_1 = i;
<a name="l01268"></a>01268            k++;
<a name="l01269"></a>01269         }
<a name="l01270"></a>01270         i++;
<a name="l01271"></a>01271     }
<a name="l01272"></a>01272 }
<a name="l01273"></a>01273 
<a name="l01274"></a>01274 
<a name="l01275"></a>01275 <span class="keywordtype">void</span> NonSmoothDescent::search_edges_faces( <span class="keyword">const</span> Vector3D* dir, Vector3D&amp; mSearch, MsqError &amp;err)
<a name="l01276"></a>01276 {
<a name="l01277"></a>01277     <span class="keywordtype">bool</span> viable;
<a name="l01278"></a>01278     <span class="keywordtype">double</span> a,b,denom;
<a name="l01279"></a>01279     Vector3D g_bar;
<a name="l01280"></a>01280     Vector3D temp_search(0,0,0); <span class="comment">/* initialize the search direction to 0,0 */</span>
<a name="l01281"></a>01281     <span class="keywordtype">double</span> projection, min_projection;
<a name="l01282"></a>01282 
<a name="l01283"></a>01283     <span class="keyword">const</span> size_t num_active = mActive.active_ind.size();;
<a name="l01284"></a>01284 
<a name="l01285"></a>01285     <span class="comment">/* Check for viable faces */</span>
<a name="l01286"></a>01286     min_projection = HUGE_VAL;
<a name="l01287"></a>01287     <span class="keywordflow">for</span> (size_t i=0; i&lt;num_active; i++) {
<a name="l01288"></a>01288         <span class="comment">/* FACE I */</span>
<a name="l01289"></a>01289         viable = <span class="keyword">true</span>;
<a name="l01290"></a>01290 
<a name="l01291"></a>01291         <span class="comment">/* test the viability */</span>
<a name="l01292"></a>01292         <span class="keywordflow">for</span> (size_t j=0;j&lt;num_active;j++) {       <span class="comment">/* lagrange multipliers&gt;0 */</span>
<a name="l01293"></a>01293              <span class="keywordflow">if</span> (mG(j,i) &lt; 0) 
<a name="l01294"></a>01294                   viable = <span class="keyword">false</span>;
<a name="l01295"></a>01295         }
<a name="l01296"></a>01296        
<a name="l01297"></a>01297         <span class="comment">/* find the minimum of viable directions */</span>
<a name="l01298"></a>01298         <span class="keywordflow">if</span> ((viable) &amp;&amp; (mG(i,i) &lt; min_projection)) {
<a name="l01299"></a>01299             min_projection = mG(i,i);
<a name="l01300"></a>01300             temp_search = dir[i];
<a name="l01301"></a>01301             mSteepest = mActive.active_ind[i];
<a name="l01302"></a>01302         }
<a name="l01303"></a>01303     
<a name="l01304"></a>01304        <span class="comment">/* INTERSECTION IJ */</span>
<a name="l01305"></a>01305        <span class="keywordflow">for</span> (size_t j=i+1; j&lt;num_active; j++) {
<a name="l01306"></a>01306           viable = <span class="keyword">true</span>;
<a name="l01307"></a>01307 
<a name="l01308"></a>01308           <span class="comment">/* find the coefficients of the intersection </span>
<a name="l01309"></a>01309 <span class="comment">             and test the viability */</span>
<a name="l01310"></a>01310           denom = 2*mG(i,j) - mG(i,i) - mG(j,j);
<a name="l01311"></a>01311           a = b = 0;
<a name="l01312"></a>01312           <span class="keywordflow">if</span> (fabs(denom) &gt; <a class="code" href="namespaceMesquite.html#27308dfd82a6c76f4c3075ac5af1b464">EPSILON</a>) {
<a name="l01313"></a>01313              b = (mG(i,j) - mG(i,i))/denom;
<a name="l01314"></a>01314              a = 1 - b;
<a name="l01315"></a>01315              <span class="keywordflow">if</span> ((b &lt; 0) || (b &gt; 1)) <span class="comment">/* 0 &lt; b &lt; 1 */</span>
<a name="l01316"></a>01316                  viable = <span class="keyword">false</span>;  
<a name="l01317"></a>01317              <span class="keywordflow">for</span> (size_t k=0;k&lt;num_active;k++) {       <span class="comment">/* lagrange multipliers&gt;0 */</span>
<a name="l01318"></a>01318                  <span class="keywordflow">if</span> ((a*mG(k,i) + b*mG(k,j)) &lt;= 0) 
<a name="l01319"></a>01319                      viable = <span class="keyword">false</span>;
<a name="l01320"></a>01320              }
<a name="l01321"></a>01321           } <span class="keywordflow">else</span> {
<a name="l01322"></a>01322              viable = <span class="keyword">false</span>;                        <span class="comment">/* Linearly dependent */</span>
<a name="l01323"></a>01323           }
<a name="l01324"></a>01324 
<a name="l01325"></a>01325           <span class="comment">/* find the minimum of viable directions */</span>
<a name="l01326"></a>01326           <span class="keywordflow">if</span> (viable) {
<a name="l01327"></a>01327              g_bar = a * dir[i] + b * dir[j];
<a name="l01328"></a>01328              projection = g_bar % g_bar;
<a name="l01329"></a>01329              <span class="keywordflow">if</span> (projection &lt; min_projection) {
<a name="l01330"></a>01330                 min_projection = projection;
<a name="l01331"></a>01331                 temp_search = g_bar;
<a name="l01332"></a>01332                 mSteepest = mActive.active_ind[i];
<a name="l01333"></a>01333              }
<a name="l01334"></a>01334           }
<a name="l01335"></a>01335        }
<a name="l01336"></a>01336     }
<a name="l01337"></a>01337     <span class="keywordflow">if</span> (optStatus != MSQ_EQUILIBRIUM) {
<a name="l01338"></a>01338         mSearch = temp_search;
<a name="l01339"></a>01339     }
<a name="l01340"></a>01340 }         
<a name="l01341"></a>01341 
<a name="l01342"></a>01342 
<a name="l01343"></a>01343  <span class="keywordtype">bool</span> NonSmoothDescent::solve2x2( <span class="keywordtype">double</span> a11, <span class="keywordtype">double</span> a12,
<a name="l01344"></a>01344                                   <span class="keywordtype">double</span> a21, <span class="keywordtype">double</span> a22, 
<a name="l01345"></a>01345                                   <span class="keywordtype">double</span> b1, <span class="keywordtype">double</span> b2,
<a name="l01346"></a>01346                                   <span class="keywordtype">double</span> x[2], MsqError &amp;<span class="comment">/*err*/</span>)
<a name="l01347"></a>01347 {
<a name="l01348"></a>01348     <span class="keywordtype">double</span> factor;
<a name="l01349"></a>01349 
<a name="l01350"></a>01350     <span class="comment">/* if the system is not singular, solve it */</span>
<a name="l01351"></a>01351     <span class="keywordflow">if</span> (fabs(a11*a22 - a21*a12) &gt; <a class="code" href="namespaceMesquite.html#27308dfd82a6c76f4c3075ac5af1b464">EPSILON</a>) {
<a name="l01352"></a>01352         <span class="keywordflow">if</span> (fabs(a11) &gt; <a class="code" href="namespaceMesquite.html#27308dfd82a6c76f4c3075ac5af1b464">EPSILON</a>) {
<a name="l01353"></a>01353             factor = (a21/a11);
<a name="l01354"></a>01354             x[1] = (b2 - factor*b1)/(a22 - factor*a12);
<a name="l01355"></a>01355             x[0] = (b1 - a12*x[1])/a11;
<a name="l01356"></a>01356         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fabs(a21) &gt; <a class="code" href="namespaceMesquite.html#27308dfd82a6c76f4c3075ac5af1b464">EPSILON</a>) {
<a name="l01357"></a>01357             factor = (a11/a21);
<a name="l01358"></a>01358             x[1] = (b1 - factor*b2)/(a12 - factor*a22);
<a name="l01359"></a>01359             x[0] = (b2 - a22*x[1])/a21;
<a name="l01360"></a>01360         }
<a name="l01361"></a>01361         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01362"></a>01362     } <span class="keywordflow">else</span> {
<a name="l01363"></a>01363         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01364"></a>01364     }
<a name="l01365"></a>01365 }
<a name="l01366"></a>01366 
<a name="l01367"></a>01367 
<a name="l01368"></a>01368 <span class="keywordtype">void</span> NonSmoothDescent::form_reduced_matrix(SymmetricMatrix&amp; P)
<a name="l01369"></a>01369 {
<a name="l01370"></a>01370     <span class="keyword">const</span> size_t P_size = mActive.active_ind.size() - 1;
<a name="l01371"></a>01371     P.resize( P_size );
<a name="l01372"></a>01372     <span class="keywordflow">for</span> (size_t i = 0; i &lt; P_size; i++) {
<a name="l01373"></a>01373         <a class="code" href="namespaceMesquite.html#3cffb20433bc7e60128cfa831d0af983">P</a>(i,i) = mG(0,0) - 2*mG(0,i+1) + mG(i+1,i+1);
<a name="l01374"></a>01374         <span class="keywordflow">for</span> (size_t j = i+1; j &lt; P_size; j++) {
<a name="l01375"></a>01375             <a class="code" href="namespaceMesquite.html#3cffb20433bc7e60128cfa831d0af983">P</a>(i,j) = mG(0,0) - mG(0,j+1) - mG(i+1,0) + mG(i+1,j+1);
<a name="l01376"></a>01376         }
<a name="l01377"></a>01377     }
<a name="l01378"></a>01378 }
<a name="l01379"></a>01379 
<a name="l01380"></a>01380 
<a name="l01381"></a>01381 <span class="keywordtype">void</span>  NonSmoothDescent::get_min_estimate( <span class="keywordtype">double</span> *final_est, MsqError &amp;<span class="comment">/*err*/</span>)
<a name="l01382"></a>01382 {
<a name="l01383"></a>01383     <span class="keywordtype">double</span> est_imp;
<a name="l01384"></a>01384 
<a name="l01385"></a>01385     *final_est = -HUGE_VAL;
<a name="l01386"></a>01386     <span class="keywordflow">for</span> (size_t i=0;i&lt;mActive.active_ind.size();i++) {
<a name="l01387"></a>01387         est_imp = -mAlpha*mGS[mActive.active_ind[i]];
<a name="l01388"></a>01388         if (est_imp&gt;*final_est) *final_est = est_imp;
<a name="l01389"></a>01389     }
<a name="l01390"></a>01390     <span class="keywordflow">if</span> (*final_est == 0) {
<a name="l01391"></a>01391         *final_est = -HUGE_VAL;
<a name="l01392"></a>01392         <span class="keywordflow">for</span> (size_t i=0;i&lt;qmHandles.size();i++) {
<a name="l01393"></a>01393             est_imp = -mAlpha*mGS[i];
<a name="l01394"></a>01394             <span class="keywordflow">if</span> ((est_imp&gt;*final_est) &amp;&amp; (fabs(est_imp) &gt; <a class="code" href="namespaceMesquite.html#27308dfd82a6c76f4c3075ac5af1b464">EPSILON</a>)) {
<a name="l01395"></a>01395                 *final_est = est_imp;
<a name="l01396"></a>01396             }
<a name="l01397"></a>01397         }
<a name="l01398"></a>01398     }
<a name="l01399"></a>01399 }
<a name="l01400"></a>01400 
<a name="l01401"></a>01401 
<a name="l01402"></a>01402 <span class="keywordtype">void</span> NonSmoothDescent::get_gradient_projections(<span class="keyword">const</span> Vector3D&amp; mSearch, MsqError &amp;<span class="comment">/*err*/</span>)
<a name="l01403"></a>01403 {
<a name="l01404"></a>01404     <span class="keywordflow">for</span> (size_t i=0;i&lt;qmHandles.size();i++) 
<a name="l01405"></a>01405         mGS[i] = mGradient[i] % mSearch;
<a name="l01406"></a>01406 
<a name="l01407"></a>01407     <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"steepest in get_gradient_projections %lu\n"</span>,(<span class="keywordtype">unsigned</span> long)mSteepest);
<a name="l01408"></a>01408 }
<a name="l01409"></a>01409 
<a name="l01410"></a>01410 
<a name="l01411"></a>01411 <span class="keywordtype">void</span> NonSmoothDescent::compute_alpha(MsqError &amp;<span class="comment">/*err*/</span>)
<a name="l01412"></a>01412 {
<a name="l01413"></a>01413     <span class="keywordtype">double</span>    steepest_function;
<a name="l01414"></a>01414     <span class="keywordtype">double</span>    steepest_grad;
<a name="l01415"></a>01415     <span class="keywordtype">double</span>    alpha_i;
<a name="l01416"></a>01416     <span class="keywordtype">double</span>    min_positive_value=HUGE_VAL;
<a name="l01417"></a>01417 
<a name="l01418"></a>01418 <span class="comment">//    FUNCTION_TIMER_START("Compute Alpha");</span>
<a name="l01419"></a>01419 
<a name="l01420"></a>01420     <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(2)(<span class="stringliteral">"In compute alpha\n"</span>);
<a name="l01421"></a>01421 
<a name="l01422"></a>01422     mAlpha = HUGE_VAL;
<a name="l01423"></a>01423 
<a name="l01424"></a>01424     steepest_function = mFunction[mSteepest];
<a name="l01425"></a>01425     steepest_grad = mGS[mSteepest];
<a name="l01426"></a>01426     <span class="keywordflow">for</span> (size_t i=0;i&lt;qmHandles.size();i++)
<a name="l01427"></a>01427     {
<a name="l01428"></a>01428         <span class="comment">/* if it's not active */</span>
<a name="l01429"></a>01429       <span class="keywordflow">if</span> (i!=mSteepest)
<a name="l01430"></a>01430       {
<a name="l01431"></a>01431           alpha_i = steepest_function - mFunction[i];
<a name="l01432"></a>01432            
<a name="l01433"></a>01433           <span class="keywordflow">if</span> (fabs(mGS[mSteepest] - mGS[i])&gt;1E-13) {
<a name="l01434"></a>01434              <span class="comment">/* compute line intersection */</span>
<a name="l01435"></a>01435              alpha_i = alpha_i/(steepest_grad - mGS[i]);
<a name="l01436"></a>01436           } <span class="keywordflow">else</span> {
<a name="l01437"></a>01437              <span class="comment">/* the lines don't intersect - it's not under consideration*/</span>
<a name="l01438"></a>01438              alpha_i = 0;
<a name="l01439"></a>01439           }
<a name="l01440"></a>01440           <span class="keywordflow">if</span> ((alpha_i &gt; minStepSize ) &amp;&amp; (fabs(alpha_i) &lt; fabs(mAlpha))) {
<a name="l01441"></a>01441             mAlpha = fabs(alpha_i); 
<a name="l01442"></a>01442             <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"Setting alpha %lu %g\n"</span>,(<span class="keywordtype">unsigned</span> long)i,alpha_i);
<a name="l01443"></a>01443           }
<a name="l01444"></a>01444           <span class="keywordflow">if</span> ((alpha_i &gt; 0) &amp;&amp; (alpha_i &lt; min_positive_value)) {
<a name="l01445"></a>01445             min_positive_value = alpha_i;
<a name="l01446"></a>01446           }
<a name="l01447"></a>01447        }
<a name="l01448"></a>01448     }
<a name="l01449"></a>01449 
<a name="l01450"></a>01450     <span class="keywordflow">if</span> ((mAlpha == HUGE_VAL) &amp;&amp; (min_positive_value != HUGE_VAL)) {
<a name="l01451"></a>01451       mAlpha = min_positive_value;
<a name="l01452"></a>01452     }
<a name="l01453"></a>01453 
<a name="l01454"></a>01454     <span class="comment">/* if it never gets set, set it to the default */</span>
<a name="l01455"></a>01455     <span class="keywordflow">if</span> (mAlpha == HUGE_VAL) {
<a name="l01456"></a>01456       mAlpha = maxAlpha;
<a name="l01457"></a>01457       <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"Setting alpha to the maximum step length\n"</span>);
<a name="l01458"></a>01458     }
<a name="l01459"></a>01459 
<a name="l01460"></a>01460     <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"  The initial step size: %f\n"</span>,mAlpha);
<a name="l01461"></a>01461 
<a name="l01462"></a>01462 <span class="comment">//    FUNCTION_TIMER_END();</span>
<a name="l01463"></a>01463 }
<a name="l01464"></a>01464 
<a name="l01465"></a>01465 
<a name="l01466"></a>01466 <span class="keywordtype">void</span> NonSmoothDescent::print_active_set( <span class="keyword">const</span> ActiveSet&amp; active_set, <span class="keyword">const</span> std::vector&lt;double&gt;&amp; func )
<a name="l01467"></a>01467 {
<a name="l01468"></a>01468     <span class="keywordflow">if</span> (active_set.active_ind.empty()) <a class="code" href="group__debug.html#gc1fb4ac3396b35008642ebd22e1b4d02">MSQ_DBGOUT</a>(3)&lt;&lt; <span class="stringliteral">"No active values\n"</span>;
<a name="l01469"></a>01469     <span class="comment">/* print the active set */</span>
<a name="l01470"></a>01470     <span class="keywordflow">for</span> (size_t i = 0; i &lt; active_set.active_ind.size(); i++) {
<a name="l01471"></a>01471      <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"Active value %lu:   %f \n"</span>, (<span class="keywordtype">unsigned</span> long)i+1,func[active_set.active_ind[i]]);
<a name="l01472"></a>01472     }
<a name="l01473"></a>01473 }
<a name="l01474"></a>01474 
<a name="l01475"></a>01475 
<a name="l01476"></a>01476 <span class="keywordtype">void</span> NonSmoothDescent::init_opt(PatchData&amp; pd, MsqError &amp;err)
<a name="l01477"></a>01477 {
<a name="l01478"></a>01478     qmHandles.clear();
<a name="l01479"></a>01479     currentQM-&gt;get_evaluations( pd, qmHandles, <span class="keyword">true</span>, err ); <a class="code" href="group__error.html#g4e8d0b49f7fa27ef04bb387e9436a40a">MSQ_ERRRTN</a>(err);
<a name="l01480"></a>01480 
<a name="l01481"></a>01481     <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(2)(<span class="stringliteral">"\nInitializing Optimization \n"</span>);
<a name="l01482"></a>01482 
<a name="l01483"></a>01483     <span class="comment">/* for the purposes of initialization will be set to zero after */</span>
<a name="l01484"></a>01484     optStatus = MSQ_NO_STATUS;
<a name="l01485"></a>01485     mSteepest = 0;
<a name="l01486"></a>01486     mAlpha = 0;
<a name="l01487"></a>01487     maxAlpha = 0;
<a name="l01488"></a>01488 
<a name="l01489"></a>01489     <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"  Initialized Constants \n"</span>);
<a name="l01490"></a>01490     pdgInd[0] = pdgInd[1] = pdgInd[2] = -1;
<a name="l01491"></a>01491     mPDG = Matrix3D(0.0);
<a name="l01492"></a>01492 
<a name="l01493"></a>01493     <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"  Initialized search and PDG \n"</span>);
<a name="l01494"></a>01494     mFunction.clear(); 
<a name="l01495"></a>01495     mFunction.resize( qmHandles.size(), 0.0 );
<a name="l01496"></a>01496     testFunction.clear(); 
<a name="l01497"></a>01497     testFunction.resize( qmHandles.size(), 0.0 );
<a name="l01498"></a>01498     originalFunction.clear(); 
<a name="l01499"></a>01499     originalFunction.resize( qmHandles.size(), 0.0 );
<a name="l01500"></a>01500     mGradient.clear();
<a name="l01501"></a>01501     mGradient.resize( qmHandles.size(), Vector3D(0.0) );
<a name="l01502"></a>01502     mGS.resize( qmHandles.size() );
<a name="l01503"></a>01503 
<a name="l01504"></a>01504     <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"  Initialized function/gradient \n"</span>);
<a name="l01505"></a>01505     mG.resize( qmHandles.size() );
<a name="l01506"></a>01506     mG.fill(-1);
<a name="l01507"></a>01507     <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"  Initialized G\n"</span>);
<a name="l01508"></a>01508  
<a name="l01509"></a>01509     prevActiveValues.clear();
<a name="l01510"></a>01510     prevActiveValues.reserve(32);
<a name="l01511"></a>01511     <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"  Initialized prevActiveValues\n"</span>);
<a name="l01512"></a>01512 }
<a name="l01513"></a>01513 
<a name="l01514"></a>01514 
<a name="l01515"></a>01515 <span class="keywordtype">void</span> NonSmoothDescent::init_max_step_length( PatchData&amp; pd, MsqError &amp;err )
<a name="l01516"></a>01516 {
<a name="l01517"></a>01517   size_t i, j;
<a name="l01518"></a>01518   <span class="keywordtype">double</span> max_diff = 0;
<a name="l01519"></a>01519   <span class="keywordtype">double</span> diff=0;
<a name="l01520"></a>01520 
<a name="l01521"></a>01521   <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(2)(<span class="stringliteral">"In init_max_step_length\n"</span>);
<a name="l01522"></a>01522 
<a name="l01523"></a>01523   <span class="comment">/* check that the input data is correct */</span>
<a name="l01524"></a>01524   <span class="keywordflow">if</span> (pd.num_elements()==0) {
<a name="l01525"></a>01525     <a class="code" href="group__error.html#g2a2fbc6c2b94ad06a287ec11ea469868">MSQ_SETERR</a>(err)(<span class="stringliteral">"Num incident vtx = 0\n"</span>,<a class="code" href="classMesquite_1_1MsqError.html#1d7c4cd95eccb8d09c39504ff0c2ec0b0f0d34ca5ee885772c3a45bd98725e0b">MsqError::INVALID_MESH</a>);
<a name="l01526"></a>01526     <span class="keywordflow">return</span>;
<a name="l01527"></a>01527   }
<a name="l01528"></a>01528 
<a name="l01529"></a>01529   <span class="comment">/* find the maximum distance between two incident vertex locations */</span>
<a name="l01530"></a>01530   <span class="keyword">const</span> MsqVertex* coords = pd.get_vertex_array(err);
<a name="l01531"></a>01531   <span class="keywordflow">for</span> (i=0;i&lt;pd.num_nodes()-1;i++) {
<a name="l01532"></a>01532     <span class="keywordflow">for</span> (j=i;j&lt;pd.num_nodes();j++) {
<a name="l01533"></a>01533       diff = (coords[i]-coords[j]).length_squared();
<a name="l01534"></a>01534       <span class="keywordflow">if</span> (max_diff &lt; diff) max_diff=diff;
<a name="l01535"></a>01535     } 
<a name="l01536"></a>01536   }
<a name="l01537"></a>01537   max_diff = sqrt(max_diff);
<a name="l01538"></a>01538   <span class="keywordflow">if</span> (max_diff==0) {
<a name="l01539"></a>01539      <a class="code" href="group__error.html#g2a2fbc6c2b94ad06a287ec11ea469868">MSQ_SETERR</a>(err)(<span class="stringliteral">"Maximum distance between incident vertices = 0\n"</span>,
<a name="l01540"></a>01540                      <a class="code" href="classMesquite_1_1MsqError.html#1d7c4cd95eccb8d09c39504ff0c2ec0b0f0d34ca5ee885772c3a45bd98725e0b">MsqError::INVALID_MESH</a>);
<a name="l01541"></a>01541     <span class="keywordflow">return</span>;
<a name="l01542"></a>01542   }
<a name="l01543"></a>01543   maxAlpha = max_diff/100;
<a name="l01544"></a>01544 
<a name="l01545"></a>01545   <a class="code" href="group__debug.html#g0aa9fb4562a411fee9a7916941360a2b">MSQ_PRINT</a>(3)(<span class="stringliteral">"  Maximum step is %g\n"</span>,maxAlpha);
<a name="l01546"></a>01546 }
<a name="l01547"></a>01547 
<a name="l01548"></a>01548 } <span class="comment">// namespace Mesquite</span>
<a name="l01549"></a>01549 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on 14 Aug 2013 for MESQUITE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
