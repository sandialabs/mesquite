<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>MESQUITE: ParallelHelper.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>ParallelHelper.cpp</h1><a href="ParallelHelper_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00002"></a>00002 <span class="preprocessor">#include "<a class="code" href="ParallelHelper_8hpp.html">ParallelHelper.hpp</a>"</span>
<a name="l00003"></a>00003 
<a name="l00004"></a>00004 <span class="preprocessor">#include &lt;mpi.h&gt;</span>
<a name="l00005"></a>00005 
<a name="l00006"></a>00006 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include &lt;assert.h&gt;</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &lt;time.h&gt;</span>
<a name="l00012"></a>00012 
<a name="l00013"></a>00013 <span class="preprocessor">#include "<a class="code" href="MsqVertex_8hpp.html">MsqVertex.hpp</a>"</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include "<a class="code" href="MsqError_8hpp.html">MsqError.hpp</a>"</span>
<a name="l00015"></a>00015 
<a name="l00016"></a><a class="code" href="ParallelHelper_8cpp.html#0b474ffa817926a5bbff5b51046fd45c">00016</a> <span class="preprocessor">#define VERTEX_HEADER 1</span>
<a name="l00017"></a><a class="code" href="ParallelHelper_8cpp.html#c5eb83026ccd0c22f641e74d3e19ff4a">00017</a> <span class="preprocessor"></span><span class="preprocessor">#define VERTEX_BLOCK 1000 </span>
<a name="l00018"></a><a class="code" href="ParallelHelper_8cpp.html#3f59b9223fe7e91f2c2a77fa3339a183">00018</a> <span class="preprocessor"></span><span class="preprocessor">#define GHOST_NODE_INFO 2000 </span>
<a name="l00019"></a><a class="code" href="ParallelHelper_8cpp.html#2bb049adaf5b230611c709c33b11ac3d">00019</a> <span class="preprocessor"></span><span class="preprocessor">#define GHOST_NODE_VERTICES_WANTED 2001</span>
<a name="l00020"></a><a class="code" href="ParallelHelper_8cpp.html#b6f55b7d22af555cc8749885e91c1cfe">00020</a> <span class="preprocessor"></span><span class="preprocessor">#define GHOST_NODE_VERTEX_GIDS 2002</span>
<a name="l00021"></a><a class="code" href="ParallelHelper_8cpp.html#869853f0b4e76aa416998a5ea1a472d8">00021</a> <span class="preprocessor"></span><span class="preprocessor">#define GHOST_NODE_VERTEX_UPDATES 2003</span>
<a name="l00022"></a>00022 <span class="preprocessor"></span>
<a name="l00023"></a><a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">00023</a> <span class="preprocessor">#define ARRPTR(x) arrptr(x,true)</span>
<a name="l00024"></a>00024 <span class="preprocessor"></span>
<a name="l00025"></a>00025 <span class="keyword">namespace </span><a class="code" href="mesquite__version_8h.html#7afaa56f6d67fe375b7d2b89b82a8313">MESQUITE_NS</a> {
<a name="l00026"></a>00026 
<a name="l00027"></a><a class="code" href="namespaceMesquite.html#201c376822ad94451d3396fec89a1e07">00027</a> <span class="keywordtype">void</span> <a class="code" href="namespaceMesquite.html#201c376822ad94451d3396fec89a1e07">parallel_barrier</a>()
<a name="l00028"></a>00028 {
<a name="l00029"></a>00029   <span class="keywordtype">int</span> is_init=0;
<a name="l00030"></a>00030   <span class="keywordtype">int</span> err = MPI_Initialized(&amp;is_init);
<a name="l00031"></a>00031   <span class="keywordflow">if</span> (MPI_SUCCESS != err) <span class="keywordflow">return</span>;
<a name="l00032"></a>00032   <span class="keywordflow">if</span> (is_init) MPI_Barrier(MPI_COMM_WORLD);
<a name="l00033"></a>00033 }
<a name="l00034"></a>00034 
<a name="l00035"></a><a class="code" href="namespaceMesquite.html#f5b47331c4c7a8a5bc47edce36e3b9b1">00035</a> <span class="keywordtype">int</span> <a class="code" href="namespaceMesquite.html#f5b47331c4c7a8a5bc47edce36e3b9b1">get_parallel_rank</a>()
<a name="l00036"></a>00036 {
<a name="l00037"></a>00037   <span class="keywordtype">int</span> rank=0;
<a name="l00038"></a>00038   <span class="keywordtype">int</span> is_init=0;
<a name="l00039"></a>00039   <span class="keywordtype">int</span> err = MPI_Initialized(&amp;is_init);
<a name="l00040"></a>00040   <span class="keywordflow">if</span> (MPI_SUCCESS != err) <span class="keywordflow">return</span> 0;
<a name="l00041"></a>00041   <span class="keywordflow">if</span> (is_init) MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);
<a name="l00042"></a>00042   <span class="keywordflow">return</span> rank;
<a name="l00043"></a>00043 }
<a name="l00044"></a>00044 
<a name="l00045"></a><a class="code" href="namespaceMesquite.html#46d94ea39bdbf60e28f9f6bf5bc0873b">00045</a> <span class="keywordtype">int</span> <a class="code" href="namespaceMesquite.html#46d94ea39bdbf60e28f9f6bf5bc0873b">get_parallel_size</a>()
<a name="l00046"></a>00046 {
<a name="l00047"></a>00047   <span class="keywordtype">int</span> nprocs=0;
<a name="l00048"></a>00048   <span class="keywordtype">int</span> is_init=0;
<a name="l00049"></a>00049   <span class="keywordtype">int</span> err = MPI_Initialized(&amp;is_init);
<a name="l00050"></a>00050   <span class="keywordflow">if</span> (MPI_SUCCESS != err) <span class="keywordflow">return</span> 0;
<a name="l00051"></a>00051   <span class="keywordflow">if</span> (is_init) MPI_Comm_size(MPI_COMM_WORLD, &amp;nprocs);
<a name="l00052"></a>00052   <span class="keywordflow">return</span> nprocs;
<a name="l00053"></a>00053 }
<a name="l00054"></a>00054 
<a name="l00055"></a><a class="code" href="namespaceMesquite.html#ff017681414d143f2afa898aae884ec4">00055</a> <span class="keywordtype">double</span> <a class="code" href="namespaceMesquite.html#ff017681414d143f2afa898aae884ec4">reduce_parallel_max</a>(<span class="keywordtype">double</span> value)
<a name="l00056"></a>00056 {
<a name="l00057"></a>00057   <span class="keywordtype">int</span> is_init=0;
<a name="l00058"></a>00058   <span class="keywordtype">int</span> err = MPI_Initialized(&amp;is_init);
<a name="l00059"></a>00059   <span class="keywordflow">if</span> (MPI_SUCCESS != err) <span class="keywordflow">return</span> value;
<a name="l00060"></a>00060   <span class="keywordflow">if</span> (!is_init) <span class="keywordflow">return</span> value;
<a name="l00061"></a>00061 
<a name="l00062"></a>00062   <span class="keywordtype">double</span> d_max[1];
<a name="l00063"></a>00063   <span class="keywordtype">double</span> d_max_recv[1];
<a name="l00064"></a>00064   d_max[0] = value;
<a name="l00065"></a>00065   <span class="keywordtype">int</span> rval = MPI_Allreduce(d_max, d_max_recv, 1, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);
<a name="l00066"></a>00066   <span class="keywordflow">if</span> (MPI_SUCCESS != rval) <span class="keywordflow">return</span> value;
<a name="l00067"></a>00067 
<a name="l00068"></a>00068   <span class="keywordflow">return</span> d_max_recv[0];
<a name="l00069"></a>00069 }
<a name="l00070"></a>00070 
<a name="l00071"></a>00071 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* mpi_err_string( <span class="keywordtype">int</span> error_code )
<a name="l00072"></a>00072 {
<a name="l00073"></a>00073   <span class="keyword">static</span> <span class="keywordtype">char</span> buffer[128];
<a name="l00074"></a>00074   <span class="keywordtype">int</span> len = <span class="keyword">sizeof</span>(buffer);
<a name="l00075"></a>00075   <span class="keywordtype">int</span> e = MPI_Error_string( error_code, buffer, &amp;len );
<a name="l00076"></a>00076   <span class="keywordflow">if</span> (MPI_SUCCESS != e)
<a name="l00077"></a>00077     len = 0;
<a name="l00078"></a>00078   
<a name="l00079"></a>00079   <span class="keywordflow">if</span> (len &gt;= (<span class="keywordtype">int</span>)<span class="keyword">sizeof</span>(buffer))
<a name="l00080"></a>00080     len = <span class="keyword">sizeof</span>(buffer) - 1;
<a name="l00081"></a>00081   buffer[len] = <span class="charliteral">'\0'</span>;
<a name="l00082"></a>00082   <span class="keywordflow">return</span> buffer;    
<a name="l00083"></a>00083 }
<a name="l00084"></a>00084 
<a name="l00085"></a><a class="code" href="ParallelHelper_8cpp.html#78b12d3996624c2282598c84cabf1874">00085</a> <span class="preprocessor">#define CHECK_MPI( RVAL, ERR ) do { if (MPI_SUCCESS != (RVAL)) { \</span>
<a name="l00086"></a>00086 <span class="preprocessor">  MSQ_SETERR(err)(MsqError::UNKNOWN_ERROR, "MPI Error %d: %s", \</span>
<a name="l00087"></a>00087 <span class="preprocessor">   (int)(RVAL), mpi_err_string((RVAL)) ); \</span>
<a name="l00088"></a>00088 <span class="preprocessor">  return; \</span>
<a name="l00089"></a>00089 <span class="preprocessor">} } while(false)</span>
<a name="l00090"></a>00090 <span class="preprocessor"></span>
<a name="l00091"></a><a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">00091</a> <span class="preprocessor">#define CHECK_MPI_RZERO( RVAL, ERR ) do { if (MPI_SUCCESS != (RVAL)) { \</span>
<a name="l00092"></a>00092 <span class="preprocessor">  MSQ_SETERR(err)(MsqError::UNKNOWN_ERROR, "MPI Error %d: %s", \</span>
<a name="l00093"></a>00093 <span class="preprocessor">   (int)(RVAL), mpi_err_string((RVAL)) ); \</span>
<a name="l00094"></a>00094 <span class="preprocessor">  return 0; \</span>
<a name="l00095"></a>00095 <span class="preprocessor">} } while(false)</span>
<a name="l00096"></a>00096 <span class="preprocessor"></span>
<a name="l00097"></a>00097     <span class="keyword">static</span> <span class="keywordtype">bool</span> vertex_map_insert(<a class="code" href="namespaceMesquite.html#aff7adf7a48e76eb81e3c029e7964a4b">VertexIdMap</a>&amp; map, size_t glob_id, <span class="keywordtype">int</span> proc_id, <span class="keywordtype">int</span> value)
<a name="l00098"></a>00098     {
<a name="l00099"></a>00099         <a class="code" href="namespaceMesquite.html#04bb3685dbf28e98a6c09eeb9f1a990c">VertexIdMapKey</a> vid;
<a name="l00100"></a>00100         vid.<a class="code" href="structMesquite_1_1VertexIdMapKey.html#2405cb28c24f7be95d2df4b75cb3afcf">glob_id</a> = glob_id;
<a name="l00101"></a>00101         vid.proc_id = proc_id;
<a name="l00102"></a>00102         <span class="keywordflow">return</span> map.insert(VertexIdMap::value_type(vid, value)).second;
<a name="l00103"></a>00103     }
<a name="l00104"></a>00104     
<a name="l00105"></a>00105     <span class="keyword">static</span> <span class="keywordtype">int</span> vertex_map_find(<span class="keyword">const</span> <a class="code" href="namespaceMesquite.html#aff7adf7a48e76eb81e3c029e7964a4b">VertexIdMap</a>&amp; map, size_t glob_id, <span class="keywordtype">int</span> proc_id)
<a name="l00106"></a>00106     {
<a name="l00107"></a>00107         <a class="code" href="namespaceMesquite.html#04bb3685dbf28e98a6c09eeb9f1a990c">VertexIdMapKey</a> vid;
<a name="l00108"></a>00108         vid.<a class="code" href="structMesquite_1_1VertexIdMapKey.html#2405cb28c24f7be95d2df4b75cb3afcf">glob_id</a> = glob_id;
<a name="l00109"></a>00109         vid.proc_id = proc_id;
<a name="l00110"></a>00110         VertexIdMap::const_iterator map_element = map.find(vid);
<a name="l00111"></a>00111         <span class="keywordflow">if</span> (map_element == map.end())
<a name="l00112"></a>00112         {
<a name="l00113"></a>00113             <span class="keywordflow">return</span> 0;
<a name="l00114"></a>00114         }
<a name="l00115"></a>00115         <span class="keywordflow">else</span>
<a name="l00116"></a>00116         {
<a name="l00117"></a>00117             <span class="keywordflow">return</span> map_element-&gt;second;
<a name="l00118"></a>00118         }
<a name="l00119"></a>00119     }
<a name="l00120"></a>00120 
<a name="l00121"></a>00121 <span class="keyword">static</span> <span class="keywordtype">void</span> my_quicksort(<span class="keywordtype">int</span>* a, size_t* b, <a class="code" href="classMesquite_1_1Mesh.html#9d765053bc19100f1de05d87d4222777">Mesquite::Mesh::VertexHandle</a>* c, <span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j)
<a name="l00122"></a>00122 {
<a name="l00123"></a>00123   <span class="keywordtype">int</span> in_i = i;
<a name="l00124"></a>00124   <span class="keywordtype">int</span> in_j = j;
<a name="l00125"></a>00125   <span class="keywordtype">int</span> wa;
<a name="l00126"></a>00126   size_t wb;
<a name="l00127"></a>00127   <a class="code" href="classMesquite_1_1Mesh.html#9d765053bc19100f1de05d87d4222777">Mesquite::Mesh::VertexHandle</a> w1;
<a name="l00128"></a>00128   <span class="keywordtype">int</span> key = a[(i+j)/2];
<a name="l00129"></a>00129   <span class="keywordflow">do</span>
<a name="l00130"></a>00130     {
<a name="l00131"></a>00131       <span class="keywordflow">while</span> ( a[i] &lt; key ) i++;
<a name="l00132"></a>00132       <span class="keywordflow">while</span> ( a[j] &gt; key ) j--;
<a name="l00133"></a>00133       <span class="keywordflow">if</span> (i&lt;j)
<a name="l00134"></a>00134         {
<a name="l00135"></a>00135           wa = a[i];
<a name="l00136"></a>00136           a[i] = a[j];
<a name="l00137"></a>00137           a[j] = wa;
<a name="l00138"></a>00138           wb = b[i];
<a name="l00139"></a>00139           b[i] = b[j];
<a name="l00140"></a>00140           b[j] = wb;
<a name="l00141"></a>00141           w1 = c[i];
<a name="l00142"></a>00142           c[i] = c[j];
<a name="l00143"></a>00143           c[j] = w1;      
<a name="l00144"></a>00144         }
<a name="l00145"></a>00145     } <span class="keywordflow">while</span> (++i&lt;=--j);
<a name="l00146"></a>00146   <span class="keywordflow">if</span> (i == j+3)
<a name="l00147"></a>00147     {
<a name="l00148"></a>00148       i--;
<a name="l00149"></a>00149       j++;
<a name="l00150"></a>00150     }
<a name="l00151"></a>00151   <span class="keywordflow">if</span> (j&gt;in_i) my_quicksort(a, b, c, in_i, j);
<a name="l00152"></a>00152   <span class="keywordflow">if</span> (i&lt;in_j) my_quicksort(a, b, c, i, in_j);
<a name="l00153"></a>00153 }
<a name="l00154"></a>00154 
<a name="l00155"></a>00155 <span class="keyword">static</span> <span class="keywordtype">int</span> hash6432shift(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> key)
<a name="l00156"></a>00156 {
<a name="l00157"></a>00157   key = (~key) + (key &lt;&lt; 18); <span class="comment">// key = (key &lt;&lt; 18) - key - 1;</span>
<a name="l00158"></a>00158   key = key ^ (key &gt;&gt; 31);
<a name="l00159"></a>00159   key = key * 21; <span class="comment">// key = (key + (key &lt;&lt; 2)) + (key &lt;&lt; 4);</span>
<a name="l00160"></a>00160   key = key ^ (key &gt;&gt; 11);
<a name="l00161"></a>00161   key = key + (key &lt;&lt; 6);
<a name="l00162"></a>00162   key = key ^ (key &gt;&gt; 22);
<a name="l00163"></a>00163   <span class="keywordflow">return</span> (<span class="keywordtype">int</span>) key;
<a name="l00164"></a>00164 }
<a name="l00165"></a>00165 
<a name="l00166"></a>00166 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> hash64shift(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> key)
<a name="l00167"></a>00167 {
<a name="l00168"></a>00168   key = (~key) + (key &lt;&lt; 21); <span class="comment">// key = (key &lt;&lt; 21) - key - 1;</span>
<a name="l00169"></a>00169   key = key ^ (key &gt;&gt; 24);
<a name="l00170"></a>00170   key = (key + (key &lt;&lt; 3)) + (key &lt;&lt; 8); <span class="comment">// key * 265</span>
<a name="l00171"></a>00171   key = key ^ (key &gt;&gt; 14);
<a name="l00172"></a>00172   key = (key + (key &lt;&lt; 2)) + (key &lt;&lt; 4); <span class="comment">// key * 21</span>
<a name="l00173"></a>00173   key = key ^ (key &gt;&gt; 28);
<a name="l00174"></a>00174   key = key + (key &lt;&lt; 31);
<a name="l00175"></a>00175   <span class="keywordflow">return</span> key;
<a name="l00176"></a>00176 }
<a name="l00177"></a>00177 
<a name="l00178"></a>00178 <span class="keyword">static</span> <span class="keywordtype">double</span> generate_random_number(<span class="keywordtype">int</span> generate_random_numbers, <span class="keywordtype">int</span> proc_id, size_t glob_id)
<a name="l00179"></a>00179 {
<a name="l00180"></a>00180   <span class="keywordtype">int</span> gid;
<a name="l00181"></a>00181 
<a name="l00182"></a>00182   <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(size_t) == <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)) {
<a name="l00183"></a>00183     gid = hash6432shift((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)glob_id);
<a name="l00184"></a>00184   }
<a name="l00185"></a>00185   <span class="keywordflow">else</span> {
<a name="l00186"></a>00186     gid = (int)glob_id;
<a name="l00187"></a>00187   }
<a name="l00188"></a>00188 
<a name="l00189"></a>00189   <span class="keywordflow">if</span> (generate_random_numbers == 1)
<a name="l00190"></a>00190   {
<a name="l00191"></a>00191     <span class="comment">// count number of on bits</span>
<a name="l00192"></a>00192     <span class="keywordtype">int</span> on = 0;
<a name="l00193"></a>00193     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mist = (<span class="keywordtype">unsigned</span> int)gid;
<a name="l00194"></a>00194     <span class="keywordflow">while</span> (mist)
<a name="l00195"></a>00195     {
<a name="l00196"></a>00196       <span class="keywordflow">if</span> (mist &amp; 1) on++;
<a name="l00197"></a>00197       mist = mist &gt;&gt; 1;
<a name="l00198"></a>00198     }
<a name="l00199"></a>00199     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> xsubi[3];
<a name="l00200"></a>00200     <span class="keywordflow">if</span> (on &amp; 1) mist = (<span class="keywordtype">unsigned</span> int)gid;
<a name="l00201"></a>00201     <span class="keywordflow">else</span> mist = (<span class="keywordtype">unsigned</span> int)(-gid);
<a name="l00202"></a>00202     <span class="keywordflow">if</span> (on &amp; 2) { 
<a name="l00203"></a>00203       xsubi[0] = (<span class="keywordtype">unsigned</span> short)(65535 &amp; mist); 
<a name="l00204"></a>00204       xsubi[1] = (<span class="keywordtype">unsigned</span> short)(65535 &amp; (mist &gt;&gt; 16)); 
<a name="l00205"></a>00205     } 
<a name="l00206"></a>00206     <span class="keywordflow">else</span> { 
<a name="l00207"></a>00207       xsubi[1] = (<span class="keywordtype">unsigned</span> short)(65535 &amp; mist); 
<a name="l00208"></a>00208       xsubi[0] = (<span class="keywordtype">unsigned</span> short)(65535 &amp; (mist &gt;&gt; 16)); 
<a name="l00209"></a>00209     } 
<a name="l00210"></a>00210     xsubi[2] = proc_id;
<a name="l00211"></a>00211     
<a name="l00212"></a>00212 <span class="preprocessor">#if (defined WIN32 || defined WIN64)</span>
<a name="l00213"></a>00213 <span class="preprocessor"></span>    time_t seed = (gid + xsubi[1]) / ((time(NULL) % 10)+1);
<a name="l00214"></a>00214     srand((<span class="keywordtype">int</span>)seed);
<a name="l00215"></a>00215     <span class="keywordflow">return</span> rand() / (RAND_MAX+1.0);
<a name="l00216"></a>00216 <span class="preprocessor">#else</span>
<a name="l00217"></a>00217 <span class="preprocessor"></span>    <span class="keywordflow">return</span> erand48(xsubi);
<a name="l00218"></a>00218 <span class="preprocessor">#endif</span>
<a name="l00219"></a>00219 <span class="preprocessor"></span>  }
<a name="l00220"></a>00220   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (generate_random_numbers == 2)
<a name="l00221"></a>00221   {
<a name="l00222"></a>00222     <span class="comment">// count number of on bits</span>
<a name="l00223"></a>00223     <span class="keywordtype">int</span> on = 0;
<a name="l00224"></a>00224     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mist = (<span class="keywordtype">unsigned</span> int)gid;
<a name="l00225"></a>00225     <span class="keywordflow">while</span> (mist)
<a name="l00226"></a>00226     {
<a name="l00227"></a>00227       <span class="keywordflow">if</span> (mist &amp; 1) on++;
<a name="l00228"></a>00228       mist = mist &gt;&gt; 1;
<a name="l00229"></a>00229     }
<a name="l00230"></a>00230     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> xsubi[3];
<a name="l00231"></a>00231     <span class="keywordflow">if</span> (on &amp; 1) mist = (<span class="keywordtype">unsigned</span> int)gid; 
<a name="l00232"></a>00232     <span class="keywordflow">else</span> mist = (<span class="keywordtype">unsigned</span> int)(-gid);
<a name="l00233"></a>00233     <span class="keywordflow">if</span> (on &amp; 2) {
<a name="l00234"></a>00234       xsubi[0] = (<span class="keywordtype">unsigned</span> short)(65535 &amp; mist); 
<a name="l00235"></a>00235       xsubi[1] = (<span class="keywordtype">unsigned</span> short)(65535 &amp; (mist &gt;&gt; 16));
<a name="l00236"></a>00236     }
<a name="l00237"></a>00237     <span class="keywordflow">else</span> {
<a name="l00238"></a>00238       xsubi[1] = (<span class="keywordtype">unsigned</span> short)(65535 &amp; mist); 
<a name="l00239"></a>00239       xsubi[0] = (<span class="keywordtype">unsigned</span> short)(65535 &amp; (mist &gt;&gt; 16));
<a name="l00240"></a>00240     }
<a name="l00241"></a>00241     xsubi[2] = proc_id ^ xsubi[1];
<a name="l00242"></a>00242 
<a name="l00243"></a>00243 <span class="preprocessor">#if (defined WIN32 || defined WIN64)</span>
<a name="l00244"></a>00244 <span class="preprocessor"></span>    time_t seed = (gid + xsubi[1]) / ((time(NULL) % 10)+1);
<a name="l00245"></a>00245     srand((<span class="keywordtype">int</span>)seed);
<a name="l00246"></a>00246     <span class="keywordflow">return</span> rand() / (RAND_MAX+1.0);
<a name="l00247"></a>00247 <span class="preprocessor">#else</span>
<a name="l00248"></a>00248 <span class="preprocessor"></span>    <span class="keywordflow">return</span> erand48(xsubi);
<a name="l00249"></a>00249 <span class="preprocessor">#endif</span>
<a name="l00250"></a>00250 <span class="preprocessor"></span>  }
<a name="l00251"></a>00251   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (generate_random_numbers == 3)
<a name="l00252"></a>00252   {
<a name="l00253"></a>00253     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> key = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> long)gid;
<a name="l00254"></a>00254     key = key &lt;&lt; 32;
<a name="l00255"></a>00255     key = key | proc_id;
<a name="l00256"></a>00256     <span class="keywordflow">return</span> (<span class="keywordtype">double</span>)hash64shift(key);
<a name="l00257"></a>00257   }
<a name="l00258"></a>00258   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (generate_random_numbers == 4)
<a name="l00259"></a>00259   {
<a name="l00260"></a>00260     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> key = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> long)gid;
<a name="l00261"></a>00261     key = key &lt;&lt; 32;
<a name="l00262"></a>00262     key = key | proc_id;
<a name="l00263"></a>00263     key = hash64shift(key);
<a name="l00264"></a>00264     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> xsubi[3];
<a name="l00265"></a>00265     xsubi[0] = (<span class="keywordtype">unsigned</span> short)(key &gt;&gt; 48);
<a name="l00266"></a>00266     xsubi[1] = (<span class="keywordtype">unsigned</span> short)(key &gt;&gt; 32);
<a name="l00267"></a>00267     xsubi[2] = (<span class="keywordtype">unsigned</span> short)(key &gt;&gt; 16);
<a name="l00268"></a>00268 
<a name="l00269"></a>00269 <span class="preprocessor">#if (defined WIN32 || defined WIN64)</span>
<a name="l00270"></a>00270 <span class="preprocessor"></span>    time_t seed = (gid + xsubi[1]) / ((time(NULL) % 10)+1);
<a name="l00271"></a>00271     srand((<span class="keywordtype">int</span>)seed);
<a name="l00272"></a>00272     <span class="keywordflow">return</span> rand() / (RAND_MAX+1.0);
<a name="l00273"></a>00273 <span class="preprocessor">#else</span>
<a name="l00274"></a>00274 <span class="preprocessor"></span>    <span class="keywordflow">return</span> erand48(xsubi);
<a name="l00275"></a>00275 <span class="preprocessor">#endif</span>
<a name="l00276"></a>00276 <span class="preprocessor"></span>  }
<a name="l00277"></a>00277   <span class="keywordflow">else</span>
<a name="l00278"></a>00278   {
<a name="l00279"></a>00279     <span class="keywordflow">return</span> -1;
<a name="l00280"></a>00280   }
<a name="l00281"></a>00281 }
<a name="l00282"></a>00282 
<a name="l00283"></a><a class="code" href="classMesquite_1_1ParallelHelperImpl.html#e0b3ad9564e5f3b737050069b04f5825">00283</a> ParallelHelperImpl::ParallelHelperImpl()
<a name="l00284"></a>00284 {
<a name="l00285"></a>00285   mesh = 0;
<a name="l00286"></a>00286   <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#a19135583527ac600d591a90303df617">set_communicator</a>(MPI_COMM_WORLD);
<a name="l00287"></a>00287   communication_model = <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#129bd7bfb54772d608af770b5ab06208fa03e2f94dd01f27453b505e8d15f795">TrulyNonBlockingAvoidAllReduce</a>;
<a name="l00288"></a>00288 
<a name="l00289"></a>00289   MPI_Comm_rank((MPI_Comm)communicator, &amp;rank);
<a name="l00290"></a>00290   MPI_Comm_size((MPI_Comm)communicator, &amp;nprocs);
<a name="l00291"></a>00291 
<a name="l00292"></a>00292   <span class="comment">// variable defaults for VertexMover::loop_over_mesh()</span>
<a name="l00293"></a>00293   generate_random_numbers = 2;
<a name="l00294"></a>00294 
<a name="l00295"></a>00295   <span class="comment">// memory chunks referenced for VertexMover::loop_over_mesh()</span>
<a name="l00296"></a>00296   vertices.clear();
<a name="l00297"></a>00297   vtx_in_partition_boundary.clear();
<a name="l00298"></a>00298   part_vertices.clear();
<a name="l00299"></a>00299   unghost_vertices.clear();
<a name="l00300"></a>00300   part_proc_owner.clear();
<a name="l00301"></a>00301   part_gid.clear();
<a name="l00302"></a>00302   part_smoothed_flag.clear();
<a name="l00303"></a>00303   part_rand_number.clear();
<a name="l00304"></a>00304   exportVtxGIDs.clear();
<a name="l00305"></a>00305   exportVtxLIDs.clear();
<a name="l00306"></a>00306   exportProc.clear();
<a name="l00307"></a>00307   in_independent_set.clear();
<a name="l00308"></a>00308   vid_map.clear();
<a name="l00309"></a>00309   neighbourProcSend.clear();
<a name="l00310"></a>00310   neighbourProcRecv.clear();
<a name="l00311"></a>00311   neighbourProcSendRemain.clear();
<a name="l00312"></a>00312   neighbourProcRecvRemain.clear();
<a name="l00313"></a>00313   vtx_off_proc_list.clear();
<a name="l00314"></a>00314   neighbourProc.clear();
<a name="l00315"></a>00315 }
<a name="l00316"></a>00316 
<a name="l00317"></a><a class="code" href="classMesquite_1_1ParallelHelperImpl.html#8fa12cd1220182419bb955d1e5a22a79">00317</a> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#8fa12cd1220182419bb955d1e5a22a79">ParallelHelperImpl::~ParallelHelperImpl</a>()
<a name="l00318"></a>00318 {
<a name="l00319"></a>00319 }
<a name="l00320"></a>00320 
<a name="l00321"></a><a class="code" href="classMesquite_1_1ParallelHelperImpl.html#ba679b574a590dd760731815bfff618f">00321</a> <span class="keywordtype">void</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#ba679b574a590dd760731815bfff618f">ParallelHelperImpl::set_parallel_mesh</a>(<a class="code" href="classMesquite_1_1ParallelMesh.html">ParallelMesh</a>* mesh) {
<a name="l00322"></a>00322   this-&gt;mesh = mesh;
<a name="l00323"></a>00323 }
<a name="l00324"></a>00324 
<a name="l00325"></a><a class="code" href="classMesquite_1_1ParallelHelperImpl.html#a19135583527ac600d591a90303df617">00325</a> <span class="keywordtype">void</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#a19135583527ac600d591a90303df617">ParallelHelperImpl::set_communicator</a>(size_t comm) {
<a name="l00326"></a>00326   communicator = comm;
<a name="l00327"></a>00327   MPI_Comm_rank((MPI_Comm)communicator, &amp;rank);
<a name="l00328"></a>00328   MPI_Comm_size((MPI_Comm)communicator, &amp;nprocs);
<a name="l00329"></a>00329 }
<a name="l00330"></a>00330 
<a name="l00331"></a><a class="code" href="classMesquite_1_1ParallelHelperImpl.html#ff187719c992d27f6ab169c5805ba26c">00331</a> <span class="keywordtype">void</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#ff187719c992d27f6ab169c5805ba26c">ParallelHelperImpl::set_communication_model</a>(<span class="keywordtype">int</span> model, <a class="code" href="classMesquite_1_1MsqError.html">MsqError</a>&amp; ) {
<a name="l00332"></a>00332   communication_model = model;
<a name="l00333"></a>00333 }
<a name="l00334"></a>00334 
<a name="l00335"></a><a class="code" href="classMesquite_1_1ParallelHelperImpl.html#ef4edc3500a51432bbf29cdb302aa9c7">00335</a> <span class="keywordtype">void</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#ef4edc3500a51432bbf29cdb302aa9c7">ParallelHelperImpl::set_generate_random_numbers</a>(<span class="keywordtype">int</span> grn, <a class="code" href="classMesquite_1_1MsqError.html">MsqError</a>&amp; ) {
<a name="l00336"></a>00336   this-&gt;generate_random_numbers = grn;
<a name="l00337"></a>00337 }
<a name="l00338"></a>00338 
<a name="l00339"></a><a class="code" href="classMesquite_1_1ParallelHelperImpl.html#faf139a7ad9028a3c924875741313f88">00339</a> <span class="keywordtype">void</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#faf139a7ad9028a3c924875741313f88">ParallelHelperImpl::smoothing_init</a>(<a class="code" href="classMesquite_1_1MsqError.html">MsqError</a>&amp; err)
<a name="l00340"></a>00340 {
<a name="l00341"></a>00341 
<a name="l00342"></a>00342   <span class="keywordtype">int</span> i,j,k, rval;
<a name="l00343"></a>00343   size_t l;
<a name="l00344"></a>00344 
<a name="l00345"></a>00345   <span class="keywordflow">if</span> (!mesh) {
<a name="l00346"></a>00346     <a class="code" href="group__error.html#gae6b768761f28b93e4a49048380313a0">MSQ_SETERR</a>(err)(<a class="code" href="classMesquite_1_1MsqError.html#810d503b59129a9369511a41f4dbb1bd3fb68d072a710e7e20303e5fe5246a24">MsqError::INVALID_STATE</a>);
<a name="l00347"></a>00347     <span class="keywordflow">return</span>;
<a name="l00348"></a>00348   }
<a name="l00349"></a>00349   <span class="keywordflow">if</span> (nprocs == 1) <span class="keywordflow">return</span>;
<a name="l00350"></a>00350 
<a name="l00351"></a>00351   <span class="comment">/* get the vertices */</span>
<a name="l00352"></a>00352   mesh-&gt;<a class="code" href="classMesquite_1_1Mesh.html#492a50903b32775bd996a8972abed0d9">get_all_vertices</a>(vertices, err); <a class="code" href="group__error.html#gb3bb4847196a6336b1fe6e2fd18caaef">MSQ_ERRRTN</a>(err);
<a name="l00353"></a>00353   num_vertex = vertices.size();
<a name="l00354"></a>00354 
<a name="l00355"></a>00355   <span class="comment">/* allocate the data arrays we'll use for smoothing */</span>
<a name="l00356"></a>00356   std::vector&lt;size_t&gt; gid(num_vertex);
<a name="l00357"></a>00357   std::vector&lt;int&gt; proc_owner(num_vertex);
<a name="l00358"></a>00358   std::vector&lt;unsigned char&gt; app_fixed(num_vertex);
<a name="l00359"></a>00359 
<a name="l00360"></a>00360   <span class="comment">/* get the data from the mesquite mesh */</span>
<a name="l00361"></a>00361   mesh-&gt;<a class="code" href="classMesquite_1_1ParallelMesh.html#cce40fc332b2dfa298027720c2e2ce42">vertices_get_global_id</a>(<a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(vertices),<a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(gid),num_vertex,err); <a class="code" href="group__error.html#gb3bb4847196a6336b1fe6e2fd18caaef">MSQ_ERRRTN</a>(err);
<a name="l00362"></a>00362   mesh-&gt;<a class="code" href="classMesquite_1_1Mesh.html#d6a2fb69dc334fa46f9123dea16828fc">vertices_get_byte</a>(<a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(vertices),<a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(app_fixed),num_vertex,err); <a class="code" href="group__error.html#gb3bb4847196a6336b1fe6e2fd18caaef">MSQ_ERRRTN</a>(err);
<a name="l00363"></a>00363   mesh-&gt;<a class="code" href="classMesquite_1_1ParallelMesh.html#ab8227ceb6ea93ee139ac2748e6e98cd">vertices_get_processor_id</a>(<a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(vertices),<a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(proc_owner),num_vertex,err); <a class="code" href="group__error.html#gb3bb4847196a6336b1fe6e2fd18caaef">MSQ_ERRRTN</a>(err);
<a name="l00364"></a>00364   <span class="keywordflow">if</span> (0)
<a name="l00365"></a>00365     {
<a name="l00366"></a>00366       <span class="keywordtype">int</span> ncull=0;
<a name="l00367"></a>00367       <span class="keywordflow">for</span> (i = 0; i &lt; num_vertex; ++i)
<a name="l00368"></a>00368         {
<a name="l00369"></a>00369           <span class="keywordflow">if</span> (app_fixed[i] &amp; <a class="code" href="classMesquite_1_1MsqVertex.html#2e255a70db385be125bd6798085605d5f83ca01c3d59a22c3fb6d4d9a36b8cb3">MsqVertex::MSQ_CULLED</a>)
<a name="l00370"></a>00370             {
<a name="l00371"></a>00371               ++ncull;
<a name="l00372"></a>00372             }
<a name="l00373"></a>00373         }
<a name="l00374"></a>00374       std::cout &lt;&lt; <span class="stringliteral">"P["</span> &lt;&lt; rank &lt;&lt; <span class="stringliteral">"] smoothing_init ncull= "</span> &lt;&lt; ncull &lt;&lt; <span class="stringliteral">" num_vertex= "</span> &lt;&lt; num_vertex &lt;&lt; std::endl;
<a name="l00375"></a>00375     }
<a name="l00376"></a>00376 
<a name="l00377"></a>00377   <span class="comment">/* only interested in fixed flag from vertex byte? Clear others. */</span>
<a name="l00378"></a>00378   <span class="comment">// srkenno AT sandia.gov 1/19/12: bug fix: changed from |= which makes all vertices fixed</span>
<a name="l00379"></a>00379   <span class="keywordflow">for</span> (i = 0; i &lt; num_vertex; ++i)
<a name="l00380"></a>00380     app_fixed[i] &amp;= <a class="code" href="classMesquite_1_1MsqVertex.html#2e255a70db385be125bd6798085605d5df282e146f11277088c56741de570dbc">MsqVertex::MSQ_HARD_FIXED</a>;
<a name="l00381"></a>00381   
<a name="l00382"></a>00382   <span class="comment">/* create temporary Tag for the local IDs */</span>
<a name="l00383"></a>00383   std::vector&lt;int&gt; lid(num_vertex);
<a name="l00384"></a>00384   <span class="keywordflow">for</span> (i=0; i &lt; num_vertex; i++) lid[i] = i;
<a name="l00385"></a>00385   <span class="keyword">const</span> <span class="keywordtype">char</span> LOCAL_ID_NAME[] = <span class="stringliteral">"LOCAL_ID"</span>;
<a name="l00386"></a>00386   <a class="code" href="namespaceMesquite.html#77eff90af5a2bd389b7232e61b40ce23">TagHandle</a> lid_tag = mesh-&gt;<a class="code" href="classMesquite_1_1Mesh.html#8934a3be2e6eb9cc9164a5eef2bf8810">tag_create</a>( LOCAL_ID_NAME, <a class="code" href="classMesquite_1_1Mesh.html#35387662fc187ac5b2a268700c53e07119e7563d2db482fc1b7c92edad1613e5">Mesh::INT</a>, 1, NULL, err ); <a class="code" href="group__error.html#gb3bb4847196a6336b1fe6e2fd18caaef">MSQ_ERRRTN</a>(err);
<a name="l00387"></a>00387   mesh-&gt;<a class="code" href="classMesquite_1_1Mesh.html#eece13ec3b16974f31eb203b9f1c81cf">tag_set_vertex_data</a>( lid_tag, num_vertex, <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(vertices), <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(lid), err ); <a class="code" href="group__error.html#gb3bb4847196a6336b1fe6e2fd18caaef">MSQ_ERRRTN</a>(err);
<a name="l00388"></a>00388 
<a name="l00389"></a>00389   <span class="keywordflow">if</span> (0) printf(<span class="stringliteral">"[%d] set local tags on %d vertices\n"</span>,rank,num_vertex);
<a name="l00390"></a>00390 
<a name="l00391"></a>00391   <span class="comment">/* get the elements */</span>
<a name="l00392"></a>00392   std::vector&lt;Mesquite::Mesh::ElementHandle&gt; elements;
<a name="l00393"></a>00393   mesh-&gt;<a class="code" href="classMesquite_1_1Mesh.html#145187e34f413b250efc682e91bb232f">get_all_elements</a>(elements, err);  <a class="code" href="group__error.html#gb3bb4847196a6336b1fe6e2fd18caaef">MSQ_ERRRTN</a>(err);
<a name="l00394"></a>00394   <span class="keywordtype">int</span> num_elems = elements.size();
<a name="l00395"></a>00395 
<a name="l00396"></a>00396   <span class="comment">/****************************************************************</span>
<a name="l00397"></a>00397 <span class="comment">  PARTITION BOUNDARY VERTEX DETERMINATION</span>
<a name="l00398"></a>00398 <span class="comment">  ***********************************************************************/</span>
<a name="l00399"></a>00399 
<a name="l00400"></a>00400   <span class="comment">/* initialize the vertex partition boundary array */</span>
<a name="l00401"></a>00401   vtx_in_partition_boundary.clear();
<a name="l00402"></a>00402   vtx_in_partition_boundary.resize( num_vertex, 0 );
<a name="l00403"></a>00403   <span class="keywordtype">int</span> incident_vtx, vtx_off_proc, vtx_on_proc;
<a name="l00404"></a>00404 
<a name="l00405"></a>00405   <span class="comment">/* get the array that contains the adjacent vertices for each mesh element */</span>
<a name="l00406"></a>00406   std::vector&lt;Mesquite::Mesh::VertexHandle&gt; adj_vertices;
<a name="l00407"></a>00407   std::vector&lt;size_t&gt; vtx_offsets;
<a name="l00408"></a>00408   mesh-&gt;<a class="code" href="classMesquite_1_1Mesh.html#fd0dab3edfb6d7570a08f4cb5aa295ef">elements_get_attached_vertices</a>(<a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(elements),num_elems,adj_vertices,vtx_offsets,err);
<a name="l00409"></a>00409   std::vector&lt;int&gt; adj_vertices_lid(adj_vertices.size());
<a name="l00410"></a>00410   mesh-&gt;<a class="code" href="classMesquite_1_1Mesh.html#0fd96fd71be129b2eee1500f878cf125">tag_get_vertex_data</a>( lid_tag, adj_vertices.size(), <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(adj_vertices), <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(adj_vertices_lid), err );
<a name="l00411"></a>00411 
<a name="l00412"></a>00412   <span class="keywordflow">if</span> (0) printf(<span class="stringliteral">"[%d] gotten adjacent elements for %d elements\n"</span>,rank,num_elems);
<a name="l00413"></a>00413 
<a name="l00414"></a>00414   <span class="comment">/* determine which vertices are smoothed as part of the boundary (and which are unused ghost vertices) */</span>
<a name="l00415"></a>00415   num_vtx_partition_boundary_local = 0;
<a name="l00416"></a>00416   num_vtx_partition_boundary_remote = 0;
<a name="l00417"></a>00417   <span class="keywordflow">for</span> (i=0;i&lt;num_elems;i++) {
<a name="l00418"></a>00418     <span class="comment">/* count how many vertices of the current element are on/off a different processor */</span>
<a name="l00419"></a>00419     vtx_off_proc = 0;
<a name="l00420"></a>00420     vtx_on_proc = 0;
<a name="l00421"></a>00421     <span class="keywordflow">for</span> (j=vtx_offsets[i];j&lt;(int)(vtx_offsets[i+1]);j++) {
<a name="l00422"></a>00422         incident_vtx = adj_vertices_lid[j];
<a name="l00423"></a>00423         <span class="comment">/* obviously the vertex only counts if it is not app_fixed */</span>
<a name="l00424"></a>00424         <span class="keywordflow">if</span> (!app_fixed[incident_vtx]) {
<a name="l00425"></a>00425           <span class="keywordflow">if</span> (proc_owner[incident_vtx]!=rank) {
<a name="l00426"></a>00426             vtx_off_proc++;
<a name="l00427"></a>00427           }
<a name="l00428"></a>00428           <span class="keywordflow">else</span> {
<a name="l00429"></a>00429             vtx_on_proc++;
<a name="l00430"></a>00430           }
<a name="l00431"></a>00431         }
<a name="l00432"></a>00432     }
<a name="l00433"></a>00433 
<a name="l00434"></a>00434     <span class="comment">/* if vertices are on different processors mark all local vertices as boundary1 and all remote vertices as boundary2 */</span>
<a name="l00435"></a>00435     <span class="keywordflow">if</span> (vtx_off_proc &gt; 0 &amp;&amp; vtx_on_proc &gt; 0) {
<a name="l00436"></a>00436         <span class="comment">/* collect stats */</span>
<a name="l00437"></a>00437         <span class="comment">//      smooth_stats.num_part_bndy_elem++;</span>
<a name="l00438"></a>00438         <span class="comment">/* mark the vertices */</span>
<a name="l00439"></a>00439         <span class="keywordflow">for</span> (j=vtx_offsets[i];j&lt;(int)(vtx_offsets[i+1]);j++) {
<a name="l00440"></a>00440           incident_vtx = adj_vertices_lid[j];
<a name="l00441"></a>00441           <span class="comment">/* obviously the vertex does not need to be marked if it was already marked or if it is app_fixed*/</span>
<a name="l00442"></a>00442           <span class="keywordflow">if</span> (vtx_in_partition_boundary[incident_vtx] &lt;= 0 &amp;&amp; app_fixed[incident_vtx] == 0) {
<a name="l00443"></a>00443             <span class="comment">/* mark and count the vertex */</span>
<a name="l00444"></a>00444             <span class="keywordflow">if</span> (proc_owner[incident_vtx]!=rank) {
<a name="l00445"></a>00445               vtx_in_partition_boundary[incident_vtx] = 2;
<a name="l00446"></a>00446               num_vtx_partition_boundary_remote++;
<a name="l00447"></a>00447             }
<a name="l00448"></a>00448             <span class="keywordflow">else</span> {
<a name="l00449"></a>00449               vtx_in_partition_boundary[incident_vtx] = 1;
<a name="l00450"></a>00450               num_vtx_partition_boundary_local++;
<a name="l00451"></a>00451             }
<a name="l00452"></a>00452           }
<a name="l00453"></a>00453         }
<a name="l00454"></a>00454     }
<a name="l00455"></a>00455     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vtx_off_proc &gt; 0) {
<a name="l00456"></a>00456       <span class="comment">/* mark the vertices as boundary-1 (aka unused ghost) if the element has only off-processor vertices */</span>
<a name="l00457"></a>00457       <span class="keywordflow">for</span> (j=vtx_offsets[i];j&lt;(int)(vtx_offsets[i+1]);j++) {
<a name="l00458"></a>00458         incident_vtx = adj_vertices_lid[j];
<a name="l00459"></a>00459         <span class="comment">/* obviously the vertex is not marked if it was already marked or if it is app_fixed*/</span>
<a name="l00460"></a>00460         <span class="keywordflow">if</span> (vtx_in_partition_boundary[incident_vtx] == 0 &amp;&amp; app_fixed[incident_vtx] == 0) {
<a name="l00461"></a>00461           vtx_in_partition_boundary[incident_vtx] = -1;
<a name="l00462"></a>00462         }
<a name="l00463"></a>00463       }
<a name="l00464"></a>00464     }
<a name="l00465"></a>00465   }    
<a name="l00466"></a>00466 
<a name="l00467"></a>00467   <span class="keywordflow">if</span> (0)
<a name="l00468"></a>00468   {
<a name="l00469"></a>00469     printf(<span class="stringliteral">"[%d]i%d local %d remote %d "</span>,rank,iteration,num_vtx_partition_boundary_local,num_vtx_partition_boundary_remote);
<a name="l00470"></a>00470     printf(<span class="stringliteral">"[%d]i%d pb1 "</span>,rank,iteration);
<a name="l00471"></a>00471     <span class="keywordflow">for</span> (i=0;i&lt;num_vertex;i++) <span class="keywordflow">if</span> (vtx_in_partition_boundary[i] == 1) printf(<span class="stringliteral">"%d,%Zu "</span>,i,gid[i]);
<a name="l00472"></a>00472     printf(<span class="stringliteral">"\n"</span>);
<a name="l00473"></a>00473     printf(<span class="stringliteral">"[%d]i%d pb2 "</span>,rank,iteration);
<a name="l00474"></a>00474     <span class="keywordflow">for</span> (i=0;i&lt;num_vertex;i++) <span class="keywordflow">if</span> (vtx_in_partition_boundary[i] == 2) printf(<span class="stringliteral">"%d,%Zu "</span>,i,gid[i]);
<a name="l00475"></a>00475     printf(<span class="stringliteral">"\n"</span>);
<a name="l00476"></a>00476     fflush(NULL);
<a name="l00477"></a>00477   }
<a name="l00478"></a>00478 
<a name="l00479"></a>00479   num_vtx_partition_boundary = num_vtx_partition_boundary_local + num_vtx_partition_boundary_remote;
<a name="l00480"></a>00480 
<a name="l00481"></a>00481   <span class="comment">/********************************************************************</span>
<a name="l00482"></a>00482 <span class="comment"> COLLECT THE PARTITION BOUNDARY VERTICES AND THE UNUSED GHOST VERTICES</span>
<a name="l00483"></a>00483 <span class="comment">  ********************************************************************/</span>
<a name="l00484"></a>00484 
<a name="l00485"></a>00485   <span class="comment">/* create the vectors to store the partition boundary vertex data */</span>
<a name="l00486"></a>00486   part_vertices.resize(num_vtx_partition_boundary);
<a name="l00487"></a>00487   part_proc_owner.resize(num_vtx_partition_boundary);
<a name="l00488"></a>00488   part_gid.resize(num_vtx_partition_boundary);
<a name="l00489"></a>00489   part_smoothed_flag.resize(num_vtx_partition_boundary);
<a name="l00490"></a>00490   part_rand_number.resize(num_vtx_partition_boundary);
<a name="l00491"></a>00491 
<a name="l00492"></a>00492   <span class="comment">/* create the partition boundary map and its inverse */</span>
<a name="l00493"></a>00493   std::vector&lt;int&gt; vtx_partition_boundary_map_inverse(num_vertex);
<a name="l00494"></a>00494 
<a name="l00495"></a>00495   j=0;
<a name="l00496"></a>00496   <span class="comment">/* first we map the partition boundary vertices that we will smooth on this processor */</span>
<a name="l00497"></a>00497   <span class="keywordflow">for</span> (i=0;i&lt;num_vertex;i++) {
<a name="l00498"></a>00498     <span class="keywordflow">if</span> (vtx_in_partition_boundary[i]==1) {
<a name="l00499"></a>00499         part_vertices[j] = vertices[i];
<a name="l00500"></a>00500         part_proc_owner[j] = rank; assert(proc_owner[i] == rank);
<a name="l00501"></a>00501         part_gid[j] = gid[i];
<a name="l00502"></a>00502         vtx_partition_boundary_map_inverse[i] = j;
<a name="l00503"></a>00503         j++;
<a name="l00504"></a>00504     }
<a name="l00505"></a>00505   }
<a name="l00506"></a>00506 
<a name="l00507"></a>00507   vid_map.clear();
<a name="l00508"></a>00508 
<a name="l00509"></a>00509   <span class="comment">/* then we map the ghost vertices that will be smoothed on other processors */</span>
<a name="l00510"></a>00510   <span class="keywordflow">for</span> (i=0;i&lt;num_vertex;i++) {
<a name="l00511"></a>00511     <span class="keywordflow">if</span> (vtx_in_partition_boundary[i]==2) {
<a name="l00512"></a>00512         part_vertices[j] = vertices[i];
<a name="l00513"></a>00513         part_proc_owner[j] = proc_owner[i];  assert(proc_owner[i] != rank);
<a name="l00514"></a>00514         part_gid[j] = gid[i];
<a name="l00515"></a>00515         vtx_partition_boundary_map_inverse[i] = j;
<a name="l00516"></a>00516         <span class="comment">/* only insert those vertices in the map that are smoothed on other processors */</span>
<a name="l00517"></a>00517         vertex_map_insert(vid_map, part_gid[j], part_proc_owner[j], j);
<a name="l00518"></a>00518         <span class="comment">// printf("[%d] inserting vertex with gid %Zu and pid %d \n", rank, part_gid[j], part_proc_owner[j]);     </span>
<a name="l00519"></a>00519         j++;
<a name="l00520"></a>00520     }
<a name="l00521"></a>00521   }
<a name="l00522"></a>00522 
<a name="l00523"></a>00523   <span class="comment">/* create our own 'very pseudo random' numbers */</span>
<a name="l00524"></a>00524   <span class="keywordflow">for</span> (i=0;i&lt;num_vtx_partition_boundary;i++)
<a name="l00525"></a>00525     part_rand_number[i] = generate_random_number(generate_random_numbers, part_proc_owner[i], part_gid[i]);
<a name="l00526"></a>00526 
<a name="l00527"></a>00527   <span class="comment">/* count the number of unused ghost vertices */</span>
<a name="l00528"></a>00528   unghost_num_vtx = 0;
<a name="l00529"></a>00529   <span class="keywordflow">for</span> (i=0;i&lt;num_vertex;i++) {
<a name="l00530"></a>00530     <span class="keywordflow">if</span> (vtx_in_partition_boundary[i]==-1) {
<a name="l00531"></a>00531       unghost_num_vtx++;
<a name="l00532"></a>00532     }
<a name="l00533"></a>00533   }
<a name="l00534"></a>00534   <span class="comment">// printf("[%d] found %d unused ghost vertices (local %d remote %d)\n",rank, unghost_num_vtx, num_vtx_partition_boundary_local,num_vtx_partition_boundary_remote);</span>
<a name="l00535"></a>00535 
<a name="l00536"></a>00536   <span class="comment">/* create the vectors to store the unused ghost vertices */</span> 
<a name="l00537"></a>00537   unghost_vertices.resize(unghost_num_vtx);
<a name="l00538"></a>00538   std::vector&lt;int&gt; unghost_proc_owner(unghost_num_vtx);
<a name="l00539"></a>00539   std::vector&lt;size_t&gt; unghost_gid(unghost_num_vtx);
<a name="l00540"></a>00540 
<a name="l00541"></a>00541   <span class="comment">/* store the unused ghost vertices that are copies of vertices from other processors and will need to be received */</span>
<a name="l00542"></a>00542   j=0;
<a name="l00543"></a>00543   <span class="keywordflow">for</span> (i=0;i&lt;num_vertex;i++) {
<a name="l00544"></a>00544     <span class="keywordflow">if</span> (vtx_in_partition_boundary[i]==-1) {
<a name="l00545"></a>00545       unghost_vertices[j] = vertices[i];
<a name="l00546"></a>00546       unghost_proc_owner[j] = proc_owner[i];  assert(proc_owner[i] != rank);
<a name="l00547"></a>00547       unghost_gid[j] = gid[i];
<a name="l00548"></a>00548       <span class="comment">// printf(" %d", unghost_gid[j]);</span>
<a name="l00549"></a>00549       j++;
<a name="l00550"></a>00550     }
<a name="l00551"></a>00551   }
<a name="l00552"></a>00552 
<a name="l00553"></a>00553   <span class="comment">/* no longer needed */</span>
<a name="l00554"></a>00554   <span class="comment">//delete [] gid; gid = 0;</span>
<a name="l00555"></a>00555   <span class="comment">//delete [] proc_owner; proc_owner = 0;</span>
<a name="l00556"></a>00556 
<a name="l00557"></a>00557   unghost_num_procs = 0;
<a name="l00558"></a>00558   unghost_procs.clear();
<a name="l00559"></a>00559   unghost_procs_offset.clear();
<a name="l00560"></a>00560   unghost_procs_num_vtx.clear();
<a name="l00561"></a>00561   <span class="keywordflow">if</span> (unghost_num_vtx)
<a name="l00562"></a>00562   {
<a name="l00563"></a>00563     <span class="comment">/* sort the unused ghost vertices by processor */</span>
<a name="l00564"></a>00564     my_quicksort(<a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(unghost_proc_owner), <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(unghost_gid), &amp;(unghost_vertices[0]), 0, unghost_num_vtx-1);
<a name="l00565"></a>00565 
<a name="l00566"></a>00566     <span class="comment">/* count the number of processors we have unused ghost data from that we want to get updated */</span>
<a name="l00567"></a>00567     unghost_num_procs = 1;
<a name="l00568"></a>00568     <span class="keywordflow">for</span> (i = 1; i &lt; unghost_num_vtx; i++)
<a name="l00569"></a>00569     {
<a name="l00570"></a>00570       <span class="keywordflow">if</span> (unghost_proc_owner[i-1] != unghost_proc_owner[i]) unghost_num_procs++;
<a name="l00571"></a>00571     }
<a name="l00572"></a>00572 
<a name="l00573"></a>00573     <span class="comment">/* get the ids of those processors and the number of vertices we want from each */</span>
<a name="l00574"></a>00574     unghost_procs.resize(unghost_num_procs);
<a name="l00575"></a>00575     unghost_procs_offset.resize(unghost_num_procs+1);
<a name="l00576"></a>00576     unghost_procs_num_vtx.resize(unghost_num_procs);
<a name="l00577"></a>00577     unghost_procs[0] = unghost_proc_owner[0];
<a name="l00578"></a>00578     unghost_procs_offset[0] = 0;
<a name="l00579"></a>00579     <span class="keywordflow">for</span> (i = 1, j = 1; i &lt; unghost_num_vtx; i++)
<a name="l00580"></a>00580     {
<a name="l00581"></a>00581       <span class="keywordflow">if</span> (unghost_proc_owner[i-1] != unghost_proc_owner[i])
<a name="l00582"></a>00582       {
<a name="l00583"></a>00583         unghost_procs[j] = unghost_proc_owner[i];
<a name="l00584"></a>00584         unghost_procs_offset[j] = i;
<a name="l00585"></a>00585         unghost_procs_num_vtx[j-1] = unghost_procs_offset[j] - unghost_procs_offset[j-1];
<a name="l00586"></a>00586         assert(unghost_procs_num_vtx[j-1] &gt; 0);
<a name="l00587"></a>00587         j++;
<a name="l00588"></a>00588       }
<a name="l00589"></a>00589     }
<a name="l00590"></a>00590     unghost_procs_offset[j] = i;
<a name="l00591"></a>00591     unghost_procs_num_vtx[j-1] = unghost_procs_offset[j] - unghost_procs_offset[j-1];
<a name="l00592"></a>00592     assert(unghost_procs_num_vtx[j-1] &gt; 0);
<a name="l00593"></a>00593     assert(j == unghost_num_procs);
<a name="l00594"></a>00594 
<a name="l00595"></a>00595     <span class="comment">//delete [] unghost_proc_owner; unghost_proc_owner = 0;</span>
<a name="l00596"></a>00596 
<a name="l00597"></a>00597     <span class="comment">// printf("[%d] have ugns from %d processor(s) (%d,%d,%d)\n", rank, unghost_num_procs, unghost_procs[0], (unghost_num_procs&gt;1) ? unghost_procs[1] : -1, (unghost_num_procs&gt;2) ? unghost_procs[1] : -1);</span>
<a name="l00598"></a>00598   }
<a name="l00599"></a>00599 
<a name="l00600"></a>00600   <span class="comment">/* this will eventually store to how many processors each processor needs to send unused ghost data to */</span>
<a name="l00601"></a>00601   std::vector&lt;int&gt; num_sends_of_unghost;
<a name="l00602"></a>00602 
<a name="l00603"></a>00603   <span class="comment">/* gather the information about how many processors need ghost data */</span>
<a name="l00604"></a>00604   <span class="keywordflow">if</span> (rank == 0)
<a name="l00605"></a>00605   {
<a name="l00606"></a>00606     <span class="comment">/* this will eventually store to how many processors each processor needs to send unused ghost data to */</span>
<a name="l00607"></a>00607     num_sends_of_unghost.resize(nprocs);
<a name="l00608"></a>00608   }
<a name="l00609"></a>00609   <span class="comment">/* temporary used for the initial gather in which each proc tells the root from how many procs it wants unused ghost data updates */</span>
<a name="l00610"></a>00610   rval = MPI_Gather(&amp;unghost_num_procs, 1, MPI_INT, <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(num_sends_of_unghost), 1, MPI_INT, 0, (MPI_Comm)communicator);
<a name="l00611"></a>00611   <a class="code" href="ParallelHelper_8cpp.html#78b12d3996624c2282598c84cabf1874">CHECK_MPI</a>(rval, err);
<a name="l00612"></a>00612 
<a name="l00613"></a>00613   <span class="comment">/* now each processor tells the root node from which processors they want unused ghost nodes information */</span>
<a name="l00614"></a>00614   <span class="keywordflow">if</span> (rank == 0)
<a name="l00615"></a>00615   {
<a name="l00616"></a>00616     <span class="keywordtype">int</span> procs_num = 0;
<a name="l00617"></a>00617     <span class="keywordtype">int</span> procs_max = 0;
<a name="l00618"></a>00618     <span class="comment">/* first count how many processors will send unused ghost node info and find the maximum they will send */</span>
<a name="l00619"></a>00619     <span class="keywordflow">for</span> (i = 1; i &lt; nprocs; i++)
<a name="l00620"></a>00620     {
<a name="l00621"></a>00621       <span class="keywordflow">if</span> (num_sends_of_unghost[i])
<a name="l00622"></a>00622       {
<a name="l00623"></a>00623         procs_num++;
<a name="l00624"></a>00624         <span class="keywordflow">if</span> (num_sends_of_unghost[i] &gt; procs_max) procs_max = num_sends_of_unghost[i];
<a name="l00625"></a>00625       }
<a name="l00626"></a>00626     }
<a name="l00627"></a>00627     <span class="comment">/* clean the temporary used array */</span>
<a name="l00628"></a>00628     <span class="keywordflow">for</span> (i = 0; i &lt; nprocs; i++) num_sends_of_unghost[i] = 0;
<a name="l00629"></a>00629     <span class="comment">/* process rank 0's unused ghost nodes procs first */</span>
<a name="l00630"></a>00630     <span class="keywordflow">for</span> (j = 0; j &lt; unghost_num_procs; j++)
<a name="l00631"></a>00631     {
<a name="l00632"></a>00632       num_sends_of_unghost[unghost_procs[j]]++;
<a name="l00633"></a>00633     }
<a name="l00634"></a>00634     <span class="comment">/* now we process messages from all other processors that want unused ghost node information */</span>
<a name="l00635"></a>00635     <span class="keywordtype">int</span> *unghost_procs_array = <span class="keyword">new</span> <span class="keywordtype">int</span>[procs_max];
<a name="l00636"></a>00636     <span class="keywordflow">for</span> (i = 0; i &lt; procs_num; i++)
<a name="l00637"></a>00637     {
<a name="l00638"></a>00638       MPI_Status status;
<a name="l00639"></a>00639       rval = MPI_Recv(unghost_procs_array, procs_max, MPI_INT, MPI_ANY_SOURCE, <a class="code" href="ParallelHelper_8cpp.html#3f59b9223fe7e91f2c2a77fa3339a183">GHOST_NODE_INFO</a>, (MPI_Comm)communicator, &amp;status);
<a name="l00640"></a>00640       <a class="code" href="ParallelHelper_8cpp.html#78b12d3996624c2282598c84cabf1874">CHECK_MPI</a>(rval,err);
<a name="l00641"></a>00641       <span class="keywordtype">int</span> count;
<a name="l00642"></a>00642       MPI_Get_count(&amp;status, MPI_INT, &amp;count);
<a name="l00643"></a>00643       <span class="keywordflow">for</span> (j = 0; j &lt; count; j++)
<a name="l00644"></a>00644       {
<a name="l00645"></a>00645                num_sends_of_unghost[unghost_procs_array[j]]++;
<a name="l00646"></a>00646       }
<a name="l00647"></a>00647     }
<a name="l00648"></a>00648     <span class="keyword">delete</span> [] unghost_procs_array;
<a name="l00649"></a>00649   }
<a name="l00650"></a>00650   <span class="keywordflow">else</span>
<a name="l00651"></a>00651   {
<a name="l00652"></a>00652     <span class="keywordflow">if</span> (unghost_num_vtx)
<a name="l00653"></a>00653     {
<a name="l00654"></a>00654       rval = MPI_Send(<a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(unghost_procs), unghost_num_procs, MPI_INT, 0, <a class="code" href="ParallelHelper_8cpp.html#3f59b9223fe7e91f2c2a77fa3339a183">GHOST_NODE_INFO</a>, (MPI_Comm)communicator);
<a name="l00655"></a>00655       <a class="code" href="ParallelHelper_8cpp.html#78b12d3996624c2282598c84cabf1874">CHECK_MPI</a>(rval,err);
<a name="l00656"></a>00656     }
<a name="l00657"></a>00657   }
<a name="l00658"></a>00658 
<a name="l00659"></a>00659   <span class="comment">/* now the root node knows for each processor on how many other processors they have ghost nodes (which need updating) */</span> 
<a name="l00660"></a>00660   <span class="comment">/* the scatter distributes this information to each processor */</span>
<a name="l00661"></a>00661   rval = MPI_Scatter(<a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(num_sends_of_unghost), 1, MPI_INT, &amp;update_num_procs, 1, MPI_INT, 0, (MPI_Comm)communicator);
<a name="l00662"></a>00662   <a class="code" href="ParallelHelper_8cpp.html#78b12d3996624c2282598c84cabf1874">CHECK_MPI</a>(rval,err);
<a name="l00663"></a>00663 
<a name="l00664"></a>00664   <span class="comment">//if (rank == 0) delete [] num_sends_of_unghost;</span>
<a name="l00665"></a>00665 
<a name="l00666"></a>00666   <span class="comment">//printf("[%d] i have unused ghost nodes from %d procs and i need to send updates to %d procs\n", rank, unghost_num_procs, update_num_procs);</span>
<a name="l00667"></a>00667 
<a name="l00668"></a>00668   <span class="comment">/* now the processors can negotiate amongst themselves: */</span>
<a name="l00669"></a>00669 
<a name="l00670"></a>00670   <span class="comment">/* first tell each processor the number of unused ghost nodes we want from them */</span>
<a name="l00671"></a>00671   std::vector&lt;MPI_Request&gt; requests_unghost(unghost_num_procs);
<a name="l00672"></a>00672   <span class="keywordflow">for</span> (j = 0; j &lt; unghost_num_procs; j++)
<a name="l00673"></a>00673   {
<a name="l00674"></a>00674     rval = MPI_Isend(&amp;(unghost_procs_num_vtx[j]),
<a name="l00675"></a>00675               1,
<a name="l00676"></a>00676               MPI_INT,
<a name="l00677"></a>00677               unghost_procs[j],
<a name="l00678"></a>00678               <a class="code" href="ParallelHelper_8cpp.html#2bb049adaf5b230611c709c33b11ac3d">GHOST_NODE_VERTICES_WANTED</a>,
<a name="l00679"></a>00679               (MPI_Comm)communicator,
<a name="l00680"></a>00680               &amp;(requests_unghost[j]));
<a name="l00681"></a>00681     <a class="code" href="ParallelHelper_8cpp.html#78b12d3996624c2282598c84cabf1874">CHECK_MPI</a>(rval,err);
<a name="l00682"></a>00682   }
<a name="l00683"></a>00683 
<a name="l00684"></a>00684   <span class="comment">/* then listen to as many processors as there are that want updates from us */</span>
<a name="l00685"></a>00685   std::vector&lt;MPI_Request&gt; requests_updates(update_num_procs);
<a name="l00686"></a>00686   update_procs_num_vtx.resize(update_num_procs);
<a name="l00687"></a>00687   <span class="keywordflow">for</span> (j = 0; j &lt; update_num_procs; j++)
<a name="l00688"></a>00688   {
<a name="l00689"></a>00689     rval = MPI_Irecv(&amp;(update_procs_num_vtx[j]),
<a name="l00690"></a>00690              1,
<a name="l00691"></a>00691              MPI_INT,
<a name="l00692"></a>00692              MPI_ANY_SOURCE,
<a name="l00693"></a>00693              <a class="code" href="ParallelHelper_8cpp.html#2bb049adaf5b230611c709c33b11ac3d">GHOST_NODE_VERTICES_WANTED</a>,
<a name="l00694"></a>00694              (MPI_Comm)communicator,
<a name="l00695"></a>00695               &amp;(requests_updates[j]));
<a name="l00696"></a>00696     <a class="code" href="ParallelHelper_8cpp.html#78b12d3996624c2282598c84cabf1874">CHECK_MPI</a>(rval,err);
<a name="l00697"></a>00697   }
<a name="l00698"></a>00698 
<a name="l00699"></a>00699   <span class="comment">/* wait until we have heard from all processors how many ghost nodes updates they want from us */</span>
<a name="l00700"></a>00700   std::vector&lt;MPI_Status&gt; status_update(update_num_procs);
<a name="l00701"></a>00701   update_procs.resize(update_num_procs);
<a name="l00702"></a>00702   rval = MPI_Waitall(update_num_procs, <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(requests_updates), <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(status_update));
<a name="l00703"></a>00703   <a class="code" href="ParallelHelper_8cpp.html#78b12d3996624c2282598c84cabf1874">CHECK_MPI</a>(rval,err);
<a name="l00704"></a>00704   <span class="keywordflow">for</span> (j = 0; j &lt; update_num_procs; j++)
<a name="l00705"></a>00705   {
<a name="l00706"></a>00706     update_procs[j] = status_update[j].MPI_SOURCE;
<a name="l00707"></a>00707     <span class="comment">// printf("[%d] i have to send %d vertices to processor %d\n", rank, update_procs_num_vtx[j], update_procs[j]);</span>
<a name="l00708"></a>00708   }
<a name="l00709"></a>00709 
<a name="l00710"></a>00710   <span class="comment">/* count the total number of vertices that we need to update elsewhere */</span>
<a name="l00711"></a>00711   update_procs_offset.resize(update_num_procs+1);
<a name="l00712"></a>00712   update_num_vtx = 0;
<a name="l00713"></a>00713   update_procs_offset[0] = 0;
<a name="l00714"></a>00714   <span class="keywordflow">for</span> (j = 0; j &lt; update_num_procs; j++)
<a name="l00715"></a>00715   {
<a name="l00716"></a>00716     update_num_vtx += update_procs_num_vtx[j];
<a name="l00717"></a>00717     update_procs_offset[j+1] = update_num_vtx;
<a name="l00718"></a>00718   }
<a name="l00719"></a>00719   
<a name="l00720"></a>00720   <span class="comment">/* create enough space to receive all the vertex indices */</span>
<a name="l00721"></a>00721   update_gid.resize(update_num_vtx);
<a name="l00722"></a>00722 
<a name="l00723"></a>00723   <span class="comment">/* tell each processor which vertices we want from them */</span>
<a name="l00724"></a>00724   <span class="keywordflow">for</span> (j = 0; j &lt; unghost_num_procs; j++)
<a name="l00725"></a>00725   {
<a name="l00726"></a>00726     rval = MPI_Isend(&amp;(unghost_gid[unghost_procs_offset[j]]),
<a name="l00727"></a>00727               unghost_procs_num_vtx[j],
<a name="l00728"></a>00728               <span class="keyword">sizeof</span>(size_t) == 4 ? MPI_INT : MPI_DOUBLE,
<a name="l00729"></a>00729               unghost_procs[j],
<a name="l00730"></a>00730               <a class="code" href="ParallelHelper_8cpp.html#b6f55b7d22af555cc8749885e91c1cfe">GHOST_NODE_VERTEX_GIDS</a>,
<a name="l00731"></a>00731               (MPI_Comm)communicator,
<a name="l00732"></a>00732               &amp;(requests_unghost[j]));
<a name="l00733"></a>00733     <a class="code" href="ParallelHelper_8cpp.html#78b12d3996624c2282598c84cabf1874">CHECK_MPI</a>(rval,err);
<a name="l00734"></a>00734   }
<a name="l00735"></a>00735 
<a name="l00736"></a>00736   <span class="comment">/* receive from each processor the info which vertices they want from us */</span>
<a name="l00737"></a>00737   <span class="keywordflow">for</span> (j = 0; j &lt; update_num_procs; j++)
<a name="l00738"></a>00738   {
<a name="l00739"></a>00739     rval = MPI_Irecv(&amp;(update_gid[update_procs_offset[j]]),
<a name="l00740"></a>00740              update_procs_num_vtx[j],
<a name="l00741"></a>00741              <span class="keyword">sizeof</span>(size_t) == 4 ? MPI_INT : MPI_DOUBLE,
<a name="l00742"></a>00742              update_procs[j],
<a name="l00743"></a>00743              <a class="code" href="ParallelHelper_8cpp.html#b6f55b7d22af555cc8749885e91c1cfe">GHOST_NODE_VERTEX_GIDS</a>,
<a name="l00744"></a>00744              (MPI_Comm)communicator,
<a name="l00745"></a>00745               &amp;(requests_updates[j]));
<a name="l00746"></a>00746     <a class="code" href="ParallelHelper_8cpp.html#78b12d3996624c2282598c84cabf1874">CHECK_MPI</a>(rval,err);
<a name="l00747"></a>00747   }
<a name="l00748"></a>00748 
<a name="l00749"></a>00749   <span class="comment">/* wait until we have heard from all processors which vertices they want from us */</span>
<a name="l00750"></a>00750   rval = MPI_Waitall(update_num_procs, <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(requests_updates), <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(status_update));
<a name="l00751"></a>00751   <a class="code" href="ParallelHelper_8cpp.html#78b12d3996624c2282598c84cabf1874">CHECK_MPI</a>(rval,err);
<a name="l00752"></a>00752 
<a name="l00753"></a>00753   <span class="comment">/* wait until we have sent to all processors which vertices we want from them */</span>
<a name="l00754"></a>00754   std::vector&lt;MPI_Status&gt; status_unghost(unghost_num_procs);
<a name="l00755"></a>00755   rval = MPI_Waitall(unghost_num_procs, <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(requests_unghost), <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(status_unghost));
<a name="l00756"></a>00756   <a class="code" href="ParallelHelper_8cpp.html#78b12d3996624c2282598c84cabf1874">CHECK_MPI</a>(rval,err);
<a name="l00757"></a>00757   
<a name="l00758"></a>00758   <span class="comment">/*</span>
<a name="l00759"></a>00759 <span class="comment">  for (j = 0; j &lt; update_num_procs; j++)</span>
<a name="l00760"></a>00760 <span class="comment">  {</span>
<a name="l00761"></a>00761 <span class="comment">    printf("[%d] will send to proc %d:", rank, update_procs[j]);</span>
<a name="l00762"></a>00762 <span class="comment">    for (i = update_procs_offset[j]; i &lt; update_procs_offset[j+1]; i++) printf(" %d", update_gid[i]);</span>
<a name="l00763"></a>00763 <span class="comment">    printf("\n");</span>
<a name="l00764"></a>00764 <span class="comment">  }</span>
<a name="l00765"></a>00765 <span class="comment">  */</span>
<a name="l00766"></a>00766 
<a name="l00767"></a>00767 
<a name="l00768"></a>00768   <span class="comment">/***********************************************************************</span>
<a name="l00769"></a>00769 <span class="comment"> COMPUTE THE SET OF NEIGHBORS THAT OUR VERTICES HAVE ON OTHER PROCESSORS</span>
<a name="l00770"></a>00770 <span class="comment">               COMPUTE THE SET OF NEIGHBORS PROCESSORS</span>
<a name="l00771"></a>00771 <span class="comment">  ***********************************************************************/</span>
<a name="l00772"></a>00772 
<a name="l00773"></a>00773   <span class="keywordflow">if</span> (num_vtx_partition_boundary_local == 0)
<a name="l00774"></a>00774   {
<a name="l00775"></a>00775     <span class="comment">/* this processor does not partake in the boundary smoothing */</span>
<a name="l00776"></a>00776     neighbourProc.clear();
<a name="l00777"></a>00777     mesh-&gt;<a class="code" href="classMesquite_1_1Mesh.html#40e223df07cbb5f38e72c075aa9ab9f5">tag_delete</a>( lid_tag, err );
<a name="l00778"></a>00778     vtx_partition_boundary_map_inverse.clear();
<a name="l00779"></a>00779     <span class="keywordflow">return</span>;
<a name="l00780"></a>00780   }
<a name="l00781"></a>00781 
<a name="l00782"></a>00782   <span class="comment">/* init the neighbour processor list */</span>
<a name="l00783"></a>00783   neighbourProc.clear();
<a name="l00784"></a>00784 
<a name="l00785"></a>00785   <span class="comment">/* init the neighbour lists */</span>
<a name="l00786"></a>00786 
<a name="l00787"></a>00787   vtx_off_proc_list.clear();
<a name="l00788"></a>00788   vtx_off_proc_list.resize( num_vtx_partition_boundary_local );
<a name="l00789"></a>00789 
<a name="l00790"></a>00790   <span class="comment">/* get the adjacency arrays that we need */</span>
<a name="l00791"></a>00791   std::vector&lt;Mesquite::Mesh::ElementHandle&gt; adj_elements;
<a name="l00792"></a>00792   std::vector&lt;Mesquite::Mesh::VertexHandle&gt; adj_adj_vertices;
<a name="l00793"></a>00793   std::vector&lt;size_t&gt; elem_offsets;
<a name="l00794"></a>00794   std::vector&lt;size_t&gt; adj_vtx_offsets;
<a name="l00795"></a>00795   mesh-&gt;<a class="code" href="classMesquite_1_1Mesh.html#b671ad5f2dacaf729743d9d0876e435b">vertices_get_attached_elements</a>(<a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(part_vertices),num_vtx_partition_boundary_local,
<a name="l00796"></a>00796                                          adj_elements,elem_offsets,err);
<a name="l00797"></a>00797   mesh-&gt;<a class="code" href="classMesquite_1_1Mesh.html#fd0dab3edfb6d7570a08f4cb5aa295ef">elements_get_attached_vertices</a>(<a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(adj_elements),adj_elements.size(),
<a name="l00798"></a>00798                                          adj_adj_vertices,adj_vtx_offsets,err);
<a name="l00799"></a>00799   <span class="comment">//delete adj_elements; adj_elements = 0;</span>
<a name="l00800"></a>00800   std::vector&lt;int&gt; adj_adj_vertices_lid(adj_adj_vertices.size());
<a name="l00801"></a>00801   mesh-&gt;<a class="code" href="classMesquite_1_1Mesh.html#0fd96fd71be129b2eee1500f878cf125">tag_get_vertex_data</a>( lid_tag, adj_adj_vertices.size(), <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(adj_adj_vertices), <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(adj_adj_vertices_lid), err );
<a name="l00802"></a>00802   <span class="comment">//delete adj_adj_vertices; adj_adj_vertices = 0;</span>
<a name="l00803"></a>00803   mesh-&gt;<a class="code" href="classMesquite_1_1Mesh.html#40e223df07cbb5f38e72c075aa9ab9f5">tag_delete</a>( lid_tag, err );
<a name="l00804"></a>00804 
<a name="l00805"></a>00805   <span class="keywordflow">for</span> (i=0;i&lt;num_vtx_partition_boundary_local;i++) {
<a name="l00806"></a>00806     <span class="comment">/* loop over the elements surrounding that vertex */</span>
<a name="l00807"></a>00807     <span class="keywordflow">for</span> (j=elem_offsets[i];j&lt;(int)(elem_offsets[i+1]);j++) {
<a name="l00808"></a>00808       <span class="comment">/* loop over the neighbors of the considered vertex (i.e. the vertices of these element) */</span>
<a name="l00809"></a>00809       <span class="keywordflow">for</span> (k=adj_vtx_offsets[j];k&lt;(int)(adj_vtx_offsets[j+1]);k++) {
<a name="l00810"></a>00810         <span class="comment">/* get the next neighbour */</span>
<a name="l00811"></a>00811         incident_vtx = adj_adj_vertices_lid[k];
<a name="l00812"></a>00812         <span class="comment">/* if this neighbour is a vertex that is smoothed on a different processor */</span>
<a name="l00813"></a>00813         <span class="keywordflow">if</span> (vtx_in_partition_boundary[incident_vtx] == 2) {
<a name="l00814"></a>00814           <span class="comment">/* then map it into our domain */</span>
<a name="l00815"></a>00815           incident_vtx = vtx_partition_boundary_map_inverse[incident_vtx];
<a name="l00816"></a>00816           <span class="comment">/* is this vertex already in our neighbour list ? */</span>
<a name="l00817"></a>00817           <span class="keywordflow">if</span> (std::find( vtx_off_proc_list[i].begin(), vtx_off_proc_list[i].end(), incident_vtx)
<a name="l00818"></a>00818             == vtx_off_proc_list[i].end()) {
<a name="l00819"></a>00819             <span class="comment">/* if the vertex is not in the list yet ... add it */</span>
<a name="l00820"></a>00820             vtx_off_proc_list[i].push_back( incident_vtx );
<a name="l00821"></a>00821             <span class="comment">/* is the processor of this vertex already in the processor list */</span>
<a name="l00822"></a>00822             incident_vtx = part_proc_owner[incident_vtx];
<a name="l00823"></a>00823             <span class="comment">/* check by scanning the list for this processor */</span>
<a name="l00824"></a>00824             <span class="keywordflow">if</span> (std::find(neighbourProc.begin(), neighbourProc.end(), incident_vtx)
<a name="l00825"></a>00825                 ==  neighbourProc.end()) {
<a name="l00826"></a>00826               <span class="comment">/* the processor is not in the list yet ... add it */</span>
<a name="l00827"></a>00827               neighbourProc.push_back( incident_vtx );
<a name="l00828"></a>00828             }
<a name="l00829"></a>00829           }
<a name="l00830"></a>00830         }
<a name="l00831"></a>00831       }
<a name="l00832"></a>00832     }
<a name="l00833"></a>00833   }
<a name="l00834"></a>00834 
<a name="l00835"></a>00835   <span class="comment">/* sort the list of neighbour processors */</span>
<a name="l00836"></a>00836   
<a name="l00837"></a>00837   std::sort( neighbourProc.begin(), neighbourProc.end() );
<a name="l00838"></a>00838 
<a name="l00839"></a>00839   <span class="comment">/***********************************************************************</span>
<a name="l00840"></a>00840 <span class="comment">    COMPUTE HOW MANY VERTICES WE NEED TO SEND/RECV FROM EACH PROCESSOR</span>
<a name="l00841"></a>00841 <span class="comment">  ***********************************************************************/</span>
<a name="l00842"></a>00842   neighbourProcSend.clear();
<a name="l00843"></a>00843   neighbourProcRecv.clear();
<a name="l00844"></a>00844   neighbourProcSendRemain.clear();
<a name="l00845"></a>00845   neighbourProcRecvRemain.clear();
<a name="l00846"></a>00846 
<a name="l00847"></a>00847   <span class="keywordflow">if</span> (communication_model &amp; 1) <span class="comment">// AVOID_ALL_REDUCE</span>
<a name="l00848"></a>00848   {
<a name="l00849"></a>00849     total_num_vertices_to_smooth = num_vtx_partition_boundary_local;
<a name="l00850"></a>00850     total_num_vertices_to_recv = num_vtx_partition_boundary_remote;
<a name="l00851"></a>00851     neighbourProcSend.resize(neighbourProc.size(), 0);
<a name="l00852"></a>00852     neighbourProcRecv.resize(neighbourProc.size(), 0);
<a name="l00853"></a>00853 
<a name="l00854"></a>00854     <span class="comment">/* for each vertex we smooth find the processors we need to send it too */</span>
<a name="l00855"></a>00855     <span class="keywordflow">for</span> (i=0;i&lt;num_vtx_partition_boundary_local;i++) {
<a name="l00856"></a>00856         <span class="comment">/* loop over its adjacent off-processor vertices */</span>
<a name="l00857"></a>00857         <span class="keywordflow">for</span> (j=0;j&lt;(long)vtx_off_proc_list[i].size(); j++) {
<a name="l00858"></a>00858           <span class="comment">/* get the processor id of these vertices */</span>
<a name="l00859"></a>00859           incident_vtx = part_proc_owner[vtx_off_proc_list[i][j]];
<a name="l00860"></a>00860           <span class="comment">/* check if we got this processor id before */</span>
<a name="l00861"></a>00861           <span class="keywordflow">for</span> (k=0;k&lt;j;k++) {
<a name="l00862"></a>00862             <span class="keywordflow">if</span> (incident_vtx == part_proc_owner[vtx_off_proc_list[i][k]]) {
<a name="l00863"></a>00863               <span class="comment">/* if we have has this procesor id already we do not need to count it again */</span>
<a name="l00864"></a>00864               incident_vtx = -1;
<a name="l00865"></a>00865               <span class="keywordflow">break</span>;
<a name="l00866"></a>00866             }
<a name="l00867"></a>00867           }
<a name="l00868"></a>00868           <span class="comment">/* if this was a new processor id */</span>
<a name="l00869"></a>00869           <span class="keywordflow">if</span> (incident_vtx != -1) {
<a name="l00870"></a>00870             <span class="comment">/* find the processor in the list and increment its counter */</span>
<a name="l00871"></a>00871             <span class="keywordflow">for</span> (l = 0; l &lt; neighbourProc.size(); l++) {
<a name="l00872"></a>00872               <span class="keywordflow">if</span> (neighbourProc[l] == incident_vtx) {
<a name="l00873"></a>00873                 neighbourProcSend[l]++;
<a name="l00874"></a>00874                 <span class="keywordflow">break</span>;
<a name="l00875"></a>00875               }
<a name="l00876"></a>00876             }
<a name="l00877"></a>00877           }
<a name="l00878"></a>00878         }
<a name="l00879"></a>00879     }
<a name="l00880"></a>00880     <span class="keywordflow">for</span> (i=num_vtx_partition_boundary_local;i&lt;num_vtx_partition_boundary;i++) {
<a name="l00881"></a>00881         incident_vtx = part_proc_owner[i];
<a name="l00882"></a>00882         <span class="keywordflow">for</span> (l = 0; l &lt; neighbourProc.size(); l++) {
<a name="l00883"></a>00883           <span class="keywordflow">if</span> (neighbourProc[l] == incident_vtx) {
<a name="l00884"></a>00884             neighbourProcRecv[l]++;
<a name="l00885"></a>00885             <span class="keywordflow">break</span>;
<a name="l00886"></a>00886           }
<a name="l00887"></a>00887         }
<a name="l00888"></a>00888     }
<a name="l00889"></a>00889     neighbourProcSendRemain.resize(neighbourProc.size());
<a name="l00890"></a>00890     neighbourProcRecvRemain.resize(neighbourProc.size());
<a name="l00891"></a>00891   }
<a name="l00892"></a>00892 
<a name="l00893"></a>00893   exportVtxGIDs.resize(num_vtx_partition_boundary);
<a name="l00894"></a>00894   exportVtxLIDs.resize(num_vtx_partition_boundary);
<a name="l00895"></a>00895   exportProc.resize(num_vtx_partition_boundary);
<a name="l00896"></a>00896   in_independent_set.resize(num_vtx_partition_boundary_local);
<a name="l00897"></a>00897 }
<a name="l00898"></a>00898 
<a name="l00899"></a>00899 
<a name="l00900"></a><a class="code" href="classMesquite_1_1ParallelHelperImpl.html#fbd7bd2649b18a8420db14097e348857">00900</a> <span class="keywordtype">void</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#fbd7bd2649b18a8420db14097e348857">ParallelHelperImpl::compute_first_independent_set</a>(std::vector&lt;Mesh::VertexHandle&gt;&amp; fixed_vertices)
<a name="l00901"></a>00901 {
<a name="l00902"></a>00902   <span class="keywordflow">if</span> (nprocs == 1) <span class="keywordflow">return</span>;
<a name="l00903"></a>00903 
<a name="l00904"></a>00904   <span class="keywordtype">int</span> i;
<a name="l00905"></a>00905 
<a name="l00906"></a>00906   <span class="comment">// to avoid all reduce we need to know how many vertices we send &amp; receive</span>
<a name="l00907"></a>00907   <span class="keywordflow">if</span> (communication_model &amp; 1) <span class="comment">// AVOID_ALL_REDUCE</span>
<a name="l00908"></a>00908   {
<a name="l00909"></a>00909     <span class="keywordflow">for</span> (i=0;i&lt;(long)neighbourProc.size();i++) {
<a name="l00910"></a>00910       neighbourProcSendRemain[i] = neighbourProcSend[i];
<a name="l00911"></a>00911       neighbourProcRecvRemain[i] = neighbourProcRecv[i];
<a name="l00912"></a>00912     }
<a name="l00913"></a>00913   }
<a name="l00914"></a>00914 
<a name="l00915"></a>00915   <span class="comment">// this is iteration zero of the bounday smooting process</span>
<a name="l00916"></a>00916   iteration = 0;
<a name="l00917"></a>00917 
<a name="l00918"></a>00918   <span class="comment">// mark all boundary partition vertices as not smoothed</span>
<a name="l00919"></a>00919   <span class="keywordflow">for</span> (i=0;i&lt;num_vtx_partition_boundary;i++) {
<a name="l00920"></a>00920     part_smoothed_flag[i] = 0;
<a name="l00921"></a>00921   }
<a name="l00922"></a>00922 
<a name="l00923"></a>00923   <span class="comment">// populates the in_independent_set and the vertex export arrays</span>
<a name="l00924"></a>00924   compute_independent_set();
<a name="l00925"></a>00925 
<a name="l00926"></a>00926   <span class="comment">// counts how many vertices are already smoothed</span>
<a name="l00927"></a>00927   num_already_smoothed_vertices = 0;
<a name="l00928"></a>00928 
<a name="l00929"></a>00929   fixed_vertices.clear();
<a name="l00930"></a>00930 
<a name="l00931"></a>00931   <span class="comment">/* mark which local boundary partition vertices are already smoothed (i.e. they are in the 1st independent set) */</span>
<a name="l00932"></a>00932   <span class="keywordflow">for</span> (i=0;i&lt;num_vtx_partition_boundary_local;i++) {
<a name="l00933"></a>00933     <span class="keywordflow">if</span> (in_independent_set[i]) {
<a name="l00934"></a>00934       part_smoothed_flag[i] = 1;
<a name="l00935"></a>00935       num_already_smoothed_vertices++;
<a name="l00936"></a>00936     }
<a name="l00937"></a>00937     <span class="keywordflow">else</span> {
<a name="l00938"></a>00938       fixed_vertices.push_back(part_vertices[i]); <span class="comment">// fix vertices *not* in the independent set</span>
<a name="l00939"></a>00939     }
<a name="l00940"></a>00940   }
<a name="l00941"></a>00941 
<a name="l00942"></a>00942   <span class="keywordflow">if</span> (0) {printf(<span class="stringliteral">"[%d]i%d after first we smoothed %d of %d\n"</span>,rank,iteration,num_already_smoothed_vertices,num_vtx_partition_boundary_local); fflush(NULL);}
<a name="l00943"></a>00943 
<a name="l00944"></a>00944   <span class="comment">// fix the ghost vertices that are smoothed on another processor</span>
<a name="l00945"></a>00945   <span class="keywordflow">for</span> (i=num_vtx_partition_boundary_local;i&lt;num_vtx_partition_boundary;i++) {
<a name="l00946"></a>00946     fixed_vertices.push_back(part_vertices[i]);
<a name="l00947"></a>00947   }
<a name="l00948"></a>00948 
<a name="l00949"></a>00949   <span class="comment">// fix the ghost vertices that are unused</span>
<a name="l00950"></a>00950   <span class="keywordflow">for</span> (i=0;i&lt;(int)(unghost_vertices.size());i++) {
<a name="l00951"></a>00951     fixed_vertices.push_back(unghost_vertices[i]);
<a name="l00952"></a>00952   }
<a name="l00953"></a>00953 }
<a name="l00954"></a>00954 
<a name="l00955"></a><a class="code" href="classMesquite_1_1ParallelHelperImpl.html#a7c0ce63602b8dba4d939ccc22707888">00955</a> <span class="keywordtype">void</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#a7c0ce63602b8dba4d939ccc22707888">ParallelHelperImpl::communicate_first_independent_set</a>(<a class="code" href="classMesquite_1_1MsqError.html">MsqError</a>&amp; err)
<a name="l00956"></a>00956 {
<a name="l00957"></a>00957   <span class="keywordflow">if</span> (nprocs == 1) <span class="keywordflow">return</span>;
<a name="l00958"></a>00958 
<a name="l00959"></a>00959   <span class="keywordflow">switch</span> (communication_model)
<a name="l00960"></a>00960   {
<a name="l00961"></a>00961   <span class="keywordflow">case</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#129bd7bfb54772d608af770b5ab06208750a82ba1372209a3439fb75f29604ff">TrulyNonBlocking</a>:
<a name="l00962"></a>00962     num_already_recv_vertices = comm_smoothed_vtx_tnb(err);
<a name="l00963"></a>00963     <span class="keywordflow">break</span>;
<a name="l00964"></a>00964   <span class="keywordflow">case</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#129bd7bfb54772d608af770b5ab06208fa03e2f94dd01f27453b505e8d15f795">TrulyNonBlockingAvoidAllReduce</a>:
<a name="l00965"></a>00965     num_already_recv_vertices = comm_smoothed_vtx_tnb_no_all(err);
<a name="l00966"></a>00966     <span class="keywordflow">break</span>;
<a name="l00967"></a>00967   <span class="keywordflow">case</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#129bd7bfb54772d608af770b5ab062082ec093e16f1c79b3a6e077625960ef65">NonBlocking</a>:
<a name="l00968"></a>00968     num_already_recv_vertices = comm_smoothed_vtx_nb(err);
<a name="l00969"></a>00969     <span class="keywordflow">break</span>;
<a name="l00970"></a>00970   <span class="keywordflow">case</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#129bd7bfb54772d608af770b5ab062086c5102fec39c39bafc0690260b9adea6">NonBlockingAvoidAllReduce</a>:
<a name="l00971"></a>00971     num_already_recv_vertices = comm_smoothed_vtx_nb_no_all(err);
<a name="l00972"></a>00972     <span class="keywordflow">break</span>;
<a name="l00973"></a>00973   <span class="keywordflow">case</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#129bd7bfb54772d608af770b5ab06208595c5b4b375eac51c28f3823718048db">Blocking</a>:
<a name="l00974"></a>00974     num_already_recv_vertices = comm_smoothed_vtx_b(err);
<a name="l00975"></a>00975     <span class="keywordflow">break</span>;
<a name="l00976"></a>00976   <span class="keywordflow">case</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#129bd7bfb54772d608af770b5ab062086fc77fc81eab45322a1c94f2c52524ba">BlockingAvoidAllReduce</a>:
<a name="l00977"></a>00977     num_already_recv_vertices = comm_smoothed_vtx_b_no_all(err);
<a name="l00978"></a>00978     <span class="keywordflow">break</span>;
<a name="l00979"></a>00979   }
<a name="l00980"></a>00980   global_work_remains = (neighbourProc.size() ? 1 : 0);
<a name="l00981"></a>00981   <a class="code" href="group__error.html#g89169bf923bf910753638052db433a22">MSQ_CHKERR</a>(err);
<a name="l00982"></a>00982 }
<a name="l00983"></a>00983 
<a name="l00984"></a><a class="code" href="classMesquite_1_1ParallelHelperImpl.html#51e833b5ccc164183b4d37258dadc1f1">00984</a> <span class="keywordtype">bool</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#51e833b5ccc164183b4d37258dadc1f1">ParallelHelperImpl::compute_next_independent_set</a>()
<a name="l00985"></a>00985 {
<a name="l00986"></a>00986   <span class="keywordflow">if</span> (nprocs == 1) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00987"></a>00987 
<a name="l00988"></a>00988   <span class="keywordflow">if</span> (global_work_remains &amp;&amp; (iteration&lt;20))
<a name="l00989"></a>00989   {
<a name="l00990"></a>00990     iteration++;
<a name="l00991"></a>00991     <span class="keywordflow">if</span> (0) printf(<span class="stringliteral">"[%d] work remains %d after %d iterations\n"</span>, rank, global_work_remains, iteration);
<a name="l00992"></a>00992     compute_independent_set();
<a name="l00993"></a>00993     next_vtx_partition_boundary = 0;
<a name="l00994"></a>00994     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00995"></a>00995   }
<a name="l00996"></a>00996   <span class="keywordflow">else</span>
<a name="l00997"></a>00997   {
<a name="l00998"></a>00998     <span class="keywordflow">if</span> (global_work_remains)
<a name="l00999"></a>00999     {
<a name="l01000"></a>01000       printf(<span class="stringliteral">"WARNING: global work remains %d after %d iterations\n"</span>, global_work_remains, iteration);
<a name="l01001"></a>01001     }
<a name="l01002"></a>01002     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01003"></a>01003   }
<a name="l01004"></a>01004 }
<a name="l01005"></a>01005 
<a name="l01006"></a><a class="code" href="classMesquite_1_1ParallelHelperImpl.html#9d79e713dc388df186e0eeece35a6a35">01006</a> <span class="keywordtype">bool</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#9d79e713dc388df186e0eeece35a6a35">ParallelHelperImpl::get_next_partition_boundary_vertex</a>(<a class="code" href="classMesquite_1_1Mesh.html#9d765053bc19100f1de05d87d4222777">Mesquite::Mesh::VertexHandle</a>&amp; vertex_handle)
<a name="l01007"></a>01007 {
<a name="l01008"></a>01008   <span class="keywordflow">while</span> (next_vtx_partition_boundary &lt; num_vtx_partition_boundary_local)
<a name="l01009"></a>01009   {
<a name="l01010"></a>01010     <span class="keywordflow">if</span> (in_independent_set[next_vtx_partition_boundary]) {
<a name="l01011"></a>01011       vertex_handle = part_vertices[next_vtx_partition_boundary];
<a name="l01012"></a>01012       num_already_smoothed_vertices++;
<a name="l01013"></a>01013       assert(part_smoothed_flag[next_vtx_partition_boundary] == 0);
<a name="l01014"></a>01014       part_smoothed_flag[next_vtx_partition_boundary] = 1;
<a name="l01015"></a>01015       next_vtx_partition_boundary++;
<a name="l01016"></a>01016       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01017"></a>01017     }
<a name="l01018"></a>01018     next_vtx_partition_boundary++;
<a name="l01019"></a>01019   }
<a name="l01020"></a>01020   <span class="keywordflow">if</span> (0) {printf(<span class="stringliteral">"[%d]i%d after next we smoothed %d of %d\n"</span>,rank,iteration,num_already_smoothed_vertices,num_vtx_partition_boundary_local); fflush(NULL);}
<a name="l01021"></a>01021   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01022"></a>01022 }
<a name="l01023"></a>01023 
<a name="l01024"></a><a class="code" href="classMesquite_1_1ParallelHelperImpl.html#f5e5fdb2aa3882fb0314d80dc938588b">01024</a> <span class="keywordtype">void</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#f5e5fdb2aa3882fb0314d80dc938588b">ParallelHelperImpl::communicate_next_independent_set</a>(<a class="code" href="classMesquite_1_1MsqError.html">MsqError</a>&amp; err)
<a name="l01025"></a>01025 {
<a name="l01026"></a>01026   <span class="keywordflow">switch</span> (communication_model)
<a name="l01027"></a>01027   {
<a name="l01028"></a>01028   <span class="keywordflow">case</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#129bd7bfb54772d608af770b5ab06208750a82ba1372209a3439fb75f29604ff">TrulyNonBlocking</a>:
<a name="l01029"></a>01029     num_already_recv_vertices += comm_smoothed_vtx_tnb(err);
<a name="l01030"></a>01030     <span class="keywordflow">break</span>;
<a name="l01031"></a>01031   <span class="keywordflow">case</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#129bd7bfb54772d608af770b5ab06208fa03e2f94dd01f27453b505e8d15f795">TrulyNonBlockingAvoidAllReduce</a>:
<a name="l01032"></a>01032     num_already_recv_vertices += comm_smoothed_vtx_tnb_no_all(err);
<a name="l01033"></a>01033     <span class="keywordflow">break</span>;
<a name="l01034"></a>01034   <span class="keywordflow">case</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#129bd7bfb54772d608af770b5ab062082ec093e16f1c79b3a6e077625960ef65">NonBlocking</a>:
<a name="l01035"></a>01035     num_already_recv_vertices += comm_smoothed_vtx_nb(err);
<a name="l01036"></a>01036     <span class="keywordflow">break</span>;
<a name="l01037"></a>01037   <span class="keywordflow">case</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#129bd7bfb54772d608af770b5ab062086c5102fec39c39bafc0690260b9adea6">NonBlockingAvoidAllReduce</a>:
<a name="l01038"></a>01038     num_already_recv_vertices += comm_smoothed_vtx_nb_no_all(err);
<a name="l01039"></a>01039     <span class="keywordflow">break</span>;
<a name="l01040"></a>01040   <span class="keywordflow">case</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#129bd7bfb54772d608af770b5ab06208595c5b4b375eac51c28f3823718048db">Blocking</a>:
<a name="l01041"></a>01041     num_already_recv_vertices += comm_smoothed_vtx_b(err);
<a name="l01042"></a>01042     <span class="keywordflow">break</span>;
<a name="l01043"></a>01043   <span class="keywordflow">case</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#129bd7bfb54772d608af770b5ab062086fc77fc81eab45322a1c94f2c52524ba">BlockingAvoidAllReduce</a>:
<a name="l01044"></a>01044     num_already_recv_vertices += comm_smoothed_vtx_b_no_all(err);
<a name="l01045"></a>01045     <span class="keywordflow">break</span>;
<a name="l01046"></a>01046   }
<a name="l01047"></a>01047 
<a name="l01048"></a>01048   <span class="keywordflow">if</span> (communication_model &amp; 1) <span class="comment">// AVOID_ALL_REDUCE</span>
<a name="l01049"></a>01049   {
<a name="l01050"></a>01050     global_work_remains = (total_num_vertices_to_smooth - num_already_smoothed_vertices) + (total_num_vertices_to_recv - num_already_recv_vertices); 
<a name="l01051"></a>01051     <span class="keywordflow">if</span> (0) {printf(<span class="stringliteral">"[%d]i%d %d - %d + %d  - %d = %d \n"</span>,rank,iteration,total_num_vertices_to_smooth,num_already_smoothed_vertices,total_num_vertices_to_recv,num_already_recv_vertices,global_work_remains); fflush(NULL);}
<a name="l01052"></a>01052   }
<a name="l01053"></a>01053   <span class="keywordflow">else</span>
<a name="l01054"></a>01054   {
<a name="l01055"></a>01055     <span class="keywordtype">int</span> i, work_remains = 0;
<a name="l01056"></a>01056     <span class="keywordflow">for</span> (i=0;i&lt;num_vtx_partition_boundary_local;i++) {
<a name="l01057"></a>01057       <span class="keywordflow">if</span> (part_smoothed_flag[i] == 0) {
<a name="l01058"></a>01058         work_remains++;
<a name="l01059"></a>01059       }
<a name="l01060"></a>01060     }
<a name="l01061"></a>01061     <span class="keywordtype">int</span> rval = MPI_Allreduce(&amp;work_remains, &amp;global_work_remains, 1, MPI_INT, MPI_SUM, (MPI_Comm)communicator);
<a name="l01062"></a>01062     <a class="code" href="ParallelHelper_8cpp.html#78b12d3996624c2282598c84cabf1874">CHECK_MPI</a>(rval, err);
<a name="l01063"></a>01063   }
<a name="l01064"></a>01064 }
<a name="l01065"></a>01065 
<a name="l01066"></a><a class="code" href="classMesquite_1_1ParallelHelperImpl.html#9590c88faa6d2ee8d52777294e9c77fc">01066</a> <span class="keywordtype">void</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#9590c88faa6d2ee8d52777294e9c77fc">ParallelHelperImpl::smoothing_close</a>(<a class="code" href="classMesquite_1_1MsqError.html">MsqError</a>&amp; err)
<a name="l01067"></a>01067 {
<a name="l01068"></a>01068   <span class="keywordtype">int</span> i,j, rval;
<a name="l01069"></a>01069 
<a name="l01070"></a>01070   <span class="keywordflow">if</span> (nprocs == 1) <span class="keywordflow">return</span>;
<a name="l01071"></a>01071 
<a name="l01072"></a>01072   <span class="comment">//  printf("[%d] used %d iterations\n", rank, iteration);</span>
<a name="l01073"></a>01073 
<a name="l01074"></a>01074   <span class="comment">// communicate unused ghost nodes  </span>
<a name="l01075"></a>01075 
<a name="l01076"></a>01076   std::vector&lt;double&gt; update_updates;
<a name="l01077"></a>01077   std::vector&lt;MPI_Request&gt; update_requests;
<a name="l01078"></a>01078 
<a name="l01079"></a>01079   <span class="keywordflow">if</span> (update_num_procs)
<a name="l01080"></a>01080   {
<a name="l01081"></a>01081     <span class="comment">/* get the tags so we can find the requested vertices */</span>
<a name="l01082"></a>01082     std::vector&lt;size_t&gt; gid(num_vertex);
<a name="l01083"></a>01083     mesh-&gt;<a class="code" href="classMesquite_1_1ParallelMesh.html#cce40fc332b2dfa298027720c2e2ce42">vertices_get_global_id</a>(<a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(vertices),<a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(gid),num_vertex,err); <a class="code" href="group__error.html#gb3bb4847196a6336b1fe6e2fd18caaef">MSQ_ERRRTN</a>(err);
<a name="l01084"></a>01084     std::vector&lt;unsigned char&gt; app_fixed(num_vertex);
<a name="l01085"></a>01085     mesh-&gt;<a class="code" href="classMesquite_1_1Mesh.html#d6a2fb69dc334fa46f9123dea16828fc">vertices_get_byte</a>(<a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(vertices),<a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(app_fixed),num_vertex,err); <a class="code" href="group__error.html#gb3bb4847196a6336b1fe6e2fd18caaef">MSQ_ERRRTN</a>(err);
<a name="l01086"></a>01086     std::vector&lt;int&gt; proc_owner(num_vertex);
<a name="l01087"></a>01087     mesh-&gt;<a class="code" href="classMesquite_1_1ParallelMesh.html#ab8227ceb6ea93ee139ac2748e6e98cd">vertices_get_processor_id</a>(<a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(vertices),<a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(proc_owner),num_vertex,err); <a class="code" href="group__error.html#gb3bb4847196a6336b1fe6e2fd18caaef">MSQ_ERRRTN</a>(err);
<a name="l01088"></a>01088 
<a name="l01089"></a>01089     <span class="keywordflow">if</span> (0)
<a name="l01090"></a>01090       {
<a name="l01091"></a>01091         <span class="keywordtype">int</span> ncull=0;
<a name="l01092"></a>01092         <span class="keywordflow">for</span> (i = 0; i &lt; num_vertex; ++i)
<a name="l01093"></a>01093           {
<a name="l01094"></a>01094             <span class="keywordflow">if</span> (app_fixed[i] &amp; <a class="code" href="classMesquite_1_1MsqVertex.html#2e255a70db385be125bd6798085605d5f83ca01c3d59a22c3fb6d4d9a36b8cb3">MsqVertex::MSQ_CULLED</a>)
<a name="l01095"></a>01095               {
<a name="l01096"></a>01096                 ++ncull;
<a name="l01097"></a>01097               }
<a name="l01098"></a>01098           }
<a name="l01099"></a>01099         std::cout &lt;&lt; <span class="stringliteral">"P["</span> &lt;&lt; rank &lt;&lt; <span class="stringliteral">"] ncull= "</span> &lt;&lt; ncull &lt;&lt; <span class="stringliteral">" num_vertex= "</span> &lt;&lt; num_vertex &lt;&lt; std::endl;
<a name="l01100"></a>01100       }
<a name="l01101"></a>01101 
<a name="l01102"></a>01102     <span class="comment">/* only interested in fixed flag from vertex byte? Clear others. */</span>
<a name="l01103"></a>01103     <span class="comment">// srkenno AT sandia.gov 1/19/12: bug fix: changed from |= which makes all vertices fixed</span>
<a name="l01104"></a>01104     <span class="keywordflow">for</span> (i = 0; i &lt; num_vertex; ++i)
<a name="l01105"></a>01105       app_fixed[i] &amp;= <a class="code" href="classMesquite_1_1MsqVertex.html#2e255a70db385be125bd6798085605d5df282e146f11277088c56741de570dbc">MsqVertex::MSQ_HARD_FIXED</a>;
<a name="l01106"></a>01106 
<a name="l01107"></a>01107     <span class="comment">/* insert all our unfixed vertices into a map so we can find the requested vertices efficiently */</span>
<a name="l01108"></a>01108     <a class="code" href="namespaceMesquite.html#aff7adf7a48e76eb81e3c029e7964a4b">VertexIdMap</a> temp_vid_map;
<a name="l01109"></a>01109     <span class="keywordflow">for</span> (j = 0; j &lt; num_vertex; j++)
<a name="l01110"></a>01110     {
<a name="l01111"></a>01111       <span class="keywordflow">if</span> (proc_owner[j] == rank &amp;&amp; app_fixed[j] == <span class="keyword">false</span>)
<a name="l01112"></a>01112       {
<a name="l01113"></a>01113         vertex_map_insert(temp_vid_map, gid[j], rank, j);
<a name="l01114"></a>01114       }
<a name="l01115"></a>01115     }
<a name="l01116"></a>01116 
<a name="l01117"></a>01117     <span class="comment">/* deallocate the tags */</span>
<a name="l01118"></a>01118     <span class="comment">//delete [] gid; gid = 0;</span>
<a name="l01119"></a>01119     <span class="comment">//delete [] app_fixed; app_fixed = 0;</span>
<a name="l01120"></a>01120     <span class="comment">//delete [] proc_owner; proc_owner = 0;</span>
<a name="l01121"></a>01121     
<a name="l01122"></a>01122     <span class="comment">/* find the requested updates and collect them into an array */</span>
<a name="l01123"></a>01123     <a class="code" href="classMesquite_1_1MsqVertex.html">Mesquite::MsqVertex</a> coordinates;
<a name="l01124"></a>01124     update_updates.resize(update_num_vtx*3);
<a name="l01125"></a>01125     <span class="keywordflow">for</span> (i = 0; i &lt; update_num_vtx; i++)
<a name="l01126"></a>01126     {
<a name="l01127"></a>01127       j = vertex_map_find(temp_vid_map, update_gid[i], rank);
<a name="l01128"></a>01128       mesh-&gt;<a class="code" href="classMesquite_1_1Mesh.html#94a5d2a9982d8480ed2db33f8b2379f3">vertices_get_coordinates</a>(&amp;(vertices[j]),&amp;coordinates,1,err); <a class="code" href="group__error.html#gb3bb4847196a6336b1fe6e2fd18caaef">MSQ_ERRRTN</a>(err);
<a name="l01129"></a>01129       update_updates[3*i+0] = coordinates[0];
<a name="l01130"></a>01130       update_updates[3*i+1] = coordinates[1];
<a name="l01131"></a>01131       update_updates[3*i+2] = coordinates[2];
<a name="l01132"></a>01132       <span class="comment">//      printf("[%d] send gid %d with %g %g %g\n", rank, update_gid[i], coordinates[0], coordinates[1], coordinates[2]);</span>
<a name="l01133"></a>01133     }
<a name="l01134"></a>01134 
<a name="l01135"></a>01135     <span class="comment">/* deallocate the map and the gid array */</span>
<a name="l01136"></a>01136     <span class="comment">//delete temp_vid_map; temp_vid_map = 0;</span>
<a name="l01137"></a>01137     <span class="comment">//delete [] update_gid; update_gid = 0;</span>
<a name="l01138"></a>01138 
<a name="l01139"></a>01139     update_requests.resize(update_num_procs);
<a name="l01140"></a>01140     <span class="comment">/* send each processor the unused ghost node updates that they requested */</span>
<a name="l01141"></a>01141     <span class="keywordflow">for</span> (j = 0; j &lt; update_num_procs; j++)
<a name="l01142"></a>01142     {
<a name="l01143"></a>01143       rval = MPI_Isend(&amp;(update_updates[update_procs_offset[j] * 3]),
<a name="l01144"></a>01144                 update_procs_num_vtx[j] * 3,
<a name="l01145"></a>01145                 MPI_DOUBLE,
<a name="l01146"></a>01146                 update_procs[j],
<a name="l01147"></a>01147                 <a class="code" href="ParallelHelper_8cpp.html#869853f0b4e76aa416998a5ea1a472d8">GHOST_NODE_VERTEX_UPDATES</a>,
<a name="l01148"></a>01148                 (MPI_Comm)communicator,
<a name="l01149"></a>01149                 &amp;(update_requests[j]));
<a name="l01150"></a>01150       <span class="comment">//      printf("[%d] sending %d of %d from %d with offset %d \n", rank, update_procs_num_vtx[j], update_num_vtx, update_procs[j], update_procs_offset[j]);</span>
<a name="l01151"></a>01151       <a class="code" href="ParallelHelper_8cpp.html#78b12d3996624c2282598c84cabf1874">CHECK_MPI</a>( rval, err );
<a name="l01152"></a>01152     }
<a name="l01153"></a>01153 
<a name="l01154"></a>01154     <span class="comment">/* deallocate more arrays that we no longer need */</span>
<a name="l01155"></a>01155     <span class="comment">//delete [] update_procs_offset; update_procs_offset = 0;</span>
<a name="l01156"></a>01156     <span class="comment">//delete [] update_procs_num_vtx; update_procs_num_vtx = 0;    </span>
<a name="l01157"></a>01157     <span class="comment">//delete [] update_procs; update_procs = 0;</span>
<a name="l01158"></a>01158   }
<a name="l01159"></a>01159 
<a name="l01160"></a>01160   <span class="keywordflow">if</span> (unghost_num_procs)
<a name="l01161"></a>01161   {
<a name="l01162"></a>01162     std::vector&lt;MPI_Request&gt; unghost_requests(unghost_num_procs);
<a name="l01163"></a>01163     <span class="comment">/* receive from each processor the unused ghost nodes updates i want from them */</span>
<a name="l01164"></a>01164     std::vector&lt;double&gt; unghost_updates(unghost_num_vtx*3);
<a name="l01165"></a>01165     <span class="keywordflow">for</span> (j = 0; j &lt; unghost_num_procs; j++)
<a name="l01166"></a>01166     {
<a name="l01167"></a>01167       rval = MPI_Irecv(&amp;(unghost_updates[unghost_procs_offset[j] * 3]),
<a name="l01168"></a>01168                 unghost_procs_num_vtx[j] * 3,
<a name="l01169"></a>01169                 MPI_DOUBLE,
<a name="l01170"></a>01170                 unghost_procs[j],
<a name="l01171"></a>01171                 <a class="code" href="ParallelHelper_8cpp.html#869853f0b4e76aa416998a5ea1a472d8">GHOST_NODE_VERTEX_UPDATES</a>,
<a name="l01172"></a>01172                 (MPI_Comm)communicator,
<a name="l01173"></a>01173                 &amp;(unghost_requests[j]));
<a name="l01174"></a>01174       <span class="comment">//      printf("[%d] receiving %d of %d from %d with offset %d \n", rank, unghost_procs_num_vtx[j], unghost_num_vtx, unghost_procs[j], unghost_procs_offset[j]);</span>
<a name="l01175"></a>01175       <a class="code" href="ParallelHelper_8cpp.html#78b12d3996624c2282598c84cabf1874">CHECK_MPI</a>( rval, err );
<a name="l01176"></a>01176     }
<a name="l01177"></a>01177 
<a name="l01178"></a>01178     <span class="comment">/* deallocate more arrays that we no longer need */</span>
<a name="l01179"></a>01179     <span class="comment">//delete [] unghost_procs_offset; unghost_procs_offset = 0;</span>
<a name="l01180"></a>01180     <span class="comment">//delete [] unghost_procs_num_vtx; unghost_procs_num_vtx = 0;</span>
<a name="l01181"></a>01181     <span class="comment">//delete [] unghost_procs; unghost_procs = 0;</span>
<a name="l01182"></a>01182 
<a name="l01183"></a>01183     std::vector&lt;MPI_Status&gt; status(unghost_num_procs);
<a name="l01184"></a>01184     rval = MPI_Waitall(unghost_num_procs, <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(unghost_requests), <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(status));
<a name="l01185"></a>01185     <a class="code" href="ParallelHelper_8cpp.html#78b12d3996624c2282598c84cabf1874">CHECK_MPI</a>(rval, err);
<a name="l01186"></a>01186 
<a name="l01187"></a>01187     <span class="comment">/* apply the received updates for the unused ghost vertices */</span>
<a name="l01188"></a>01188     <span class="keywordflow">for</span> (i = 0; i &lt; unghost_num_vtx; i++)
<a name="l01189"></a>01189     {
<a name="l01190"></a>01190       <a class="code" href="classMesquite_1_1Vector3D.html">Mesquite::Vector3D</a> coordinates;
<a name="l01191"></a>01191       coordinates[0] = unghost_updates[3*i+0];
<a name="l01192"></a>01192       coordinates[1] = unghost_updates[3*i+1];
<a name="l01193"></a>01193       coordinates[2] = unghost_updates[3*i+2];
<a name="l01194"></a>01194       <span class="comment">//      printf("[%d] recv %g %g %g\n", rank, coordinates[0], coordinates[1], coordinates[2]);</span>
<a name="l01195"></a>01195       mesh-&gt;<a class="code" href="classMesquite_1_1Mesh.html#ac451fb1605551d582b901c33692aab1">vertex_set_coordinates</a>(unghost_vertices[i],coordinates,err); <a class="code" href="group__error.html#gb3bb4847196a6336b1fe6e2fd18caaef">MSQ_ERRRTN</a>(err);
<a name="l01196"></a>01196     }
<a name="l01197"></a>01197 
<a name="l01198"></a>01198     <span class="comment">/* deallocate more arrays that we no longer need */</span>
<a name="l01199"></a>01199     <span class="comment">//delete unghost_vertices; unghost_vertices = 0;</span>
<a name="l01200"></a>01200     <span class="comment">//delete [] unghost_updates; unghost_updates = 0;</span>
<a name="l01201"></a>01201     <span class="comment">//delete [] unghost_requests; unghost_requests = 0;</span>
<a name="l01202"></a>01202   }
<a name="l01203"></a>01203 
<a name="l01204"></a>01204   <span class="comment">//if (update_num_procs)</span>
<a name="l01205"></a>01205   <span class="comment">//{</span>
<a name="l01206"></a>01206   <span class="comment">//  delete [] update_updates; update_updates = 0;</span>
<a name="l01207"></a>01207   <span class="comment">//  delete [] update_requests; update_requests = 0;</span>
<a name="l01208"></a>01208   <span class="comment">//}</span>
<a name="l01209"></a>01209 
<a name="l01210"></a>01210   <span class="comment">//if (vertices) delete vertices; vertices = 0;</span>
<a name="l01211"></a>01211   <span class="comment">//if (vtx_in_partition_boundary) delete [] vtx_in_partition_boundary; vtx_in_partition_boundary = 0;</span>
<a name="l01212"></a>01212   <span class="comment">//if (part_vertices) delete part_vertices; part_vertices = 0;</span>
<a name="l01213"></a>01213   <span class="comment">//if (unghost_vertices) delete unghost_vertices; unghost_vertices = 0;</span>
<a name="l01214"></a>01214   <span class="comment">//if (part_proc_owner) delete [] part_proc_owner; part_proc_owner = 0;</span>
<a name="l01215"></a>01215   <span class="comment">//if (part_gid) delete [] part_gid; part_gid = 0;</span>
<a name="l01216"></a>01216   <span class="comment">//if (part_smoothed_flag) delete [] part_smoothed_flag; part_smoothed_flag = 0; </span>
<a name="l01217"></a>01217   <span class="comment">//if (part_rand_number) delete [] part_rand_number; part_rand_number = 0;</span>
<a name="l01218"></a>01218   <span class="comment">//if (exportVtxGIDs) delete [] exportVtxGIDs; exportVtxGIDs = 0;</span>
<a name="l01219"></a>01219   <span class="comment">//if (exportVtxLIDs) delete [] exportVtxLIDs; exportVtxLIDs = 0;</span>
<a name="l01220"></a>01220   <span class="comment">//if (exportProc) delete [] exportProc; exportProc = 0;</span>
<a name="l01221"></a>01221   <span class="comment">//if (in_independent_set) delete [] in_independent_set; in_independent_set = 0;</span>
<a name="l01222"></a>01222   <span class="comment">//if (vid_map) delete vid_map; vid_map = 0;</span>
<a name="l01223"></a>01223   <span class="comment">//if (neighbourProcSend) delete [] neighbourProcSend; neighbourProcSend = 0;</span>
<a name="l01224"></a>01224   <span class="comment">//if (neighbourProcRecv) delete [] neighbourProcRecv; neighbourProcRecv = 0;</span>
<a name="l01225"></a>01225   <span class="comment">//if (neighbourProcSendRemain) delete [] neighbourProcSendRemain; neighbourProcSendRemain = 0;</span>
<a name="l01226"></a>01226   <span class="comment">//if (neighbourProcRecvRemain) delete [] neighbourProcRecvRemain; neighbourProcRecvRemain = 0;</span>
<a name="l01227"></a>01227   <span class="comment">//if (vtx_off_proc_list_size) delete [] vtx_off_proc_list_size; vtx_off_proc_list_size = 0;</span>
<a name="l01228"></a>01228   <span class="comment">//if (vtx_off_proc_list) {</span>
<a name="l01229"></a>01229   <span class="comment">//  for (i = 0; i &lt; num_vtx_partition_boundary_local; i++) free(vtx_off_proc_list[i]);</span>
<a name="l01230"></a>01230   <span class="comment">//  delete [] vtx_off_proc_list; vtx_off_proc_list = 0;</span>
<a name="l01231"></a>01231   <span class="comment">//}</span>
<a name="l01232"></a>01232   <span class="comment">//if (neighbourProc) free(neighbourProc); neighbourProc = 0;</span>
<a name="l01233"></a>01233 }
<a name="l01234"></a>01234 
<a name="l01235"></a>01235 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="namespaceMesquite.html#57d4b3860b73386c6c87dd2ad6904cdd">VertexPack</a> {
<a name="l01236"></a>01236   <span class="keywordtype">double</span> x;
<a name="l01237"></a>01237   <span class="keywordtype">double</span> y;
<a name="l01238"></a>01238   <span class="keywordtype">double</span> z;
<a name="l01239"></a>01239   <span class="keyword">union </span>{
<a name="l01240"></a>01240     <span class="keywordtype">double</span> mist;
<a name="l01241"></a>01241     size_t glob_id;
<a name="l01242"></a>01242   };
<a name="l01243"></a>01243 } <a class="code" href="namespaceMesquite.html#57d4b3860b73386c6c87dd2ad6904cdd">VertexPack</a>;
<a name="l01244"></a>01244 
<a name="l01245"></a>01245 <span class="keywordtype">int</span> ParallelHelperImpl::comm_smoothed_vtx_tnb(MsqError&amp; err)
<a name="l01246"></a>01246 {
<a name="l01247"></a>01247   <span class="keywordtype">int</span> i,j,k, rval;
<a name="l01248"></a>01248 
<a name="l01249"></a>01249   <span class="comment">// printf("[%d]i%d truly non blocking\n",rank, iteration);fflush(NULL);</span>
<a name="l01250"></a>01250 
<a name="l01251"></a>01251   <span class="comment">/* compute how many vertices we send to each processor */</span>
<a name="l01252"></a>01252 
<a name="l01253"></a>01253   std::vector&lt;int&gt; numVtxPerProcSend(neighbourProc.size(), 0);
<a name="l01254"></a>01254   std::vector&lt;int&gt; numVtxPerProcRecv(neighbourProc.size(), 0);
<a name="l01255"></a>01255   <span class="keywordflow">for</span> (i = 0; i &lt; num_exportVtx; i++) {
<a name="l01256"></a>01256     <span class="keywordflow">for</span> (j = 0; j &lt; (long)neighbourProc.size(); j++) {
<a name="l01257"></a>01257       <span class="keywordflow">if</span> (exportProc[i] == neighbourProc[j]) {
<a name="l01258"></a>01258         <span class="comment">/* increment count */</span>
<a name="l01259"></a>01259         numVtxPerProcSend[j]++;
<a name="l01260"></a>01260         <span class="comment">/* end loop */</span>
<a name="l01261"></a>01261         <span class="keywordflow">break</span>;
<a name="l01262"></a>01262       }
<a name="l01263"></a>01263     }
<a name="l01264"></a>01264     <span class="comment">/* did loop end without finding the processor */</span>
<a name="l01265"></a>01265     <span class="keywordflow">if</span> (j == (<span class="keywordtype">long</span>)neighbourProc.size()) {
<a name="l01266"></a>01266       printf(<span class="stringliteral">"[%d]i%d WARNING: did not find exportProc[%d] = %d in list of %lu processors.\n"</span>,rank,iteration,i,exportProc[i],(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)neighbourProc.size());
<a name="l01267"></a>01267     }
<a name="l01268"></a>01268   }
<a name="l01269"></a>01269 
<a name="l01270"></a>01270   <span class="comment">/* tell each processor how many vertices they can expect from us */</span>
<a name="l01271"></a>01271   <span class="comment">/* also ask each processor how many vertices we can expect from them */</span>
<a name="l01272"></a>01272 
<a name="l01273"></a>01273   <span class="keywordtype">int</span> num_neighbourProcSend = 0;
<a name="l01274"></a>01274   <span class="keywordtype">int</span> num_neighbourProcRecv = 0;
<a name="l01275"></a>01275   std::vector&lt;MPI_Request&gt; requests_send(neighbourProc.size());
<a name="l01276"></a>01276   std::vector&lt;MPI_Request&gt; requests_recv(neighbourProc.size());
<a name="l01277"></a>01277   <span class="keywordflow">for</span> (j = 0; j &lt; (long)neighbourProc.size(); j++) {
<a name="l01278"></a>01278     <span class="comment">/* send the vertex count to this processor */</span>
<a name="l01279"></a>01279     <span class="keywordflow">if</span> (0) {printf(<span class="stringliteral">"[%d]i%d Announce send %d vertices from proc %d\n"</span>,rank,iteration,numVtxPerProcSend[j],neighbourProc[j]); fflush(NULL);}
<a name="l01280"></a>01280     rval = MPI_Isend(&amp;(numVtxPerProcSend[j]),
<a name="l01281"></a>01281               1,
<a name="l01282"></a>01282               MPI_INT,
<a name="l01283"></a>01283               neighbourProc[j],
<a name="l01284"></a>01284               <a class="code" href="ParallelHelper_8cpp.html#0b474ffa817926a5bbff5b51046fd45c">VERTEX_HEADER</a>+iteration,
<a name="l01285"></a>01285               (MPI_Comm)communicator,
<a name="l01286"></a>01286               &amp;(requests_send[j]));
<a name="l01287"></a>01287     <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l01288"></a>01288     num_neighbourProcSend++;
<a name="l01289"></a>01289 
<a name="l01290"></a>01290     <span class="comment">/* recv the vertex count for this processor */</span>
<a name="l01291"></a>01291     <span class="keywordflow">if</span> (0) {printf(<span class="stringliteral">"[%d]i%d Listen  recv %d vertices from proc %d\n"</span>,rank,iteration,numVtxPerProcRecv[j],neighbourProc[j]); fflush(NULL);}
<a name="l01292"></a>01292     rval = MPI_Irecv(&amp;(numVtxPerProcRecv[j]),
<a name="l01293"></a>01293              1,
<a name="l01294"></a>01294              MPI_INT,
<a name="l01295"></a>01295              neighbourProc[j],
<a name="l01296"></a>01296              <a class="code" href="ParallelHelper_8cpp.html#0b474ffa817926a5bbff5b51046fd45c">VERTEX_HEADER</a>+iteration,
<a name="l01297"></a>01297              (MPI_Comm)communicator,
<a name="l01298"></a>01298               &amp;(requests_recv[j]));
<a name="l01299"></a>01299     <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l01300"></a>01300     num_neighbourProcRecv++;
<a name="l01301"></a>01301   }
<a name="l01302"></a>01302 
<a name="l01303"></a>01303   <span class="comment">/* set up memory for the outgoing vertex data blocks */</span>
<a name="l01304"></a>01304 
<a name="l01305"></a>01305   std::vector&lt;VertexPack&gt; vertex_pack_export(num_exportVtx+10); <span class="comment">/* add 10 to have enough memory */</span>
<a name="l01306"></a>01306   std::vector&lt;VertexPack*&gt; packed_vertices_export(neighbourProc.size());
<a name="l01307"></a>01307   <span class="keywordflow">if</span> (neighbourProc.size())
<a name="l01308"></a>01308     packed_vertices_export[0] = <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(vertex_pack_export);
<a name="l01309"></a>01309   <span class="keywordflow">for</span> (i = 1; i &lt; (long)neighbourProc.size(); i++) {
<a name="l01310"></a>01310     packed_vertices_export[i] = packed_vertices_export[i-1] + numVtxPerProcSend[i-1];
<a name="l01311"></a>01311   }
<a name="l01312"></a>01312 
<a name="l01313"></a>01313   <span class="comment">/* place vertex data going to the same processor into consecutive memory space */</span>
<a name="l01314"></a>01314 
<a name="l01315"></a>01315   std::vector&lt;int&gt; numVtxPerProcSendPACKED(neighbourProc.size());
<a name="l01316"></a>01316   <span class="keywordflow">for</span> (i = 0; i &lt; (long)neighbourProc.size(); i++) {
<a name="l01317"></a>01317     numVtxPerProcSendPACKED[i] = 0;
<a name="l01318"></a>01318   }
<a name="l01319"></a>01319   <span class="keywordflow">for</span> (i = 0; i &lt; num_exportVtx; i++) {
<a name="l01320"></a>01320     <span class="keywordflow">for</span> (j = 0; j &lt; (long)neighbourProc.size(); j++) {
<a name="l01321"></a>01321       <span class="keywordflow">if</span> (exportProc[i] == neighbourProc[j]) {
<a name="l01322"></a>01322         <a class="code" href="namespaceMesquite.html#57d4b3860b73386c6c87dd2ad6904cdd">VertexPack</a>* packing_vertex = packed_vertices_export[j] + numVtxPerProcSendPACKED[j];
<a name="l01323"></a>01323         numVtxPerProcSendPACKED[j]++;
<a name="l01324"></a>01324         <a class="code" href="classMesquite_1_1MsqVertex.html">Mesquite::MsqVertex</a> coordinates;
<a name="l01325"></a>01325         mesh-&gt;vertices_get_coordinates(&amp;part_vertices[exportVtxLIDs[i]],&amp;coordinates,1,err);
<a name="l01326"></a>01326         <a class="code" href="group__error.html#g1d829e1f69c04186f0de4b50a99203c8">MSQ_ERRZERO</a>(err);
<a name="l01327"></a>01327         packing_vertex-&gt;x = coordinates[0];
<a name="l01328"></a>01328         packing_vertex-&gt;y = coordinates[1];
<a name="l01329"></a>01329         packing_vertex-&gt;z = coordinates[2];
<a name="l01330"></a>01330         packing_vertex-&gt;glob_id = exportVtxGIDs[i];
<a name="l01331"></a>01331       }
<a name="l01332"></a>01332     }
<a name="l01333"></a>01333   }
<a name="l01334"></a>01334 
<a name="l01335"></a>01335   <span class="comment">/* wait until we have heard from all processors how many vertices we will receive from them */</span>
<a name="l01336"></a>01336 
<a name="l01337"></a>01337   std::vector&lt;MPI_Status&gt; status(neighbourProc.size());
<a name="l01338"></a>01338 
<a name="l01339"></a>01339   <span class="keywordflow">if</span> (num_neighbourProcRecv) {
<a name="l01340"></a>01340     rval = MPI_Waitall(neighbourProc.size(), <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(requests_recv), <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(status));
<a name="l01341"></a>01341     <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l01342"></a>01342   }
<a name="l01343"></a>01343 
<a name="l01344"></a>01344   <span class="comment">/* how many vertices will we receive */</span>
<a name="l01345"></a>01345 
<a name="l01346"></a>01346   <span class="keywordtype">int</span> numVtxImport = 0;
<a name="l01347"></a>01347   <span class="keywordflow">for</span> (i = 0; i &lt; (long)neighbourProc.size(); i++) {
<a name="l01348"></a>01348     numVtxImport += numVtxPerProcRecv[i];
<a name="l01349"></a>01349   }
<a name="l01350"></a>01350 
<a name="l01351"></a>01351   <span class="comment">/* set up memory for the incoming vertex data blocks */</span>
<a name="l01352"></a>01352 
<a name="l01353"></a>01353   std::vector&lt;VertexPack&gt; vertex_pack_import(numVtxImport+10); <span class="comment">/* add 10 to have enough memory */</span>
<a name="l01354"></a>01354   std::vector&lt;VertexPack*&gt; packed_vertices_import(neighbourProc.size());
<a name="l01355"></a>01355   <span class="keywordflow">if</span> (neighbourProc.size())
<a name="l01356"></a>01356     packed_vertices_import[0] = <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(vertex_pack_import);
<a name="l01357"></a>01357   <span class="keywordflow">for</span> (i = 1; i &lt; (long)neighbourProc.size(); i++) {
<a name="l01358"></a>01358     packed_vertices_import[i] = packed_vertices_import[i-1] + numVtxPerProcRecv[i-1];
<a name="l01359"></a>01359   }
<a name="l01360"></a>01360 
<a name="l01361"></a>01361   <span class="comment">/* post receives for all processors that have something for us */</span>
<a name="l01362"></a>01362   <span class="comment">/* post sends for all processors that we have something for */</span>
<a name="l01363"></a>01363 
<a name="l01364"></a>01364   num_neighbourProcRecv = 0;
<a name="l01365"></a>01365 
<a name="l01366"></a>01366   <span class="keywordflow">for</span> (i = 0; i &lt; (long)neighbourProc.size(); i++) {
<a name="l01367"></a>01367     <span class="keywordflow">if</span> (numVtxPerProcRecv[i]) {
<a name="l01368"></a>01368       <span class="keywordflow">if</span> (0) {printf(<span class="stringliteral">"[%d]i%d Will recv %d vertices from proc %d\n"</span>,rank,iteration,numVtxPerProcRecv[i],neighbourProc[i]); fflush(NULL);}
<a name="l01369"></a>01369       rval = MPI_Irecv(packed_vertices_import[i],
<a name="l01370"></a>01370                 4*numVtxPerProcRecv[i],
<a name="l01371"></a>01371                 MPI_DOUBLE_PRECISION,
<a name="l01372"></a>01372                 neighbourProc[i],
<a name="l01373"></a>01373                 <a class="code" href="ParallelHelper_8cpp.html#c5eb83026ccd0c22f641e74d3e19ff4a">VERTEX_BLOCK</a>+iteration,
<a name="l01374"></a>01374                 (MPI_Comm)communicator,
<a name="l01375"></a>01375                 &amp;(requests_recv[i]));
<a name="l01376"></a>01376       <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l01377"></a>01377       num_neighbourProcRecv++;
<a name="l01378"></a>01378     }
<a name="l01379"></a>01379     <span class="keywordflow">else</span> {
<a name="l01380"></a>01380       requests_recv[i] = MPI_REQUEST_NULL;
<a name="l01381"></a>01381     }
<a name="l01382"></a>01382     <span class="keywordflow">if</span> (numVtxPerProcSend[i]) {
<a name="l01383"></a>01383       <span class="keywordflow">if</span> (0) {printf(<span class="stringliteral">"[%d]i%d Will send %d vertices to proc %d\n"</span>,rank,iteration,numVtxPerProcSend[i],neighbourProc[i]); fflush(NULL);}
<a name="l01384"></a>01384       rval = MPI_Isend(packed_vertices_export[i], 
<a name="l01385"></a>01385                 4*numVtxPerProcSend[i],
<a name="l01386"></a>01386                 MPI_DOUBLE_PRECISION,
<a name="l01387"></a>01387                 neighbourProc[i],
<a name="l01388"></a>01388                 <a class="code" href="ParallelHelper_8cpp.html#c5eb83026ccd0c22f641e74d3e19ff4a">VERTEX_BLOCK</a>+iteration,
<a name="l01389"></a>01389                 (MPI_Comm)communicator,
<a name="l01390"></a>01390                 &amp;(requests_send[i]));
<a name="l01391"></a>01391       <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l01392"></a>01392     }
<a name="l01393"></a>01393     <span class="keywordflow">else</span> {
<a name="l01394"></a>01394       requests_send[i] = MPI_REQUEST_NULL;
<a name="l01395"></a>01395     }
<a name="l01396"></a>01396   }
<a name="l01397"></a>01397 
<a name="l01398"></a>01398   <span class="comment">/* wait for some receive to arrive */</span> 
<a name="l01399"></a>01399   
<a name="l01400"></a>01400   <span class="keywordtype">int</span> local_id;
<a name="l01401"></a>01401   <span class="keywordflow">while</span> (num_neighbourProcRecv) {
<a name="l01402"></a>01402     rval = MPI_Waitany(neighbourProc.size(), <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(requests_recv), &amp;k, <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(status));
<a name="l01403"></a>01403     <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l01404"></a>01404     <span class="comment">/* unpack all vertices */</span>
<a name="l01405"></a>01405     <span class="keywordflow">for</span> (i = 0; i &lt; numVtxPerProcRecv[k]; i++) {
<a name="l01406"></a>01406       local_id = vertex_map_find(vid_map,packed_vertices_import[k][i].glob_id, neighbourProc[k]);
<a name="l01407"></a>01407       <span class="keywordflow">if</span> (local_id) {
<a name="l01408"></a>01408         <a class="code" href="classMesquite_1_1Vector3D.html">Mesquite::Vector3D</a> coordinates;
<a name="l01409"></a>01409         coordinates.set(packed_vertices_import[k][i].x, packed_vertices_import[k][i].y, packed_vertices_import[k][i].z);
<a name="l01410"></a>01410         mesh-&gt;vertex_set_coordinates(part_vertices[local_id],coordinates,err);<a class="code" href="group__error.html#g1d829e1f69c04186f0de4b50a99203c8">MSQ_ERRZERO</a>(err);
<a name="l01411"></a>01411         assert(part_smoothed_flag[local_id] == 0);
<a name="l01412"></a>01412         part_smoothed_flag[local_id] = 1;
<a name="l01413"></a>01413       }
<a name="l01414"></a>01414       <span class="keywordflow">else</span> {
<a name="l01415"></a>01415         printf(<span class="stringliteral">"[%d]i%d vertex with gid %Zu and pid %d not in map\n"</span>,rank,iteration,packed_vertices_import[k][i].glob_id,neighbourProc[k]);
<a name="l01416"></a>01416       }
<a name="l01417"></a>01417     }
<a name="l01418"></a>01418     num_neighbourProcRecv--;
<a name="l01419"></a>01419   }
<a name="l01420"></a>01420 
<a name="l01421"></a>01421   <span class="comment">/* all receives have completed. it is save to release the memory */</span>
<a name="l01422"></a>01422   <span class="comment">//free(vertex_pack_import);</span>
<a name="l01423"></a>01423 
<a name="l01424"></a>01424   <span class="comment">/* wait until the sends have completed */</span>
<a name="l01425"></a>01425 
<a name="l01426"></a>01426   <span class="keywordflow">if</span> (num_neighbourProcSend) {
<a name="l01427"></a>01427     rval = MPI_Waitall(neighbourProc.size(), <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(requests_send), <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(status));
<a name="l01428"></a>01428     <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l01429"></a>01429   }
<a name="l01430"></a>01430 
<a name="l01431"></a>01431   <span class="comment">/* all sends have completed. it is save to release the memory */</span>
<a name="l01432"></a>01432   <span class="comment">//free(vertex_pack_export);</span>
<a name="l01433"></a>01433 
<a name="l01434"></a>01434   <span class="keywordflow">return</span> numVtxImport;
<a name="l01435"></a>01435 }
<a name="l01436"></a>01436 
<a name="l01437"></a>01437 <span class="keywordtype">int</span> ParallelHelperImpl::comm_smoothed_vtx_tnb_no_all( MsqError&amp; err )
<a name="l01438"></a>01438 {
<a name="l01439"></a>01439   <span class="keywordtype">int</span> i,j,k, rval;
<a name="l01440"></a>01440 
<a name="l01441"></a>01441   <span class="comment">// printf("[%d]i%d truly non blocking avoid reduce all\n", rank, iteration); fflush(NULL);</span>
<a name="l01442"></a>01442 
<a name="l01443"></a>01443   <span class="comment">/* compute how many vertices we send to each processor */</span>
<a name="l01444"></a>01444 
<a name="l01445"></a>01445   std::vector&lt;int&gt; numVtxPerProcSend(neighbourProc.size(), 0);
<a name="l01446"></a>01446   std::vector&lt;int&gt; numVtxPerProcRecv(neighbourProc.size(), 0);
<a name="l01447"></a>01447   <span class="keywordflow">for</span> (i = 0; i &lt; num_exportVtx; i++) {
<a name="l01448"></a>01448     <span class="keywordflow">for</span> (j = 0; j &lt; (long)neighbourProc.size(); j++) {
<a name="l01449"></a>01449       <span class="keywordflow">if</span> (exportProc[i] == neighbourProc[j]) {
<a name="l01450"></a>01450         <span class="comment">/* increment count */</span>
<a name="l01451"></a>01451         numVtxPerProcSend[j]++;
<a name="l01452"></a>01452         <span class="comment">/* end loop */</span>
<a name="l01453"></a>01453         <span class="keywordflow">break</span>;
<a name="l01454"></a>01454       }
<a name="l01455"></a>01455     }
<a name="l01456"></a>01456     <span class="comment">/* did loop end without finding the processor */</span>
<a name="l01457"></a>01457     <span class="keywordflow">if</span> (j == (<span class="keywordtype">long</span>)neighbourProc.size()) {
<a name="l01458"></a>01458       printf(<span class="stringliteral">"[%d]i%d WARNING: did not find exportProc[%d] = %d in list of %lu processors.\n"</span>,rank,iteration,i,exportProc[i],(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)neighbourProc.size());
<a name="l01459"></a>01459     }
<a name="l01460"></a>01460   }
<a name="l01461"></a>01461 
<a name="l01462"></a>01462   <span class="comment">/* tell each processor how many vertices they can expect from us */</span>
<a name="l01463"></a>01463   <span class="comment">/* also ask each processor how many vertices we can expect from them */</span>
<a name="l01464"></a>01464 
<a name="l01465"></a>01465   <span class="keywordtype">int</span> num_neighbourProcSend = 0;
<a name="l01466"></a>01466   <span class="keywordtype">int</span> num_neighbourProcRecv = 0;
<a name="l01467"></a>01467   std::vector&lt;MPI_Request&gt; requests_send(neighbourProc.size());
<a name="l01468"></a>01468   std::vector&lt;MPI_Request&gt; requests_recv(neighbourProc.size());
<a name="l01469"></a>01469   <span class="keywordflow">for</span> (j = 0; j &lt; (long)neighbourProc.size(); j++) {
<a name="l01470"></a>01470     <span class="keywordflow">if</span> (neighbourProcSendRemain[j]) {
<a name="l01471"></a>01471       <span class="comment">/* send the vertex count to this processor */</span>
<a name="l01472"></a>01472       <span class="keywordflow">if</span> (0) {printf(<span class="stringliteral">"[%d]i%d Announce send %d vertices to proc %d\n"</span>,rank,iteration,numVtxPerProcSend[j],neighbourProc[j]); fflush(NULL);}
<a name="l01473"></a>01473       rval = MPI_Isend(&amp;(numVtxPerProcSend[j]),
<a name="l01474"></a>01474                 1,
<a name="l01475"></a>01475                 MPI_INT,
<a name="l01476"></a>01476                 neighbourProc[j],
<a name="l01477"></a>01477                 <a class="code" href="ParallelHelper_8cpp.html#0b474ffa817926a5bbff5b51046fd45c">VERTEX_HEADER</a>+iteration,
<a name="l01478"></a>01478                 (MPI_Comm)communicator,
<a name="l01479"></a>01479                 &amp;(requests_send[j]));
<a name="l01480"></a>01480       <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l01481"></a>01481       num_neighbourProcSend++;
<a name="l01482"></a>01482     } <span class="keywordflow">else</span> {
<a name="l01483"></a>01483       requests_send[j] = MPI_REQUEST_NULL;
<a name="l01484"></a>01484     }
<a name="l01485"></a>01485     <span class="keywordflow">if</span> (neighbourProcRecvRemain[j]) {
<a name="l01486"></a>01486       <span class="comment">/* recv the vertex count for this processor */</span>
<a name="l01487"></a>01487       <span class="keywordflow">if</span> (0) {printf(<span class="stringliteral">"[%d]i%d Listen recv xx vertices from proc %d\n"</span>,rank,iteration,neighbourProc[j]); fflush(NULL);}
<a name="l01488"></a>01488       rval = MPI_Irecv(&amp;(numVtxPerProcRecv[j]),
<a name="l01489"></a>01489                 1,
<a name="l01490"></a>01490                 MPI_INT,
<a name="l01491"></a>01491                 neighbourProc[j],
<a name="l01492"></a>01492                 <a class="code" href="ParallelHelper_8cpp.html#0b474ffa817926a5bbff5b51046fd45c">VERTEX_HEADER</a>+iteration,
<a name="l01493"></a>01493                 (MPI_Comm)communicator,
<a name="l01494"></a>01494                 &amp;(requests_recv[j]));
<a name="l01495"></a>01495       <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l01496"></a>01496       num_neighbourProcRecv++;
<a name="l01497"></a>01497     } <span class="keywordflow">else</span> {
<a name="l01498"></a>01498       requests_recv[j] = MPI_REQUEST_NULL;
<a name="l01499"></a>01499     }
<a name="l01500"></a>01500   }
<a name="l01501"></a>01501 
<a name="l01502"></a>01502   <span class="comment">/* set up memory for the outgoing vertex data blocks */</span>
<a name="l01503"></a>01503 
<a name="l01504"></a>01504   std::vector&lt;VertexPack&gt; vertex_pack_export(num_exportVtx+10); <span class="comment">/* add 10 to have enough memory */</span>
<a name="l01505"></a>01505   std::vector&lt;VertexPack*&gt; packed_vertices_export(neighbourProc.size());
<a name="l01506"></a>01506   <span class="keywordflow">if</span> (neighbourProc.size())
<a name="l01507"></a>01507     packed_vertices_export[0] = <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(vertex_pack_export);
<a name="l01508"></a>01508   <span class="keywordflow">for</span> (i = 1; i &lt; (long)neighbourProc.size(); i++) {
<a name="l01509"></a>01509     packed_vertices_export[i] = packed_vertices_export[i-1] + numVtxPerProcSend[i-1];
<a name="l01510"></a>01510   }
<a name="l01511"></a>01511 
<a name="l01512"></a>01512   <span class="comment">/* place vertex data going to the same processor into consecutive memory space */</span>
<a name="l01513"></a>01513 
<a name="l01514"></a>01514   std::vector&lt;int&gt; numVtxPerProcSendPACKED(neighbourProc.size(),0);
<a name="l01515"></a>01515   <span class="keywordflow">for</span> (i = 0; i &lt; num_exportVtx; i++) {
<a name="l01516"></a>01516     <span class="keywordflow">for</span> (j = 0; j &lt; (long)neighbourProc.size(); j++) {
<a name="l01517"></a>01517       <span class="keywordflow">if</span> (exportProc[i] == neighbourProc[j]) {
<a name="l01518"></a>01518         <a class="code" href="namespaceMesquite.html#57d4b3860b73386c6c87dd2ad6904cdd">VertexPack</a>* packing_vertex = packed_vertices_export[j] + numVtxPerProcSendPACKED[j];
<a name="l01519"></a>01519         numVtxPerProcSendPACKED[j]++;
<a name="l01520"></a>01520         <a class="code" href="classMesquite_1_1MsqVertex.html">Mesquite::MsqVertex</a> coordinates;
<a name="l01521"></a>01521         mesh-&gt;vertices_get_coordinates(&amp;part_vertices[exportVtxLIDs[i]],&amp;coordinates,1,err); 
<a name="l01522"></a>01522         <a class="code" href="group__error.html#g1d829e1f69c04186f0de4b50a99203c8">MSQ_ERRZERO</a>(err);
<a name="l01523"></a>01523         packing_vertex-&gt;x = coordinates[0];
<a name="l01524"></a>01524         packing_vertex-&gt;y = coordinates[1];
<a name="l01525"></a>01525         packing_vertex-&gt;z = coordinates[2];
<a name="l01526"></a>01526         packing_vertex-&gt;glob_id = exportVtxGIDs[i];
<a name="l01527"></a>01527         <span class="keywordflow">if</span> (0) printf(<span class="stringliteral">"[%d]i%d vertex %lu packed %g %g %g\n"</span>, rank,iteration,(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)exportVtxGIDs[i],packing_vertex-&gt;x, packing_vertex-&gt;y, packing_vertex-&gt;z);
<a name="l01528"></a>01528       }
<a name="l01529"></a>01529     }
<a name="l01530"></a>01530   }
<a name="l01531"></a>01531 
<a name="l01532"></a>01532   <span class="comment">/* wait until we have heard from all processors how many vertices we will receive from them */</span>
<a name="l01533"></a>01533 
<a name="l01534"></a>01534   std::vector&lt;MPI_Status&gt; status(neighbourProc.size());
<a name="l01535"></a>01535 
<a name="l01536"></a>01536   <span class="keywordflow">if</span> (num_neighbourProcRecv) {
<a name="l01537"></a>01537     rval = MPI_Waitall(neighbourProc.size(), <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(requests_recv), <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(status));
<a name="l01538"></a>01538     <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l01539"></a>01539   }
<a name="l01540"></a>01540 
<a name="l01541"></a>01541   <span class="comment">/* how many vertices will we receive */</span>
<a name="l01542"></a>01542 
<a name="l01543"></a>01543   <span class="keywordtype">int</span> numVtxImport = 0;
<a name="l01544"></a>01544   <span class="keywordflow">for</span> (i = 0; i &lt; (long)neighbourProc.size(); i++) {
<a name="l01545"></a>01545     numVtxImport += numVtxPerProcRecv[i];
<a name="l01546"></a>01546     neighbourProcRecvRemain[i] -= numVtxPerProcRecv[i];
<a name="l01547"></a>01547     neighbourProcSendRemain[i] -= numVtxPerProcSend[i];
<a name="l01548"></a>01548   }
<a name="l01549"></a>01549 
<a name="l01550"></a>01550   <span class="comment">/* set up memory for the incoming vertex data blocks */</span>
<a name="l01551"></a>01551 
<a name="l01552"></a>01552   std::vector&lt;VertexPack&gt; vertex_pack_import(numVtxImport+10); <span class="comment">/* add 10 to have enough memory */</span>
<a name="l01553"></a>01553   std::vector&lt;VertexPack*&gt; packed_vertices_import(neighbourProc.size());
<a name="l01554"></a>01554   <span class="keywordflow">if</span> (neighbourProc.size())
<a name="l01555"></a>01555     packed_vertices_import[0] = <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(vertex_pack_import);
<a name="l01556"></a>01556   <span class="keywordflow">for</span> (i = 1; i &lt; (long)neighbourProc.size(); i++) {
<a name="l01557"></a>01557     packed_vertices_import[i] = packed_vertices_import[i-1] + numVtxPerProcRecv[i-1];
<a name="l01558"></a>01558   }
<a name="l01559"></a>01559 
<a name="l01560"></a>01560   <span class="comment">/* post receives for all processors that have something for us */</span>
<a name="l01561"></a>01561   <span class="comment">/* post sends for all processors that we have something for */</span>
<a name="l01562"></a>01562 
<a name="l01563"></a>01563   num_neighbourProcRecv = 0;
<a name="l01564"></a>01564 
<a name="l01565"></a>01565   <span class="keywordflow">for</span> (i = 0; i &lt; (long)neighbourProc.size(); i++) {
<a name="l01566"></a>01566     <span class="keywordflow">if</span> (0) {printf(<span class="stringliteral">"[%d]i%d Will recv %d vertices from proc %d\n"</span>,rank,iteration,numVtxPerProcRecv[i],neighbourProc[i]); fflush(NULL);}
<a name="l01567"></a>01567     <span class="keywordflow">if</span> (numVtxPerProcRecv[i]) {
<a name="l01568"></a>01568       rval = MPI_Irecv(packed_vertices_import[i],
<a name="l01569"></a>01569                 4*numVtxPerProcRecv[i],
<a name="l01570"></a>01570                 MPI_DOUBLE_PRECISION,
<a name="l01571"></a>01571                 neighbourProc[i],
<a name="l01572"></a>01572                 <a class="code" href="ParallelHelper_8cpp.html#c5eb83026ccd0c22f641e74d3e19ff4a">VERTEX_BLOCK</a>+iteration,
<a name="l01573"></a>01573                 (MPI_Comm)communicator,
<a name="l01574"></a>01574                 &amp;(requests_recv[i]));
<a name="l01575"></a>01575       <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l01576"></a>01576       num_neighbourProcRecv++;
<a name="l01577"></a>01577     }
<a name="l01578"></a>01578     <span class="keywordflow">else</span> {
<a name="l01579"></a>01579       requests_recv[i] = MPI_REQUEST_NULL;
<a name="l01580"></a>01580     }
<a name="l01581"></a>01581     <span class="keywordflow">if</span> (0) {printf(<span class="stringliteral">"[%d]i%d Will send %d vertices to proc %d\n"</span>,rank,iteration,numVtxPerProcSend[i],neighbourProc[i]); fflush(NULL);}
<a name="l01582"></a>01582     <span class="keywordflow">if</span> (numVtxPerProcSend[i]) {
<a name="l01583"></a>01583       rval = MPI_Isend(packed_vertices_export[i], 
<a name="l01584"></a>01584                 4*numVtxPerProcSend[i],
<a name="l01585"></a>01585                 MPI_DOUBLE_PRECISION,
<a name="l01586"></a>01586                 neighbourProc[i],
<a name="l01587"></a>01587                 <a class="code" href="ParallelHelper_8cpp.html#c5eb83026ccd0c22f641e74d3e19ff4a">VERTEX_BLOCK</a>+iteration,
<a name="l01588"></a>01588                 (MPI_Comm)communicator,
<a name="l01589"></a>01589                 &amp;(requests_send[i]));
<a name="l01590"></a>01590       <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l01591"></a>01591     }
<a name="l01592"></a>01592     <span class="keywordflow">else</span> {
<a name="l01593"></a>01593       requests_send[i] = MPI_REQUEST_NULL;
<a name="l01594"></a>01594     }
<a name="l01595"></a>01595   }
<a name="l01596"></a>01596 
<a name="l01597"></a>01597   <span class="comment">/* wait for some receive to arrive */</span> 
<a name="l01598"></a>01598   
<a name="l01599"></a>01599   <span class="keywordtype">int</span> local_id;
<a name="l01600"></a>01600   <span class="keywordflow">while</span> (num_neighbourProcRecv) {
<a name="l01601"></a>01601     rval = MPI_Waitany(neighbourProc.size(), <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(requests_recv), &amp;k, <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(status));
<a name="l01602"></a>01602     <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l01603"></a>01603     <span class="comment">/* unpack all vertices */</span>
<a name="l01604"></a>01604     <span class="keywordflow">for</span> (i = 0; i &lt; numVtxPerProcRecv[k]; i++) {
<a name="l01605"></a>01605       local_id = vertex_map_find(vid_map,packed_vertices_import[k][i].glob_id, neighbourProc[k]);
<a name="l01606"></a>01606       <span class="keywordflow">if</span> (local_id) {
<a name="l01607"></a>01607         <a class="code" href="classMesquite_1_1Vector3D.html">Mesquite::Vector3D</a> coordinates;
<a name="l01608"></a>01608         coordinates.<a class="code" href="classMesquite_1_1Vector3D.html#afd16f85e6d2ea346f8dbda034b61b85">set</a>(packed_vertices_import[k][i].x, packed_vertices_import[k][i].y, packed_vertices_import[k][i].z);
<a name="l01609"></a>01609         <span class="keywordflow">if</span> (0) printf(<span class="stringliteral">"[%d]i%d vertex %d becomes %g %g %g\n"</span>, rank,iteration,local_id,packed_vertices_import[k][i].x, packed_vertices_import[k][i].y, packed_vertices_import[k][i].z);
<a name="l01610"></a>01610         mesh-&gt;vertex_set_coordinates(part_vertices[local_id],coordinates,err); <a class="code" href="group__error.html#g1d829e1f69c04186f0de4b50a99203c8">MSQ_ERRZERO</a>(err);
<a name="l01611"></a>01611         assert(part_smoothed_flag[local_id] == 0);
<a name="l01612"></a>01612         part_smoothed_flag[local_id] = 1;
<a name="l01613"></a>01613       }
<a name="l01614"></a>01614       <span class="keywordflow">else</span> {
<a name="l01615"></a>01615         printf(<span class="stringliteral">"[%d]i%d vertex with gid %Zu and pid %d not in map\n"</span>,rank,iteration,packed_vertices_import[k][i].glob_id,neighbourProc[k]);
<a name="l01616"></a>01616       }
<a name="l01617"></a>01617     }
<a name="l01618"></a>01618     num_neighbourProcRecv--;
<a name="l01619"></a>01619   }
<a name="l01620"></a>01620 
<a name="l01621"></a>01621   <span class="comment">/* all receives have completed. it is save to release the memory */</span>
<a name="l01622"></a>01622   <span class="comment">//free(vertex_pack_import);</span>
<a name="l01623"></a>01623 
<a name="l01624"></a>01624   <span class="comment">/* wait until the sends have completed */</span>
<a name="l01625"></a>01625 
<a name="l01626"></a>01626   <span class="keywordflow">if</span> (num_neighbourProcSend) {
<a name="l01627"></a>01627     rval = MPI_Waitall(neighbourProc.size(), <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(requests_send), <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(status));
<a name="l01628"></a>01628     <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l01629"></a>01629   }
<a name="l01630"></a>01630 
<a name="l01631"></a>01631   <span class="comment">/* all sends have completed. it is save to release the memory */</span>
<a name="l01632"></a>01632   <span class="comment">//free(vertex_pack_export);</span>
<a name="l01633"></a>01633 
<a name="l01634"></a>01634   <span class="keywordflow">return</span> numVtxImport;
<a name="l01635"></a>01635 }
<a name="l01636"></a>01636 
<a name="l01637"></a>01637 <span class="keywordtype">int</span> ParallelHelperImpl::comm_smoothed_vtx_nb(MsqError&amp; err)
<a name="l01638"></a>01638 {
<a name="l01639"></a>01639   <span class="keywordtype">int</span> i,j,k, rval;
<a name="l01640"></a>01640 
<a name="l01641"></a>01641   <span class="comment">// printf("[%d] %d %d non blocking\n",rank, iteration, pass);fflush(NULL);</span>
<a name="l01642"></a>01642 
<a name="l01643"></a>01643   <span class="comment">/* how many vertices will we receive */</span>
<a name="l01644"></a>01644 
<a name="l01645"></a>01645   std::vector&lt;int&gt; numVtxPerProcSend(neighbourProc.size());
<a name="l01646"></a>01646   <span class="keywordflow">for</span> (i = 0; i &lt; (long)neighbourProc.size(); i++) {
<a name="l01647"></a>01647     numVtxPerProcSend[i] = 0;
<a name="l01648"></a>01648   }
<a name="l01649"></a>01649   <span class="keywordflow">for</span> (i = 0; i &lt; num_exportVtx; i++) {
<a name="l01650"></a>01650     <span class="keywordflow">for</span> (j = 0; j &lt; (long)neighbourProc.size(); j++) {
<a name="l01651"></a>01651       <span class="keywordflow">if</span> (exportProc[i] == neighbourProc[j]) {
<a name="l01652"></a>01652         <span class="comment">/* increment count */</span>
<a name="l01653"></a>01653         numVtxPerProcSend[j]++;
<a name="l01654"></a>01654         <span class="comment">/* end loop */</span>
<a name="l01655"></a>01655         <span class="keywordflow">break</span>;
<a name="l01656"></a>01656       }
<a name="l01657"></a>01657     }
<a name="l01658"></a>01658     <span class="comment">/* assert loop did not end without finding processor */</span>
<a name="l01659"></a>01659     assert(j != (<span class="keywordtype">long</span>)neighbourProc.size());
<a name="l01660"></a>01660   }
<a name="l01661"></a>01661 
<a name="l01662"></a>01662   <span class="comment">/* tell each processor how many vertices to expect */</span>
<a name="l01663"></a>01663 
<a name="l01664"></a>01664   <span class="keywordflow">for</span> (j = 0; j &lt; (long)neighbourProc.size(); j++) {
<a name="l01665"></a>01665     rval = MPI_Send(&amp;(numVtxPerProcSend[j]),
<a name="l01666"></a>01666              1,
<a name="l01667"></a>01667              MPI_INT,
<a name="l01668"></a>01668              neighbourProc[j],
<a name="l01669"></a>01669              <a class="code" href="ParallelHelper_8cpp.html#0b474ffa817926a5bbff5b51046fd45c">VERTEX_HEADER</a>+iteration,
<a name="l01670"></a>01670              (MPI_Comm)communicator);
<a name="l01671"></a>01671     <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l01672"></a>01672     <span class="comment">//    printf("[%d]i%d Announcing %d vertices to proc %d\n",rank,iteration,numVtxPerProcSend[j],neighbourProc[j]); fflush(NULL);</span>
<a name="l01673"></a>01673   }
<a name="l01674"></a>01674 
<a name="l01675"></a>01675   <span class="comment">/* place vertex data going to the same processor into consecutive memory space */</span>
<a name="l01676"></a>01676   std::vector&lt;VertexPack&gt; vertex_pack_export(num_exportVtx+10); <span class="comment">/* add 10 to have enough memory */</span>
<a name="l01677"></a>01677   std::vector&lt;VertexPack*&gt; packed_vertices_export(neighbourProc.size());
<a name="l01678"></a>01678   <span class="keywordflow">if</span> (neighbourProc.size())
<a name="l01679"></a>01679     packed_vertices_export[0] = <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(vertex_pack_export);
<a name="l01680"></a>01680   <span class="keywordflow">for</span> (i = 1; i &lt; (long)neighbourProc.size(); i++) {
<a name="l01681"></a>01681     packed_vertices_export[i] = packed_vertices_export[i-1] + numVtxPerProcSend[i-1];
<a name="l01682"></a>01682   }
<a name="l01683"></a>01683 
<a name="l01684"></a>01684   std::vector&lt;int&gt; numVtxPerProcSendPACKED(neighbourProc.size(),0);
<a name="l01685"></a>01685   <span class="keywordflow">for</span> (i = 0; i &lt; num_exportVtx; i++) {
<a name="l01686"></a>01686     <span class="keywordflow">for</span> (j = 0; j &lt; (long)neighbourProc.size(); j++) {
<a name="l01687"></a>01687       <span class="keywordflow">if</span> (exportProc[i] == neighbourProc[j]) {
<a name="l01688"></a>01688         <a class="code" href="namespaceMesquite.html#57d4b3860b73386c6c87dd2ad6904cdd">VertexPack</a>* packing_vertex = packed_vertices_export[j] + numVtxPerProcSendPACKED[j];
<a name="l01689"></a>01689         numVtxPerProcSendPACKED[j]++;
<a name="l01690"></a>01690         <a class="code" href="classMesquite_1_1MsqVertex.html">Mesquite::MsqVertex</a> coordinates;
<a name="l01691"></a>01691         mesh-&gt;vertices_get_coordinates(&amp;part_vertices[exportVtxLIDs[i]],&amp;coordinates,1,err);
<a name="l01692"></a>01692         <a class="code" href="group__error.html#g1d829e1f69c04186f0de4b50a99203c8">MSQ_ERRZERO</a>(err);
<a name="l01693"></a>01693         packing_vertex-&gt;x = coordinates[0];
<a name="l01694"></a>01694         packing_vertex-&gt;y = coordinates[1];
<a name="l01695"></a>01695         packing_vertex-&gt;z = coordinates[2];
<a name="l01696"></a>01696         packing_vertex-&gt;glob_id = exportVtxGIDs[i];
<a name="l01697"></a>01697       }
<a name="l01698"></a>01698     }
<a name="l01699"></a>01699   }
<a name="l01700"></a>01700   <span class="comment">//delete [] numVtxPerProcSendPACKED;</span>
<a name="l01701"></a>01701 
<a name="l01702"></a>01702   <span class="comment">/* now ask each processor how many vertices to expect */</span>
<a name="l01703"></a>01703 
<a name="l01704"></a>01704   <span class="keywordtype">int</span> num;
<a name="l01705"></a>01705   <span class="keywordtype">int</span> proc;
<a name="l01706"></a>01706   <span class="keywordtype">int</span> numVtxImport = 0;
<a name="l01707"></a>01707   <span class="keywordtype">int</span> num_neighbourProcRecv = 0;
<a name="l01708"></a>01708   std::vector&lt;int&gt; numVtxPerProcRecv(neighbourProc.size());
<a name="l01709"></a>01709   MPI_Status status;
<a name="l01710"></a>01710   <span class="keywordflow">for</span> (j = 0; j &lt; (long)neighbourProc.size(); j++) {
<a name="l01711"></a>01711     numVtxPerProcRecv[j] = 0;
<a name="l01712"></a>01712   }
<a name="l01713"></a>01713 
<a name="l01714"></a>01714   <span class="keywordflow">for</span> (j = 0; j &lt; (long)neighbourProc.size(); j++) {
<a name="l01715"></a>01715     <span class="comment">/* get the vertex count for some processor */</span>
<a name="l01716"></a>01716     rval = MPI_Recv(&amp;num,              <span class="comment">/* message buffer */</span>
<a name="l01717"></a>01717              1,                 <span class="comment">/* one data item */</span>
<a name="l01718"></a>01718              MPI_INT,           <span class="comment">/* of type int */</span>
<a name="l01719"></a>01719              MPI_ANY_SOURCE,    <span class="comment">/* receive from any sender */</span>
<a name="l01720"></a>01720              <a class="code" href="ParallelHelper_8cpp.html#0b474ffa817926a5bbff5b51046fd45c">VERTEX_HEADER</a>+iteration,     <span class="comment">/* receive only VERTEX HEADERs from this iteration */</span>
<a name="l01721"></a>01721              (MPI_Comm)communicator,    <span class="comment">/* default communicator */</span>
<a name="l01722"></a>01722              &amp;status);          <span class="comment">/* info about the received message */</span>
<a name="l01723"></a>01723     <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l01724"></a>01724     proc = status.MPI_SOURCE;
<a name="l01725"></a>01725     <span class="comment">/* will we import vertices from this processor */</span>
<a name="l01726"></a>01726 
<a name="l01727"></a>01727     <span class="comment">//    printf("[%d]i%d Heard we will receive %d vertices from proc %d\n",rank,iteration,num,proc); fflush(NULL);</span>
<a name="l01728"></a>01728 
<a name="l01729"></a>01729     <span class="keywordflow">if</span> (num) {
<a name="l01730"></a>01730       <span class="comment">/* increase number of processors we will receive from */</span>
<a name="l01731"></a>01731       num_neighbourProcRecv++;
<a name="l01732"></a>01732       <span class="comment">/* add number of vertices we will receive to the import total */</span>
<a name="l01733"></a>01733       numVtxImport += num;
<a name="l01734"></a>01734     }
<a name="l01735"></a>01735     <span class="comment">/* find this processor in the list */</span>
<a name="l01736"></a>01736     <span class="keywordflow">for</span> (i = 0; i &lt; (long)neighbourProc.size(); i++) {
<a name="l01737"></a>01737       <span class="keywordflow">if</span> (neighbourProc[i] == proc) {
<a name="l01738"></a>01738         numVtxPerProcRecv[i] = num;
<a name="l01739"></a>01739         <span class="keywordflow">break</span>;
<a name="l01740"></a>01740       }
<a name="l01741"></a>01741     }
<a name="l01742"></a>01742     <span class="comment">/* assert loop did not end without finding processor */</span>
<a name="l01743"></a>01743     assert(i != (<span class="keywordtype">long</span>)neighbourProc.size());
<a name="l01744"></a>01744     <span class="keywordflow">if</span> (0) printf(<span class="stringliteral">"[%d]i%d Will receive %d vertices from proc %d\n"</span>,rank,iteration,num,proc); fflush(NULL);
<a name="l01745"></a>01745   }
<a name="l01746"></a>01746 
<a name="l01747"></a>01747   <span class="comment">/* create list of processors we receive from */</span>
<a name="l01748"></a>01748   std::vector&lt;int&gt; neighbourProcRecv(num_neighbourProcRecv);
<a name="l01749"></a>01749   std::vector&lt;int&gt; numVtxPerProcRecvRecv(num_neighbourProcRecv);
<a name="l01750"></a>01750   <span class="keywordflow">for</span> (i = 0, k = 0; i &lt; (long)neighbourProc.size(); i++) {
<a name="l01751"></a>01751     <span class="keywordflow">if</span> (0) printf(<span class="stringliteral">"[%d]i%d Will receive %d vertices from proc %d\n"</span>,rank,iteration,numVtxPerProcRecv[i],neighbourProc[i]); fflush(NULL);
<a name="l01752"></a>01752     <span class="keywordflow">if</span> (numVtxPerProcRecv[i]) {
<a name="l01753"></a>01753       neighbourProcRecv[k] = neighbourProc[i];
<a name="l01754"></a>01754       numVtxPerProcRecvRecv[k] = numVtxPerProcRecv[i];
<a name="l01755"></a>01755       k++;
<a name="l01756"></a>01756     }
<a name="l01757"></a>01757   }
<a name="l01758"></a>01758 
<a name="l01759"></a>01759   <span class="comment">/* set up memory for the incoming vertex data blocks */</span>
<a name="l01760"></a>01760   std::vector&lt;VertexPack&gt; vertex_pack_import(numVtxImport+10); <span class="comment">/* add 10 to have enough memory */</span>
<a name="l01761"></a>01761   std::vector&lt;VertexPack*&gt; packed_vertices_import(num_neighbourProcRecv);
<a name="l01762"></a>01762   <span class="keywordflow">if</span> (neighbourProc.size())
<a name="l01763"></a>01763     packed_vertices_import[0] = <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(vertex_pack_import);
<a name="l01764"></a>01764   <span class="keywordflow">for</span> (i = 1; i &lt; num_neighbourProcRecv; i++) {
<a name="l01765"></a>01765     packed_vertices_import[i] = packed_vertices_import[i-1] + numVtxPerProcRecvRecv[i-1];
<a name="l01766"></a>01766   }
<a name="l01767"></a>01767 
<a name="l01768"></a>01768   <span class="comment">/* receive from all processors that have something for us */</span>
<a name="l01769"></a>01769   std::vector&lt;MPI_Request&gt; request(num_neighbourProcRecv);
<a name="l01770"></a>01770   <span class="keywordflow">for</span> (j = 0; j &lt; num_neighbourProcRecv; j++) {
<a name="l01771"></a>01771     rval = MPI_Irecv(packed_vertices_import[j],
<a name="l01772"></a>01772               4*numVtxPerProcRecvRecv[j],
<a name="l01773"></a>01773               MPI_DOUBLE_PRECISION,
<a name="l01774"></a>01774               neighbourProcRecv[j],
<a name="l01775"></a>01775               <a class="code" href="ParallelHelper_8cpp.html#c5eb83026ccd0c22f641e74d3e19ff4a">VERTEX_BLOCK</a>+iteration,
<a name="l01776"></a>01776               (MPI_Comm)communicator,
<a name="l01777"></a>01777               &amp;(request[j]));
<a name="l01778"></a>01778     <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l01779"></a>01779     <span class="keywordflow">if</span> (0) {printf(<span class="stringliteral">"[%d]i%d Scheduling receipt of %d vertices to proc %d\n"</span>,rank,iteration,numVtxPerProcRecvRecv[j],neighbourProcRecv[j]); fflush(NULL);}
<a name="l01780"></a>01780   }
<a name="l01781"></a>01781 
<a name="l01782"></a>01782   <span class="comment">/* now send the data blocks */</span>
<a name="l01783"></a>01783 
<a name="l01784"></a>01784   std::vector&lt;MPI_Request&gt; requests_send(neighbourProc.size());
<a name="l01785"></a>01785   <span class="keywordflow">for</span> (j = 0; j &lt; (long)neighbourProc.size(); j++) {
<a name="l01786"></a>01786     <span class="keywordflow">if</span> (numVtxPerProcSend[j]) {
<a name="l01787"></a>01787       rval = MPI_Isend(packed_vertices_export[j], 
<a name="l01788"></a>01788                 4*numVtxPerProcSend[j],
<a name="l01789"></a>01789                 MPI_DOUBLE_PRECISION,
<a name="l01790"></a>01790                 neighbourProc[j],
<a name="l01791"></a>01791                 <a class="code" href="ParallelHelper_8cpp.html#c5eb83026ccd0c22f641e74d3e19ff4a">VERTEX_BLOCK</a>+iteration,
<a name="l01792"></a>01792                 (MPI_Comm)communicator,
<a name="l01793"></a>01793                 &amp;(requests_send[j]));
<a name="l01794"></a>01794       <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l01795"></a>01795       <span class="keywordflow">if</span> (0) {printf(<span class="stringliteral">"[%d]i%d Scheduling send of %d vertices to proc %d\n"</span>,rank,iteration,numVtxPerProcSend[j],neighbourProc[j]); fflush(NULL);}
<a name="l01796"></a>01796     } <span class="keywordflow">else</span> {
<a name="l01797"></a>01797       requests_send[j] = MPI_REQUEST_NULL;
<a name="l01798"></a>01798     }
<a name="l01799"></a>01799   }
<a name="l01800"></a>01800   
<a name="l01801"></a>01801   <span class="comment">/* process messages as they arrive */</span> 
<a name="l01802"></a>01802 
<a name="l01803"></a>01803   <span class="keywordtype">int</span> local_id;
<a name="l01804"></a>01804   <span class="keywordflow">for</span> (j = 0; j &lt; num_neighbourProcRecv; j++) {
<a name="l01805"></a>01805     rval = MPI_Waitany(num_neighbourProcRecv, <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(request), &amp;k, &amp;status);
<a name="l01806"></a>01806     <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l01807"></a>01807 
<a name="l01808"></a>01808     <span class="comment">/* unpack messages */</span>
<a name="l01809"></a>01809     proc = status.MPI_SOURCE;
<a name="l01810"></a>01810     <span class="keywordtype">int</span> count;
<a name="l01811"></a>01811     MPI_Get_count(&amp;status, MPI_INT, &amp;count);    
<a name="l01812"></a>01812     <span class="keywordflow">if</span> (0) printf(<span class="stringliteral">"[%d]i%d Received %d (%d) vertices from proc %d (%d)\n"</span>,rank,iteration,numVtxPerProcRecvRecv[k],count,neighbourProcRecv[k],proc); fflush(NULL);
<a name="l01813"></a>01813     <span class="keywordflow">for</span> (i = 0; i &lt; numVtxPerProcRecvRecv[k]; i++) {
<a name="l01814"></a>01814       local_id = vertex_map_find(vid_map, packed_vertices_import[k][i].glob_id, neighbourProcRecv[k]);
<a name="l01815"></a>01815       <span class="keywordflow">if</span> (local_id) {
<a name="l01816"></a>01816         <a class="code" href="classMesquite_1_1Vector3D.html">Mesquite::Vector3D</a> coordinates;
<a name="l01817"></a>01817         coordinates.<a class="code" href="classMesquite_1_1Vector3D.html#afd16f85e6d2ea346f8dbda034b61b85">set</a>(packed_vertices_import[k][i].x, packed_vertices_import[k][i].y, packed_vertices_import[k][i].z);
<a name="l01818"></a>01818         mesh-&gt;vertex_set_coordinates(part_vertices[local_id],coordinates,err);
<a name="l01819"></a>01819         <a class="code" href="group__error.html#g1d829e1f69c04186f0de4b50a99203c8">MSQ_ERRZERO</a>(err);
<a name="l01820"></a>01820         assert(part_smoothed_flag[local_id] == 0);
<a name="l01821"></a>01821         part_smoothed_flag[local_id] = 1;
<a name="l01822"></a>01822         <span class="keywordflow">if</span> (0) printf(<span class="stringliteral">"[%d]i%d updating vertex with global_id %d to %g %g %g \n"</span>, rank, iteration, (<span class="keywordtype">int</span>)(packed_vertices_import[k][i].glob_id), packed_vertices_import[k][i].x, packed_vertices_import[k][i].y, packed_vertices_import[k][i].z);
<a name="l01823"></a>01823       }
<a name="l01824"></a>01824       <span class="keywordflow">else</span> {
<a name="l01825"></a>01825         printf(<span class="stringliteral">"[%d]i%d vertex with gid %Zu and pid %d not in map\n"</span>,rank,iteration,packed_vertices_import[k][i].glob_id,neighbourProcRecv[k]);
<a name="l01826"></a>01826       }
<a name="l01827"></a>01827     }
<a name="l01828"></a>01828   }
<a name="l01829"></a>01829 
<a name="l01830"></a>01830   <span class="comment">/* all receives have completed. it is save to release the memory */</span>
<a name="l01831"></a>01831   <span class="comment">//free(vertex_pack_import);</span>
<a name="l01832"></a>01832   <span class="comment">/* wait until the sends have completed */</span>
<a name="l01833"></a>01833   std::vector&lt;MPI_Status&gt; stati(neighbourProc.size());
<a name="l01834"></a>01834   rval = MPI_Waitall(neighbourProc.size(), <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(requests_send), <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(stati));
<a name="l01835"></a>01835   <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l01836"></a>01836   <span class="comment">/* all sends have completed. it is save to release the memory */</span>
<a name="l01837"></a>01837   <span class="comment">//free(vertex_pack_export);</span>
<a name="l01838"></a>01838 
<a name="l01839"></a>01839   <span class="keywordflow">return</span> numVtxImport;
<a name="l01840"></a>01840 }
<a name="l01841"></a>01841 
<a name="l01842"></a>01842 <span class="keywordtype">int</span> ParallelHelperImpl::comm_smoothed_vtx_nb_no_all(MsqError&amp; err)
<a name="l01843"></a>01843 {
<a name="l01844"></a>01844   <span class="keywordtype">int</span> i,j,k, rval;
<a name="l01845"></a>01845 
<a name="l01846"></a>01846   <span class="comment">// printf("[%d] %d %d non blocking avoid reduce all\n",rank, iteration, pass);fflush(NULL);</span>
<a name="l01847"></a>01847 
<a name="l01848"></a>01848   <span class="comment">/* how many vertices will we receive */</span>
<a name="l01849"></a>01849 
<a name="l01850"></a>01850   std::vector&lt;int&gt; numVtxPerProcSend(neighbourProc.size(),0);
<a name="l01851"></a>01851   <span class="keywordflow">for</span> (i = 0; i &lt; num_exportVtx; i++) {
<a name="l01852"></a>01852     <span class="keywordflow">for</span> (j = 0; j &lt; (long)neighbourProc.size(); j++) {
<a name="l01853"></a>01853       <span class="keywordflow">if</span> (exportProc[i] == neighbourProc[j]) {
<a name="l01854"></a>01854         <span class="comment">/* increment count */</span>
<a name="l01855"></a>01855         numVtxPerProcSend[j]++;
<a name="l01856"></a>01856         <span class="comment">/* end loop */</span>
<a name="l01857"></a>01857         <span class="keywordflow">break</span>;
<a name="l01858"></a>01858       }
<a name="l01859"></a>01859     }
<a name="l01860"></a>01860     <span class="comment">/* assert loop did not end without finding processor */</span>
<a name="l01861"></a>01861     assert(j != (<span class="keywordtype">long</span>)neighbourProc.size());
<a name="l01862"></a>01862   }
<a name="l01863"></a>01863 
<a name="l01864"></a>01864   <span class="comment">/* tell each processor how many vertices to expect */</span>
<a name="l01865"></a>01865 
<a name="l01866"></a>01866   <span class="keywordflow">for</span> (j = 0; j &lt; (long)neighbourProc.size(); j++) {
<a name="l01867"></a>01867     <span class="keywordflow">if</span> (neighbourProcSendRemain[j]) {
<a name="l01868"></a>01868       assert(neighbourProcSendRemain[j] &gt;= numVtxPerProcSend[j]);
<a name="l01869"></a>01869       neighbourProcSendRemain[j] -= numVtxPerProcSend[j];
<a name="l01870"></a>01870     rval = MPI_Send(&amp;(numVtxPerProcSend[j]),
<a name="l01871"></a>01871              1,
<a name="l01872"></a>01872              MPI_INT,
<a name="l01873"></a>01873              neighbourProc[j],
<a name="l01874"></a>01874              <a class="code" href="ParallelHelper_8cpp.html#0b474ffa817926a5bbff5b51046fd45c">VERTEX_HEADER</a>+iteration,
<a name="l01875"></a>01875              (MPI_Comm)communicator);
<a name="l01876"></a>01876     <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l01877"></a>01877     <span class="comment">//    printf("[%d]i%d Announcing %d vertices to proc %d\n",rank,iteration,numVtxPerProcSend[j],neighbourProc[j]); fflush(NULL);</span>
<a name="l01878"></a>01878     }
<a name="l01879"></a>01879     <span class="keywordflow">else</span> {
<a name="l01880"></a>01880       assert(numVtxPerProcSend[j] == 0);
<a name="l01881"></a>01881     }
<a name="l01882"></a>01882   }
<a name="l01883"></a>01883 
<a name="l01884"></a>01884   <span class="comment">/* place vertex data going to the same processor into consecutive memory space */</span>
<a name="l01885"></a>01885   std::vector&lt;VertexPack&gt; vertex_pack_export(num_exportVtx+10); <span class="comment">/* add 10 to have enough memory */</span>
<a name="l01886"></a>01886   std::vector&lt;VertexPack*&gt; packed_vertices_export(neighbourProc.size());
<a name="l01887"></a>01887   <span class="keywordflow">if</span> (neighbourProc.size())
<a name="l01888"></a>01888     packed_vertices_export[0] = <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(vertex_pack_export);
<a name="l01889"></a>01889   <span class="keywordflow">for</span> (i = 1; i &lt; (long)neighbourProc.size(); i++) {
<a name="l01890"></a>01890     packed_vertices_export[i] = packed_vertices_export[i-1] + numVtxPerProcSend[i-1];
<a name="l01891"></a>01891   }
<a name="l01892"></a>01892 
<a name="l01893"></a>01893   std::vector&lt;int&gt; numVtxPerProcSendPACKED(neighbourProc.size(),0);
<a name="l01894"></a>01894   <span class="keywordflow">for</span> (i = 0; i &lt; num_exportVtx; i++) {
<a name="l01895"></a>01895     <span class="keywordflow">for</span> (j = 0; j &lt; (long)neighbourProc.size(); j++) {
<a name="l01896"></a>01896       <span class="keywordflow">if</span> (exportProc[i] == neighbourProc[j]) {
<a name="l01897"></a>01897         <a class="code" href="namespaceMesquite.html#57d4b3860b73386c6c87dd2ad6904cdd">VertexPack</a>* packing_vertex = packed_vertices_export[j] + numVtxPerProcSendPACKED[j];
<a name="l01898"></a>01898         numVtxPerProcSendPACKED[j]++;
<a name="l01899"></a>01899         <a class="code" href="classMesquite_1_1MsqVertex.html">Mesquite::MsqVertex</a> coordinates;
<a name="l01900"></a>01900         mesh-&gt;vertices_get_coordinates(&amp;part_vertices[exportVtxLIDs[i]],&amp;coordinates,1,err);
<a name="l01901"></a>01901         <a class="code" href="group__error.html#g1d829e1f69c04186f0de4b50a99203c8">MSQ_ERRZERO</a>(err);
<a name="l01902"></a>01902         packing_vertex-&gt;x = coordinates[0];
<a name="l01903"></a>01903         packing_vertex-&gt;y = coordinates[1];
<a name="l01904"></a>01904         packing_vertex-&gt;z = coordinates[2];
<a name="l01905"></a>01905         packing_vertex-&gt;glob_id = exportVtxGIDs[i];
<a name="l01906"></a>01906       }
<a name="l01907"></a>01907     }
<a name="l01908"></a>01908   }
<a name="l01909"></a>01909   <span class="comment">//delete [] numVtxPerProcSendPACKED;</span>
<a name="l01910"></a>01910 
<a name="l01911"></a>01911   <span class="comment">/* now ask each processor how many vertices to expect */</span>
<a name="l01912"></a>01912 
<a name="l01913"></a>01913   <span class="keywordtype">int</span> num;
<a name="l01914"></a>01914   <span class="keywordtype">int</span> proc;
<a name="l01915"></a>01915   <span class="keywordtype">int</span> numVtxImport = 0;
<a name="l01916"></a>01916   <span class="keywordtype">int</span> num_neighbourProcRecv = 0;
<a name="l01917"></a>01917   std::vector&lt;int&gt; numVtxPerProcRecv(neighbourProc.size(), 0);
<a name="l01918"></a>01918   MPI_Status status;
<a name="l01919"></a>01919 
<a name="l01920"></a>01920   <span class="keywordtype">int</span> num_neighbourProcRecvRemain = 0;
<a name="l01921"></a>01921   <span class="keywordflow">for</span> (j = 0; j &lt; (long)neighbourProc.size(); j++) {
<a name="l01922"></a>01922     <span class="keywordflow">if</span> (neighbourProcRecvRemain[j]) {
<a name="l01923"></a>01923       num_neighbourProcRecvRemain++;
<a name="l01924"></a>01924     }
<a name="l01925"></a>01925   }
<a name="l01926"></a>01926   <span class="keywordflow">for</span> (j = 0; j &lt; num_neighbourProcRecvRemain; j++) {
<a name="l01927"></a>01927     <span class="comment">/* get the vertex count for some processor */</span>
<a name="l01928"></a>01928     rval = MPI_Recv(&amp;num,              <span class="comment">/* message buffer */</span>
<a name="l01929"></a>01929              1,                 <span class="comment">/* one data item */</span>
<a name="l01930"></a>01930              MPI_INT,           <span class="comment">/* of type int */</span>
<a name="l01931"></a>01931              MPI_ANY_SOURCE,    <span class="comment">/* receive from any sender */</span>
<a name="l01932"></a>01932              <a class="code" href="ParallelHelper_8cpp.html#0b474ffa817926a5bbff5b51046fd45c">VERTEX_HEADER</a>+iteration,     <span class="comment">/* receive only VERTEX HEADERs from this iteration */</span>
<a name="l01933"></a>01933              (MPI_Comm)communicator,    <span class="comment">/* default communicator */</span>
<a name="l01934"></a>01934              &amp;status);          <span class="comment">/* info about the received message */</span>
<a name="l01935"></a>01935     <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l01936"></a>01936     proc = status.MPI_SOURCE;
<a name="l01937"></a>01937     <span class="comment">/* will we import vertices from this processor */</span>
<a name="l01938"></a>01938 
<a name="l01939"></a>01939     <span class="comment">//    printf("[%d]i%d Heard we will receive %d vertices from proc %d\n",rank,iteration,num,proc); fflush(NULL);</span>
<a name="l01940"></a>01940 
<a name="l01941"></a>01941     <span class="keywordflow">if</span> (num) {
<a name="l01942"></a>01942       <span class="comment">/* increase number of processors we will receive from */</span>
<a name="l01943"></a>01943       num_neighbourProcRecv++;
<a name="l01944"></a>01944       <span class="comment">/* add number of vertices we will receive to the import total */</span>
<a name="l01945"></a>01945       numVtxImport += num;
<a name="l01946"></a>01946     }
<a name="l01947"></a>01947     <span class="comment">/* find this processor in the list */</span>
<a name="l01948"></a>01948     <span class="keywordflow">for</span> (i = 0; i &lt; (long)neighbourProc.size(); i++) {
<a name="l01949"></a>01949       <span class="keywordflow">if</span> (neighbourProc[i] == proc) {
<a name="l01950"></a>01950         numVtxPerProcRecv[i] = num;
<a name="l01951"></a>01951         assert(neighbourProcRecvRemain[i] &gt;= num);
<a name="l01952"></a>01952         neighbourProcRecvRemain[i] -= num;
<a name="l01953"></a>01953         <span class="keywordflow">break</span>;
<a name="l01954"></a>01954       }
<a name="l01955"></a>01955     }
<a name="l01956"></a>01956     <span class="comment">/* assert loop did not end without finding processor */</span>
<a name="l01957"></a>01957     assert(i != (<span class="keywordtype">long</span>)neighbourProc.size());
<a name="l01958"></a>01958     <span class="keywordflow">if</span> (0) printf(<span class="stringliteral">"[%d]i%d Will receive %d vertices from proc %d\n"</span>,rank,iteration,num,proc); fflush(NULL);
<a name="l01959"></a>01959   }
<a name="l01960"></a>01960 
<a name="l01961"></a>01961   <span class="comment">/* create list of processors we receive from */</span>
<a name="l01962"></a>01962   std::vector&lt;int&gt; neighbourProcRecv(num_neighbourProcRecv);
<a name="l01963"></a>01963   std::vector&lt;int&gt; numVtxPerProcRecvRecv(num_neighbourProcRecv);
<a name="l01964"></a>01964   <span class="keywordflow">for</span> (i = 0, k = 0; i &lt; (long)neighbourProc.size(); i++) {
<a name="l01965"></a>01965     <span class="keywordflow">if</span> (0) printf(<span class="stringliteral">"[%d]i%d Will receive %d vertices from proc %d\n"</span>,rank,iteration,numVtxPerProcRecv[i],neighbourProc[i]); fflush(NULL);
<a name="l01966"></a>01966     <span class="keywordflow">if</span> (numVtxPerProcRecv[i]) {
<a name="l01967"></a>01967       neighbourProcRecv[k] = neighbourProc[i];
<a name="l01968"></a>01968       numVtxPerProcRecvRecv[k] = numVtxPerProcRecv[i];
<a name="l01969"></a>01969       k++;
<a name="l01970"></a>01970     }
<a name="l01971"></a>01971   }
<a name="l01972"></a>01972 
<a name="l01973"></a>01973   <span class="comment">/* set up memory for the incoming vertex data blocks */</span>
<a name="l01974"></a>01974   std::vector&lt;VertexPack&gt; vertex_pack_import(numVtxImport+10); <span class="comment">/* add 10 to have enough memory */</span>
<a name="l01975"></a>01975   std::vector&lt;VertexPack*&gt; packed_vertices_import(num_neighbourProcRecv);
<a name="l01976"></a>01976   <span class="keywordflow">if</span> (neighbourProc.size())
<a name="l01977"></a>01977     packed_vertices_import[0] = <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(vertex_pack_import);
<a name="l01978"></a>01978   <span class="keywordflow">for</span> (i = 1; i &lt; num_neighbourProcRecv; i++) {
<a name="l01979"></a>01979     packed_vertices_import[i] = packed_vertices_import[i-1] + numVtxPerProcRecvRecv[i-1];
<a name="l01980"></a>01980   }
<a name="l01981"></a>01981 
<a name="l01982"></a>01982   <span class="comment">/* receive from all processors that have something for us */</span>
<a name="l01983"></a>01983   std::vector&lt;MPI_Request&gt; request(num_neighbourProcRecv);
<a name="l01984"></a>01984   <span class="keywordflow">for</span> (j = 0; j &lt; num_neighbourProcRecv; j++) {
<a name="l01985"></a>01985     rval = MPI_Irecv(packed_vertices_import[j],
<a name="l01986"></a>01986               4*numVtxPerProcRecvRecv[j],
<a name="l01987"></a>01987               MPI_DOUBLE_PRECISION,
<a name="l01988"></a>01988               neighbourProcRecv[j],
<a name="l01989"></a>01989               <a class="code" href="ParallelHelper_8cpp.html#c5eb83026ccd0c22f641e74d3e19ff4a">VERTEX_BLOCK</a>+iteration,
<a name="l01990"></a>01990               (MPI_Comm)communicator,
<a name="l01991"></a>01991               &amp;(request[j]));
<a name="l01992"></a>01992     <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l01993"></a>01993     <span class="keywordflow">if</span> (0) {printf(<span class="stringliteral">"[%d]i%d Scheduling receipt of %d vertices to proc %d\n"</span>,rank,iteration,numVtxPerProcRecvRecv[j],neighbourProcRecv[j]); fflush(NULL);}
<a name="l01994"></a>01994   }
<a name="l01995"></a>01995 
<a name="l01996"></a>01996   <span class="comment">/* now send the data blocks */</span>
<a name="l01997"></a>01997 
<a name="l01998"></a>01998   std::vector&lt;MPI_Request&gt; requests_send(neighbourProc.size());
<a name="l01999"></a>01999   <span class="keywordflow">for</span> (j = 0; j &lt; (long)neighbourProc.size(); j++) {
<a name="l02000"></a>02000     <span class="keywordflow">if</span> (numVtxPerProcSend[j]) {
<a name="l02001"></a>02001       rval = MPI_Isend(packed_vertices_export[j], 
<a name="l02002"></a>02002                 4*numVtxPerProcSend[j],
<a name="l02003"></a>02003                 MPI_DOUBLE_PRECISION,
<a name="l02004"></a>02004                 neighbourProc[j],
<a name="l02005"></a>02005                 <a class="code" href="ParallelHelper_8cpp.html#c5eb83026ccd0c22f641e74d3e19ff4a">VERTEX_BLOCK</a>+iteration,
<a name="l02006"></a>02006                 (MPI_Comm)communicator,
<a name="l02007"></a>02007                 &amp;(requests_send[j]));
<a name="l02008"></a>02008       <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l02009"></a>02009       <span class="keywordflow">if</span> (0) {printf(<span class="stringliteral">"[%d]i%d Scheduling send of %d vertices to proc %d\n"</span>,rank,iteration,numVtxPerProcSend[j],neighbourProc[j]); fflush(NULL);}
<a name="l02010"></a>02010     } <span class="keywordflow">else</span> {
<a name="l02011"></a>02011       requests_send[j] = MPI_REQUEST_NULL;
<a name="l02012"></a>02012     }
<a name="l02013"></a>02013   }
<a name="l02014"></a>02014   
<a name="l02015"></a>02015   <span class="comment">/* process messages as they arrive */</span> 
<a name="l02016"></a>02016 
<a name="l02017"></a>02017   <span class="keywordtype">int</span> local_id;
<a name="l02018"></a>02018   <span class="keywordflow">for</span> (j = 0; j &lt; num_neighbourProcRecv; j++) {
<a name="l02019"></a>02019     rval = MPI_Waitany(num_neighbourProcRecv, <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(request), &amp;k, &amp;status);
<a name="l02020"></a>02020     <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l02021"></a>02021 
<a name="l02022"></a>02022     <span class="comment">/* unpack messages */</span>
<a name="l02023"></a>02023     proc = status.MPI_SOURCE;
<a name="l02024"></a>02024     <span class="keywordtype">int</span> count;
<a name="l02025"></a>02025     MPI_Get_count(&amp;status, MPI_INT, &amp;count);    
<a name="l02026"></a>02026     <span class="keywordflow">if</span> (0) printf(<span class="stringliteral">"[%d]i%d Received %d (%d) vertices from proc %d (%d)\n"</span>,rank,iteration,numVtxPerProcRecvRecv[k],count,neighbourProcRecv[k],proc); fflush(NULL);
<a name="l02027"></a>02027     <span class="keywordflow">for</span> (i = 0; i &lt; numVtxPerProcRecvRecv[k]; i++) {
<a name="l02028"></a>02028       local_id = vertex_map_find(vid_map,packed_vertices_import[k][i].glob_id, neighbourProcRecv[k]);
<a name="l02029"></a>02029       <span class="keywordflow">if</span> (local_id) {
<a name="l02030"></a>02030         <a class="code" href="classMesquite_1_1Vector3D.html">Mesquite::Vector3D</a> coordinates;
<a name="l02031"></a>02031         coordinates.<a class="code" href="classMesquite_1_1Vector3D.html#afd16f85e6d2ea346f8dbda034b61b85">set</a>(packed_vertices_import[k][i].x, packed_vertices_import[k][i].y, packed_vertices_import[k][i].z);
<a name="l02032"></a>02032         mesh-&gt;vertex_set_coordinates(part_vertices[local_id],coordinates,err);
<a name="l02033"></a>02033         <a class="code" href="group__error.html#g1d829e1f69c04186f0de4b50a99203c8">MSQ_ERRZERO</a>(err);
<a name="l02034"></a>02034         assert(part_smoothed_flag[local_id] == 0);
<a name="l02035"></a>02035         part_smoothed_flag[local_id] = 1;
<a name="l02036"></a>02036         <span class="keywordflow">if</span> (0) printf(<span class="stringliteral">"[%d]i%d updating vertex with global_id %d to %g %g %g \n"</span>, rank, iteration, (<span class="keywordtype">int</span>)(packed_vertices_import[k][i].glob_id), packed_vertices_import[k][i].x, packed_vertices_import[k][i].y, packed_vertices_import[k][i].z);
<a name="l02037"></a>02037       }
<a name="l02038"></a>02038       <span class="keywordflow">else</span> {
<a name="l02039"></a>02039         printf(<span class="stringliteral">"[%d]i%d vertex with gid %Zu and pid %d not in map\n"</span>,rank,iteration,packed_vertices_import[k][i].glob_id,neighbourProcRecv[k]);  
<a name="l02040"></a>02040       }
<a name="l02041"></a>02041     }
<a name="l02042"></a>02042   }
<a name="l02043"></a>02043 
<a name="l02044"></a>02044   <span class="comment">/* all receives have completed. it is save to release the memory */</span>
<a name="l02045"></a>02045   <span class="comment">//free(vertex_pack_import);</span>
<a name="l02046"></a>02046   <span class="comment">/* wait until the sends have completed */</span>
<a name="l02047"></a>02047   std::vector&lt;MPI_Status&gt; stati(neighbourProc.size());
<a name="l02048"></a>02048   rval = MPI_Waitall(neighbourProc.size(), <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(requests_send), <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(stati));
<a name="l02049"></a>02049   <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l02050"></a>02050   <span class="comment">/* all sends have completed. it is save to release the memory */</span>
<a name="l02051"></a>02051   <span class="comment">//free(vertex_pack_export);</span>
<a name="l02052"></a>02052 
<a name="l02053"></a>02053   <span class="keywordflow">return</span> numVtxImport;
<a name="l02054"></a>02054 }
<a name="l02055"></a>02055 
<a name="l02056"></a>02056 <span class="keywordtype">int</span> ParallelHelperImpl::comm_smoothed_vtx_b(MsqError&amp; err)
<a name="l02057"></a>02057 {
<a name="l02058"></a>02058   <span class="keywordtype">int</span> i,j, rval;
<a name="l02059"></a>02059 
<a name="l02060"></a>02060   <span class="comment">// printf("[%d] %d %d blocking\n",rank, iteration, pass);fflush(NULL);</span>
<a name="l02061"></a>02061 
<a name="l02062"></a>02062   <span class="comment">/* how many vertices per processor */</span>
<a name="l02063"></a>02063 
<a name="l02064"></a>02064   std::vector&lt;int&gt; numVtxPerProc(neighbourProc.size(),0);
<a name="l02065"></a>02065   <span class="keywordflow">for</span> (i = 0; i &lt; num_exportVtx; i++) {
<a name="l02066"></a>02066     <span class="keywordflow">for</span> (j = 0; j &lt; (long)neighbourProc.size(); j++) {
<a name="l02067"></a>02067       <span class="keywordflow">if</span> (exportProc[i] == neighbourProc[j]) {
<a name="l02068"></a>02068         <span class="comment">/* increment count */</span>
<a name="l02069"></a>02069         numVtxPerProc[j]++;
<a name="l02070"></a>02070         <span class="comment">/* end loop */</span>
<a name="l02071"></a>02071         <span class="keywordflow">break</span>;
<a name="l02072"></a>02072       }
<a name="l02073"></a>02073       <span class="comment">/* assert loop did not end without finding the processor */</span>
<a name="l02074"></a>02074       assert (j != (<span class="keywordtype">long</span>)neighbourProc.size());
<a name="l02075"></a>02075     }
<a name="l02076"></a>02076   }
<a name="l02077"></a>02077 
<a name="l02078"></a>02078   <span class="comment">/* place vertices going to the same processor into consecutive memory space */</span>
<a name="l02079"></a>02079 
<a name="l02080"></a>02080   std::vector&lt;VertexPack&gt; vertex_pack(num_exportVtx+10); <span class="comment">/* add 10 to have enough memory */</span>
<a name="l02081"></a>02081   std::vector&lt;VertexPack*&gt; packed_vertices(neighbourProc.size());
<a name="l02082"></a>02082   <a class="code" href="namespaceMesquite.html#57d4b3860b73386c6c87dd2ad6904cdd">VertexPack</a>* packing_vertex;
<a name="l02083"></a>02083   packed_vertices[0] = <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(vertex_pack);
<a name="l02084"></a>02084   <span class="keywordflow">for</span> (i = 1; i &lt; (long)neighbourProc.size(); i++) {
<a name="l02085"></a>02085     packed_vertices[i] = packed_vertices[i-1] + numVtxPerProc[i-1];
<a name="l02086"></a>02086   }
<a name="l02087"></a>02087 
<a name="l02088"></a>02088   std::vector&lt;int&gt; numVtxPackedPerProc(neighbourProc.size(), 0);
<a name="l02089"></a>02089 
<a name="l02090"></a>02090   <span class="keywordflow">for</span> (i = 0; i &lt; num_exportVtx; i++) {
<a name="l02091"></a>02091     <span class="keywordflow">for</span> (j = 0; j &lt; (long)neighbourProc.size(); j++) {
<a name="l02092"></a>02092       <span class="keywordflow">if</span> (exportProc[i] == neighbourProc[j]) {
<a name="l02093"></a>02093         packing_vertex = packed_vertices[j] + numVtxPackedPerProc[j];
<a name="l02094"></a>02094         numVtxPackedPerProc[j]++;
<a name="l02095"></a>02095         <a class="code" href="classMesquite_1_1MsqVertex.html">Mesquite::MsqVertex</a> coordinates;
<a name="l02096"></a>02096         mesh-&gt;vertices_get_coordinates(&amp;part_vertices[exportVtxLIDs[i]],&amp;coordinates,1,err);
<a name="l02097"></a>02097         <a class="code" href="group__error.html#g1d829e1f69c04186f0de4b50a99203c8">MSQ_ERRZERO</a>(err);
<a name="l02098"></a>02098         packing_vertex-&gt;x = coordinates[0];
<a name="l02099"></a>02099         packing_vertex-&gt;<a class="code" href="classMesquite_1_1Vector3D.html#bf5d9808fec5e9ad927f5365b62ed360">y</a> = coordinates[1];
<a name="l02100"></a>02100         packing_vertex-&gt;<a class="code" href="classMesquite_1_1Vector3D.html#7b3b39371c3c4c9590d3434a756ae17d">z</a> = coordinates[2];
<a name="l02101"></a>02101         packing_vertex-&gt;glob_id = exportVtxGIDs[i];
<a name="l02102"></a>02102       }
<a name="l02103"></a>02103     }
<a name="l02104"></a>02104   }
<a name="l02105"></a>02105 
<a name="l02106"></a>02106   <span class="comment">//delete [] numVtxPackedPerProc;</span>
<a name="l02107"></a>02107 
<a name="l02108"></a>02108   <span class="comment">/* send each block so the corresponding processor preceeded by the number of vertices */</span>
<a name="l02109"></a>02109   
<a name="l02110"></a>02110   <span class="keywordflow">for</span> (j = 0; j &lt; (long)neighbourProc.size(); j++) {
<a name="l02111"></a>02111 
<a name="l02112"></a>02112     <span class="comment">//    printf("[%d]i%dp%d Announcing %d vertices to proc %d\n",rank,iteration,pass,numVtxPerProc[j],neighbourProc[j]); fflush(NULL);</span>
<a name="l02113"></a>02113 
<a name="l02114"></a>02114     rval = MPI_Send(&amp;(numVtxPerProc[j]),
<a name="l02115"></a>02115              1,
<a name="l02116"></a>02116              MPI_INT,
<a name="l02117"></a>02117              neighbourProc[j],
<a name="l02118"></a>02118              <a class="code" href="ParallelHelper_8cpp.html#0b474ffa817926a5bbff5b51046fd45c">VERTEX_HEADER</a>+iteration,
<a name="l02119"></a>02119              (MPI_Comm)communicator);
<a name="l02120"></a>02120     <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l02121"></a>02121     <span class="comment">// printf("[%d]i%dp%d Sending %d vertices to proc %d\n",rank,iteration,pass,numVtxPerProc[j],neighbourProc[j]); fflush(NULL);</span>
<a name="l02122"></a>02122 
<a name="l02123"></a>02123     <span class="comment">/* is there any vertex data to be sent */</span>
<a name="l02124"></a>02124 
<a name="l02125"></a>02125     <span class="keywordflow">if</span> (numVtxPerProc[j]) {
<a name="l02126"></a>02126       rval = MPI_Send(packed_vertices[j],
<a name="l02127"></a>02127                4*numVtxPerProc[j],
<a name="l02128"></a>02128                MPI_DOUBLE_PRECISION,
<a name="l02129"></a>02129                neighbourProc[j],
<a name="l02130"></a>02130                <a class="code" href="ParallelHelper_8cpp.html#c5eb83026ccd0c22f641e74d3e19ff4a">VERTEX_BLOCK</a>+iteration,
<a name="l02131"></a>02131                (MPI_Comm)communicator);
<a name="l02132"></a>02132       <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l02133"></a>02133       <span class="comment">// printf("[%d]i%dp%d Sent %d vertices to proc %d\n",rank,iteration,pass,numVtxPerProc[j],neighbourProc[j]); fflush(NULL);</span>
<a name="l02134"></a>02134     }
<a name="l02135"></a>02135   }
<a name="l02136"></a>02136 
<a name="l02137"></a>02137   <span class="keywordtype">int</span> num;
<a name="l02138"></a>02138   <span class="keywordtype">int</span> proc;
<a name="l02139"></a>02139   <span class="keywordtype">int</span> tag;
<a name="l02140"></a>02140   <span class="keywordtype">int</span> count;
<a name="l02141"></a>02141   <span class="keywordtype">int</span> numVtxImport = 0;
<a name="l02142"></a>02142   MPI_Status status;
<a name="l02143"></a>02143   <span class="keywordtype">int</span> local_id;
<a name="l02144"></a>02144 
<a name="l02145"></a>02145   <span class="comment">//  printf("[%d]i%dp%d Waiting to receive vertices from %d processors ... \n",rank,iteration,pass,neighbourProc.size()); fflush(NULL);</span>
<a name="l02146"></a>02146 
<a name="l02147"></a>02147   <span class="comment">/* receiving blocks from other processors */</span>
<a name="l02148"></a>02148 
<a name="l02149"></a>02149   <span class="keywordflow">for</span> (j = 0; j &lt; (long)neighbourProc.size(); j++) {
<a name="l02150"></a>02150     rval = MPI_Recv(&amp;num,              <span class="comment">/* message buffer */</span>
<a name="l02151"></a>02151              1,                 <span class="comment">/* one data item */</span>
<a name="l02152"></a>02152              MPI_INT,           <span class="comment">/* of type int */</span>
<a name="l02153"></a>02153              MPI_ANY_SOURCE,    <span class="comment">/* receive from any sender */</span>
<a name="l02154"></a>02154              <a class="code" href="ParallelHelper_8cpp.html#0b474ffa817926a5bbff5b51046fd45c">VERTEX_HEADER</a>+iteration,     <span class="comment">/* receive only VERTEX HEADERs */</span>
<a name="l02155"></a>02155              (MPI_Comm)communicator,    <span class="comment">/* default communicator */</span>
<a name="l02156"></a>02156              &amp;status);          <span class="comment">/* info about the received message */</span>
<a name="l02157"></a>02157     <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l02158"></a>02158     proc = status.MPI_SOURCE;
<a name="l02159"></a>02159     tag = status.MPI_TAG;
<a name="l02160"></a>02160     MPI_Get_count(&amp;status, MPI_INT, &amp;count);
<a name="l02161"></a>02161 
<a name="l02162"></a>02162     <span class="comment">//    printf("[%d]i%dp%d Receiving %d vertices from proc %d/%d/%d\n",rank,iteration,pass,num,proc,tag,count); fflush(NULL);</span>
<a name="l02163"></a>02163 
<a name="l02164"></a>02164     <span class="comment">/* is there any vertex data to be received */</span>
<a name="l02165"></a>02165 
<a name="l02166"></a>02166     <span class="keywordflow">if</span> (num) {
<a name="l02167"></a>02167 
<a name="l02168"></a>02168       numVtxImport += num;
<a name="l02169"></a>02169 
<a name="l02170"></a>02170       <span class="comment">/* do we have enough space allocated */</span>
<a name="l02171"></a>02171 
<a name="l02172"></a>02172       <span class="keywordflow">if</span> (num_exportVtx + 10 &lt; num) {
<a name="l02173"></a>02173         <span class="comment">//if (vertex_pack) free(vertex_pack);</span>
<a name="l02174"></a>02174         num_exportVtx = num;
<a name="l02175"></a>02175         vertex_pack.resize(num_exportVtx+10);
<a name="l02176"></a>02176         <span class="comment">//vertex_pack = (VertexPack*)malloc(sizeof(VertexPack)*(num_exportVtx+10));</span>
<a name="l02177"></a>02177       }
<a name="l02178"></a>02178 
<a name="l02179"></a>02179       rval = MPI_Recv(<a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(vertex_pack),          <span class="comment">/* message buffer */</span>
<a name="l02180"></a>02180                4*num,                <span class="comment">/* num data's item with 4 doubles each */</span>
<a name="l02181"></a>02181                MPI_DOUBLE_PRECISION, <span class="comment">/* of type double */</span>
<a name="l02182"></a>02182                proc,                 <span class="comment">/* receive from this procesor only */</span>
<a name="l02183"></a>02183                <a class="code" href="ParallelHelper_8cpp.html#c5eb83026ccd0c22f641e74d3e19ff4a">VERTEX_BLOCK</a>+iteration,         <span class="comment">/* receive only VERTEX BLOCKs */</span>
<a name="l02184"></a>02184                (MPI_Comm)communicator,       <span class="comment">/* default communicator */</span>
<a name="l02185"></a>02185                &amp;status);             <span class="comment">/* info about the received message */</span>
<a name="l02186"></a>02186       <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l02187"></a>02187 
<a name="l02188"></a>02188       proc = status.MPI_SOURCE;
<a name="l02189"></a>02189       tag = status.MPI_TAG;
<a name="l02190"></a>02190       MPI_Get_count(&amp;status, MPI_DOUBLE_PRECISION, &amp;count);
<a name="l02191"></a>02191 
<a name="l02192"></a>02192       <span class="keywordflow">if</span> (count != 4*num) printf(<span class="stringliteral">"[%d]i%d WARNING: expected %d vertices = %d bytes from proc %d but only got %d bytes\n"</span>,rank,iteration,num,num*4,proc,count); fflush(NULL);
<a name="l02193"></a>02193 
<a name="l02194"></a>02194       <span class="comment">//      printf("[%d]i%d Received %d vertices from proc %d/%d/%d\n",rank,iteration,num,proc,tag,count); fflush(NULL);</span>
<a name="l02195"></a>02195 
<a name="l02196"></a>02196       <span class="comment">/* update the received vertices in our boundary mesh */</span>
<a name="l02197"></a>02197       <span class="keywordflow">for</span> (i = 0; i &lt; num; i++) {
<a name="l02198"></a>02198         <span class="comment">/*      printf("[%d]i%d updating vertex %d with global_id %d\n",rank,iteration,i,(int)(vertex_pack[i].glob_id)); fflush(NULL); */</span>
<a name="l02199"></a>02199         local_id = vertex_map_find(vid_map,(<span class="keywordtype">int</span>)(vertex_pack[i].glob_id), proc);
<a name="l02200"></a>02200         <span class="keywordflow">if</span> (local_id)
<a name="l02201"></a>02201         {
<a name="l02202"></a>02202           <a class="code" href="classMesquite_1_1Vector3D.html">Mesquite::Vector3D</a> coordinates;
<a name="l02203"></a>02203           coordinates.<a class="code" href="classMesquite_1_1Vector3D.html#afd16f85e6d2ea346f8dbda034b61b85">set</a>(vertex_pack[i].x, vertex_pack[i].y, vertex_pack[i].z);
<a name="l02204"></a>02204           mesh-&gt;vertex_set_coordinates(part_vertices[local_id],coordinates,err);
<a name="l02205"></a>02205           <a class="code" href="group__error.html#g1d829e1f69c04186f0de4b50a99203c8">MSQ_ERRZERO</a>(err);
<a name="l02206"></a>02206           assert(part_smoothed_flag[local_id] == 0);
<a name="l02207"></a>02207           part_smoothed_flag[local_id] = 1;
<a name="l02208"></a>02208           <span class="keywordflow">if</span> (0) printf(<span class="stringliteral">"[%d]i%d updating vertex with global_id %d to %g %g %g \n"</span>, rank,iteration, (<span class="keywordtype">int</span>)(vertex_pack[i].glob_id), vertex_pack[i].x, vertex_pack[i].y, vertex_pack[i].z);
<a name="l02209"></a>02209         }
<a name="l02210"></a>02210         <span class="keywordflow">else</span> {
<a name="l02211"></a>02211           printf(<span class="stringliteral">"[%d]i%d vertex with gid %Zu and pid %d not in map\n"</span>,rank,iteration,vertex_pack[i].glob_id,proc);
<a name="l02212"></a>02212         }
<a name="l02213"></a>02213       }
<a name="l02214"></a>02214     }
<a name="l02215"></a>02215   }
<a name="l02216"></a>02216   <span class="comment">//if (vertex_pack) free(vertex_pack);</span>
<a name="l02217"></a>02217 
<a name="l02218"></a>02218   <span class="keywordflow">return</span> numVtxImport;
<a name="l02219"></a>02219 }
<a name="l02220"></a>02220 
<a name="l02221"></a>02221 <span class="keywordtype">int</span> ParallelHelperImpl::comm_smoothed_vtx_b_no_all(MsqError&amp; err)
<a name="l02222"></a>02222 {
<a name="l02223"></a>02223   <span class="keywordtype">int</span> i,j, rval;
<a name="l02224"></a>02224 
<a name="l02225"></a>02225   <span class="comment">// printf("[%d] %d %d blocking avoid reduce all\n",rank, iteration, pass);fflush(NULL);</span>
<a name="l02226"></a>02226 
<a name="l02227"></a>02227   <span class="comment">/* how many vertices per processor */</span>
<a name="l02228"></a>02228 
<a name="l02229"></a>02229   std::vector&lt;int&gt; numVtxPerProc(neighbourProc.size(), 0);
<a name="l02230"></a>02230   <span class="keywordflow">for</span> (i = 0; i &lt; num_exportVtx; i++) {
<a name="l02231"></a>02231     <span class="keywordflow">for</span> (j = 0; j &lt; (long)neighbourProc.size(); j++) {
<a name="l02232"></a>02232       <span class="keywordflow">if</span> (exportProc[i] == neighbourProc[j]) {
<a name="l02233"></a>02233         <span class="comment">/* increment count */</span>
<a name="l02234"></a>02234         numVtxPerProc[j]++;
<a name="l02235"></a>02235         <span class="comment">/* end loop */</span>
<a name="l02236"></a>02236         <span class="keywordflow">break</span>;
<a name="l02237"></a>02237       }
<a name="l02238"></a>02238       <span class="comment">/* assert loop did not end without finding the processor */</span>
<a name="l02239"></a>02239       assert (j != (<span class="keywordtype">long</span>)neighbourProc.size());
<a name="l02240"></a>02240     }
<a name="l02241"></a>02241   }
<a name="l02242"></a>02242 
<a name="l02243"></a>02243   <span class="comment">/* place vertices going to the same processor into consecutive memory space */</span>
<a name="l02244"></a>02244 
<a name="l02245"></a>02245   std::vector&lt;VertexPack&gt; vertex_pack(num_exportVtx+10); <span class="comment">/* add 10 to have enough memory */</span>
<a name="l02246"></a>02246   std::vector&lt;VertexPack*&gt; packed_vertices(neighbourProc.size());
<a name="l02247"></a>02247   <a class="code" href="namespaceMesquite.html#57d4b3860b73386c6c87dd2ad6904cdd">VertexPack</a>* packing_vertex;
<a name="l02248"></a>02248   packed_vertices[0] = <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(vertex_pack);
<a name="l02249"></a>02249   <span class="keywordflow">for</span> (i = 1; i &lt; (long)neighbourProc.size(); i++) {
<a name="l02250"></a>02250     packed_vertices[i] = packed_vertices[i-1] + numVtxPerProc[i-1];
<a name="l02251"></a>02251   }
<a name="l02252"></a>02252 
<a name="l02253"></a>02253   std::vector&lt;int&gt; numVtxPackedPerProc(neighbourProc.size(),0);
<a name="l02254"></a>02254 
<a name="l02255"></a>02255   <span class="keywordflow">for</span> (i = 0; i &lt; num_exportVtx; i++) {
<a name="l02256"></a>02256     <span class="keywordflow">for</span> (j = 0; j &lt; (long)neighbourProc.size(); j++) {
<a name="l02257"></a>02257       <span class="keywordflow">if</span> (exportProc[i] == neighbourProc[j]) {
<a name="l02258"></a>02258         packing_vertex = packed_vertices[j] + numVtxPackedPerProc[j];
<a name="l02259"></a>02259         numVtxPackedPerProc[j]++;
<a name="l02260"></a>02260         <a class="code" href="classMesquite_1_1MsqVertex.html">Mesquite::MsqVertex</a> coordinates;
<a name="l02261"></a>02261         mesh-&gt;vertices_get_coordinates(&amp;part_vertices[exportVtxLIDs[i]],&amp;coordinates,1,err);
<a name="l02262"></a>02262         <a class="code" href="group__error.html#g1d829e1f69c04186f0de4b50a99203c8">MSQ_ERRZERO</a>(err);
<a name="l02263"></a>02263         packing_vertex-&gt;x = coordinates[0];
<a name="l02264"></a>02264         packing_vertex-&gt;<a class="code" href="classMesquite_1_1Vector3D.html#bf5d9808fec5e9ad927f5365b62ed360">y</a> = coordinates[1];
<a name="l02265"></a>02265         packing_vertex-&gt;<a class="code" href="classMesquite_1_1Vector3D.html#7b3b39371c3c4c9590d3434a756ae17d">z</a> = coordinates[2];
<a name="l02266"></a>02266         packing_vertex-&gt;glob_id = exportVtxGIDs[i];
<a name="l02267"></a>02267       }
<a name="l02268"></a>02268     }
<a name="l02269"></a>02269   }
<a name="l02270"></a>02270 
<a name="l02271"></a>02271   <span class="comment">//delete [] numVtxPackedPerProc;</span>
<a name="l02272"></a>02272 
<a name="l02273"></a>02273   <span class="comment">/* send each block so the corresponding processor preceeded by the number of vertices */</span>
<a name="l02274"></a>02274   
<a name="l02275"></a>02275   <span class="keywordflow">for</span> (j = 0; j &lt; (long)neighbourProc.size(); j++) {
<a name="l02276"></a>02276 
<a name="l02277"></a>02277     <span class="keywordflow">if</span> (neighbourProcSendRemain[j])
<a name="l02278"></a>02278     {
<a name="l02279"></a>02279       assert(neighbourProcSendRemain[j] &gt;= numVtxPerProc[j]);
<a name="l02280"></a>02280       neighbourProcSendRemain[j] -= numVtxPerProc[j];
<a name="l02281"></a>02281       
<a name="l02282"></a>02282       <span class="comment">// printf("[%d]i%dp%d Announcing %d vertices to proc %d\n",rank,iteration,pass,numVtxPerProc[j],neighbourProc[j]); fflush(NULL);</span>
<a name="l02283"></a>02283 
<a name="l02284"></a>02284       rval = MPI_Send(&amp;(numVtxPerProc[j]),
<a name="l02285"></a>02285                1,
<a name="l02286"></a>02286                MPI_INT,
<a name="l02287"></a>02287                neighbourProc[j],
<a name="l02288"></a>02288                <a class="code" href="ParallelHelper_8cpp.html#0b474ffa817926a5bbff5b51046fd45c">VERTEX_HEADER</a>+iteration,
<a name="l02289"></a>02289                (MPI_Comm)communicator);
<a name="l02290"></a>02290       <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l02291"></a>02291       
<a name="l02292"></a>02292       <span class="comment">// printf("[%d]i%dp%d Sending %d vertices to proc %d\n",rank,iteration,pass,numVtxPerProc[j],neighbourProc[j]); fflush(NULL);</span>
<a name="l02293"></a>02293 
<a name="l02294"></a>02294       <span class="comment">/* is there any vertex data to be sent */</span>
<a name="l02295"></a>02295       
<a name="l02296"></a>02296       <span class="keywordflow">if</span> (numVtxPerProc[j]) {
<a name="l02297"></a>02297         rval = MPI_Send(packed_vertices[j],
<a name="l02298"></a>02298                  4*numVtxPerProc[j],
<a name="l02299"></a>02299                  MPI_DOUBLE_PRECISION,
<a name="l02300"></a>02300                  neighbourProc[j],
<a name="l02301"></a>02301                  <a class="code" href="ParallelHelper_8cpp.html#c5eb83026ccd0c22f641e74d3e19ff4a">VERTEX_BLOCK</a>+iteration,
<a name="l02302"></a>02302                  (MPI_Comm)communicator);
<a name="l02303"></a>02303         <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l02304"></a>02304         
<a name="l02305"></a>02305         <span class="comment">// printf("[%d]i%dp%d Sent %d vertices to proc %d\n",rank,iteration,pass,numVtxPerProc[j],neighbourProc[j]); fflush(NULL);</span>
<a name="l02306"></a>02306       }
<a name="l02307"></a>02307     }
<a name="l02308"></a>02308     <span class="keywordflow">else</span>
<a name="l02309"></a>02309     {
<a name="l02310"></a>02310       <span class="comment">// printf("[%d]i%dp%d no longer sending to %d\n",rank,iteration,neighbourProc[j]); fflush(NULL);</span>
<a name="l02311"></a>02311     }
<a name="l02312"></a>02312   }
<a name="l02313"></a>02313 
<a name="l02314"></a>02314   <span class="keywordtype">int</span> num;
<a name="l02315"></a>02315   <span class="keywordtype">int</span> proc;
<a name="l02316"></a>02316   <span class="keywordtype">int</span> tag;
<a name="l02317"></a>02317   <span class="keywordtype">int</span> count;
<a name="l02318"></a>02318   <span class="keywordtype">int</span> numVtxImport = 0;
<a name="l02319"></a>02319   MPI_Status status;
<a name="l02320"></a>02320   <span class="keywordtype">int</span> local_id;
<a name="l02321"></a>02321 
<a name="l02322"></a>02322   <span class="comment">//  printf("[%d]i%dp%d Waiting to receive vertices from %d processors ... \n",rank,iteration,pass,neighbourProc.size()); fflush(NULL);</span>
<a name="l02323"></a>02323 
<a name="l02324"></a>02324   <span class="comment">/* receiving blocks in any order from other processors */</span>
<a name="l02325"></a>02325 
<a name="l02326"></a>02326   <span class="keywordtype">int</span> num_neighbourProcRecvRemain = 0;
<a name="l02327"></a>02327   <span class="keywordflow">for</span> (j = 0; j &lt; (long)neighbourProc.size(); j++) {
<a name="l02328"></a>02328     <span class="keywordflow">if</span> (neighbourProcRecvRemain[j]) {
<a name="l02329"></a>02329       num_neighbourProcRecvRemain++;
<a name="l02330"></a>02330     }
<a name="l02331"></a>02331   }
<a name="l02332"></a>02332   <span class="keywordflow">for</span> (j = 0; j &lt; num_neighbourProcRecvRemain; j++) {
<a name="l02333"></a>02333     rval = MPI_Recv(&amp;num,              <span class="comment">/* message buffer */</span>
<a name="l02334"></a>02334              1,                 <span class="comment">/* one data item */</span>
<a name="l02335"></a>02335              MPI_INT,           <span class="comment">/* of type int */</span>
<a name="l02336"></a>02336              MPI_ANY_SOURCE,    <span class="comment">/* receive from any sender */</span>
<a name="l02337"></a>02337              <a class="code" href="ParallelHelper_8cpp.html#0b474ffa817926a5bbff5b51046fd45c">VERTEX_HEADER</a>+iteration,     <span class="comment">/* receive only VERTEX HEADERs */</span>
<a name="l02338"></a>02338              (MPI_Comm)communicator,    <span class="comment">/* default communicator */</span>
<a name="l02339"></a>02339              &amp;status);          <span class="comment">/* info about the received message */</span>
<a name="l02340"></a>02340     <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l02341"></a>02341     proc = status.MPI_SOURCE;
<a name="l02342"></a>02342     tag = status.MPI_TAG;
<a name="l02343"></a>02343     MPI_Get_count(&amp;status, MPI_INT, &amp;count);
<a name="l02344"></a>02344 
<a name="l02345"></a>02345     <span class="comment">// printf("[%d]i%dp%d Receiving %d vertices from proc %d/%d/%d\n",rank,iteration,pass,num,proc,tag,count); fflush(NULL);</span>
<a name="l02346"></a>02346 
<a name="l02347"></a>02347     <span class="comment">/* is there any vertex data to be received */</span>
<a name="l02348"></a>02348 
<a name="l02349"></a>02349     <span class="keywordflow">if</span> (num) {
<a name="l02350"></a>02350 
<a name="l02351"></a>02351       numVtxImport += num;
<a name="l02352"></a>02352 
<a name="l02353"></a>02353       <span class="comment">/* do we have enough space allocated */</span>
<a name="l02354"></a>02354 
<a name="l02355"></a>02355       <span class="keywordflow">if</span> (num_exportVtx + 10 &lt; num) {
<a name="l02356"></a>02356         <span class="comment">//if (vertex_pack) free(vertex_pack);</span>
<a name="l02357"></a>02357         num_exportVtx = num;
<a name="l02358"></a>02358         <span class="comment">//vertex_pack = (VertexPack*)malloc(sizeof(VertexPack)*(num_exportVtx+10));</span>
<a name="l02359"></a>02359         vertex_pack.resize(num_exportVtx+10); 
<a name="l02360"></a>02360       }
<a name="l02361"></a>02361 
<a name="l02362"></a>02362       rval = MPI_Recv(<a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(vertex_pack),          <span class="comment">/* message buffer */</span>
<a name="l02363"></a>02363                4*num,                <span class="comment">/* num data's item with 4 doubles each */</span>
<a name="l02364"></a>02364                MPI_DOUBLE_PRECISION, <span class="comment">/* of type double */</span>
<a name="l02365"></a>02365                proc,                 <span class="comment">/* receive from this procesor only */</span>
<a name="l02366"></a>02366                <a class="code" href="ParallelHelper_8cpp.html#c5eb83026ccd0c22f641e74d3e19ff4a">VERTEX_BLOCK</a>+iteration,         <span class="comment">/* receive only VERTEX BLOCKs */</span>
<a name="l02367"></a>02367                (MPI_Comm)communicator,       <span class="comment">/* default communicator */</span>
<a name="l02368"></a>02368                &amp;status);             <span class="comment">/* info about the received message */</span>
<a name="l02369"></a>02369       <a class="code" href="ParallelHelper_8cpp.html#7466a946dea3c8b1728eed5c287866d4">CHECK_MPI_RZERO</a>( rval, err );
<a name="l02370"></a>02370 
<a name="l02371"></a>02371       proc = status.MPI_SOURCE;
<a name="l02372"></a>02372       tag = status.MPI_TAG;
<a name="l02373"></a>02373       MPI_Get_count(&amp;status, MPI_DOUBLE_PRECISION, &amp;count);
<a name="l02374"></a>02374 
<a name="l02375"></a>02375       <span class="keywordflow">if</span> (count != 4*num) printf(<span class="stringliteral">"[%d]i%d WARNING: expected %d vertices = %d bytes from proc %d but only got %d bytes\n"</span>,rank,iteration,num,num*4,proc,count); fflush(NULL);
<a name="l02376"></a>02376 
<a name="l02377"></a>02377       <span class="comment">// printf("[%d]i%d Received %d vertices from proc %d/%d/%d\n",rank,iteration,num,proc,tag,count); fflush(NULL);</span>
<a name="l02378"></a>02378 
<a name="l02379"></a>02379       <span class="comment">/* update the received vertices in our boundary mesh */</span>
<a name="l02380"></a>02380       <span class="keywordflow">for</span> (i = 0; i &lt; num; i++) {
<a name="l02381"></a>02381         <span class="comment">/*      printf("[%d]i%d updating vertex %d with global_id %d\n",rank,iteration,i,(int)(vertex_pack[i].glob_id)); fflush(NULL); */</span>
<a name="l02382"></a>02382         local_id = vertex_map_find(vid_map,(<span class="keywordtype">int</span>)(vertex_pack[i].glob_id), proc);
<a name="l02383"></a>02383         <span class="keywordflow">if</span> (local_id)
<a name="l02384"></a>02384         {
<a name="l02385"></a>02385           <a class="code" href="classMesquite_1_1Vector3D.html">Mesquite::Vector3D</a> coordinates;
<a name="l02386"></a>02386           coordinates.<a class="code" href="classMesquite_1_1Vector3D.html#afd16f85e6d2ea346f8dbda034b61b85">set</a>(vertex_pack[i].x, vertex_pack[i].y, vertex_pack[i].z);
<a name="l02387"></a>02387           mesh-&gt;vertex_set_coordinates(part_vertices[local_id],coordinates,err);
<a name="l02388"></a>02388           <a class="code" href="group__error.html#g1d829e1f69c04186f0de4b50a99203c8">MSQ_ERRZERO</a>(err);
<a name="l02389"></a>02389           assert(part_smoothed_flag[local_id] == 0);
<a name="l02390"></a>02390           part_smoothed_flag[local_id] = 1;
<a name="l02391"></a>02391           <span class="keywordflow">if</span> (0 &amp;&amp; rank == 1) printf(<span class="stringliteral">"[%d]i%d updating vertex with global_id %d to %g %g %g \n"</span>, rank,iteration, (<span class="keywordtype">int</span>)(vertex_pack[i].glob_id), vertex_pack[i].x, vertex_pack[i].y, vertex_pack[i].z);
<a name="l02392"></a>02392         }
<a name="l02393"></a>02393         <span class="keywordflow">else</span> {
<a name="l02394"></a>02394           printf(<span class="stringliteral">"[%d]i%d vertex with gid %Zu and pid %d not in map\n"</span>,rank,iteration,vertex_pack[i].glob_id,proc);
<a name="l02395"></a>02395         }
<a name="l02396"></a>02396       }
<a name="l02397"></a>02397     }
<a name="l02398"></a>02398     <span class="keywordflow">for</span> (i = 0; i &lt; (long)neighbourProc.size(); i++) {
<a name="l02399"></a>02399       <span class="keywordflow">if</span> (proc == neighbourProc[i]) {
<a name="l02400"></a>02400         assert(neighbourProcRecvRemain[i] &gt;= num);
<a name="l02401"></a>02401         neighbourProcRecvRemain[i] -= num;
<a name="l02402"></a>02402         <span class="keywordflow">break</span>;
<a name="l02403"></a>02403       }
<a name="l02404"></a>02404     }
<a name="l02405"></a>02405   }
<a name="l02406"></a>02406   <span class="comment">//if (vertex_pack) free(vertex_pack);</span>
<a name="l02407"></a>02407 
<a name="l02408"></a>02408   <span class="keywordflow">return</span> numVtxImport;
<a name="l02409"></a>02409 }
<a name="l02410"></a>02410 
<a name="l02411"></a>02411 <span class="comment">/***********************************************************************</span>
<a name="l02412"></a>02412 <span class="comment">COMPUTING THE INDEPENDENT SET AND EXPORT INFORMATION</span>
<a name="l02413"></a>02413 <span class="comment">***********************************************************************/</span>
<a name="l02414"></a>02414 <span class="comment">/* the only thing that can prevent a vertex from being in the independent</span>
<a name="l02415"></a>02415 <span class="comment">   set is that is has an neighbouring vertex on a different processor that</span>
<a name="l02416"></a>02416 <span class="comment">   has not been smoothed yet and that has a larger random number */</span>
<a name="l02417"></a>02417 
<a name="l02418"></a>02418 <span class="keywordtype">void</span> ParallelHelperImpl::compute_independent_set()
<a name="l02419"></a>02419 {
<a name="l02420"></a>02420   <span class="keywordtype">int</span> i,j,k,l;
<a name="l02421"></a>02421   <span class="keywordtype">int</span> incident_vtx;
<a name="l02422"></a>02422   <span class="keywordtype">bool</span> done;
<a name="l02423"></a>02423 
<a name="l02424"></a>02424   <span class="keywordflow">for</span> (i=0;i&lt;num_vtx_partition_boundary_local;i++) in_independent_set[i] = <span class="keyword">false</span>;
<a name="l02425"></a>02425 
<a name="l02426"></a>02426   <span class="keywordtype">bool</span> found_more = <span class="keyword">true</span>;
<a name="l02427"></a>02427   <span class="keywordtype">int</span> found_iter = 0;
<a name="l02428"></a>02428 
<a name="l02429"></a>02429   num_exportVtx = 0;
<a name="l02430"></a>02430 
<a name="l02431"></a>02431   <span class="keywordflow">while</span> (found_more)
<a name="l02432"></a>02432   {  
<a name="l02433"></a>02433     found_iter++;
<a name="l02434"></a>02434     found_more = <span class="keyword">false</span>;
<a name="l02435"></a>02435     <span class="keywordflow">for</span> (i=0;i&lt;num_vtx_partition_boundary_local;i++) {
<a name="l02436"></a>02436       <span class="comment">/* if this vertex could become part of the independent set */</span>
<a name="l02437"></a>02437       <span class="keywordflow">if</span> (part_smoothed_flag[i] == 0 &amp;&amp; in_independent_set[i] == <span class="keyword">false</span>) {
<a name="l02438"></a>02438         <span class="comment">/* assume it's in the independent set */</span>
<a name="l02439"></a>02439         done = <span class="keyword">false</span>;
<a name="l02440"></a>02440         <span class="comment">/* then loop over the neighbors it has on other processors */</span>
<a name="l02441"></a>02441         <span class="keywordflow">for</span> (j = 0; !done &amp;&amp; j &lt; (long)vtx_off_proc_list[i].size(); j++) {
<a name="l02442"></a>02442           incident_vtx = vtx_off_proc_list[i][j];
<a name="l02443"></a>02443           <span class="comment">/* if this neighbour has not yet been smoothed and is not covered and ... */</span>
<a name="l02444"></a>02444           <span class="keywordflow">if</span> ( part_smoothed_flag[incident_vtx] == 0 ) {
<a name="l02445"></a>02445             <span class="comment">/* ... has a higher rand_number than me */</span>
<a name="l02446"></a>02446             <span class="keywordflow">if</span> ( part_rand_number[i] &lt; part_rand_number[incident_vtx] ) {
<a name="l02447"></a>02447               <span class="comment">/* then I am not in the independent set */</span>
<a name="l02448"></a>02448               done = <span class="keyword">true</span>;
<a name="l02449"></a>02449               <span class="keywordflow">break</span>;
<a name="l02450"></a>02450             }
<a name="l02451"></a>02451             <span class="comment">/* ... or has the same rand_number than me but a higher processor id */</span>
<a name="l02452"></a>02452             <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ( part_rand_number[i] == part_rand_number[incident_vtx] ) &amp;&amp; ( rank &lt; part_proc_owner[incident_vtx] ) ) {
<a name="l02453"></a>02453               <span class="comment">/* then I am not in the independent set */</span>
<a name="l02454"></a>02454               done = <span class="keyword">true</span>;
<a name="l02455"></a>02455               <span class="keywordflow">break</span>;
<a name="l02456"></a>02456             }
<a name="l02457"></a>02457           }
<a name="l02458"></a>02458         }
<a name="l02459"></a>02459         <span class="comment">/* if the vertex is in the independent set, add it to the export list */</span>
<a name="l02460"></a>02460         <span class="keywordflow">if</span> (!done) {
<a name="l02461"></a>02461           found_more = <span class="keyword">true</span>;
<a name="l02462"></a>02462           <span class="comment">//    if (found_iter &gt; 1) printf("[%d]i%d found another one %d in iteration %d\n",rank,iteration,i, found_iter);</span>
<a name="l02463"></a>02463           in_independent_set[i] = <span class="keyword">true</span>;
<a name="l02464"></a>02464           <span class="comment">/* mark vertices with lower random numbers as covered */</span>
<a name="l02465"></a>02465           <span class="keywordflow">for</span> (j = 0; j &lt; (long)vtx_off_proc_list[i].size(); j++) {
<a name="l02466"></a>02466             incident_vtx = vtx_off_proc_list[i][j];
<a name="l02467"></a>02467             <span class="comment">/* if this neighbour has not yet been smoothed or covered mark it as covered */</span>
<a name="l02468"></a>02468             <span class="keywordflow">if</span> ( part_smoothed_flag[incident_vtx] == 0 ) {
<a name="l02469"></a>02469               part_smoothed_flag[incident_vtx] = 2;
<a name="l02470"></a>02470             }
<a name="l02471"></a>02471           }
<a name="l02472"></a>02472           k = num_exportVtx;
<a name="l02473"></a>02473           <span class="comment">/* then loop over the neighbors it has on other processors */</span>
<a name="l02474"></a>02474           <span class="keywordflow">for</span> (j = 0; j &lt; (long)vtx_off_proc_list[i].size(); j++) {
<a name="l02475"></a>02475             incident_vtx = vtx_off_proc_list[i][j];
<a name="l02476"></a>02476             <span class="comment">/* check to see if this processor already on the list */</span>
<a name="l02477"></a>02477             done = <span class="keyword">false</span>;
<a name="l02478"></a>02478             <span class="keywordflow">for</span> (l=k; l &lt; num_exportVtx &amp;&amp; !done; l++) {
<a name="l02479"></a>02479               <span class="keywordflow">if</span>  (exportProc[l] == part_proc_owner[incident_vtx]) {
<a name="l02480"></a>02480                 done = <span class="keyword">true</span>;
<a name="l02481"></a>02481               }
<a name="l02482"></a>02482             }
<a name="l02483"></a>02483             <span class="comment">/* if it's not on the list add it */</span>
<a name="l02484"></a>02484             <span class="keywordflow">if</span> (!done) {
<a name="l02485"></a>02485               exportVtxLIDs[num_exportVtx] = i;
<a name="l02486"></a>02486               exportVtxGIDs[num_exportVtx] = part_gid[i];
<a name="l02487"></a>02487               exportProc[num_exportVtx] = part_proc_owner[incident_vtx];
<a name="l02488"></a>02488               num_exportVtx++;
<a name="l02489"></a>02489             }
<a name="l02490"></a>02490           }
<a name="l02491"></a>02491         }
<a name="l02492"></a>02492       }
<a name="l02493"></a>02493     }
<a name="l02494"></a>02494   }
<a name="l02495"></a>02495   
<a name="l02496"></a>02496   <span class="keywordflow">if</span> (0)
<a name="l02497"></a>02497   {
<a name="l02498"></a>02498     <span class="keywordtype">int</span> in_set  = 0;
<a name="l02499"></a>02499     <span class="keywordflow">for</span> (i=0;i&lt;num_vtx_partition_boundary_local;i++) <span class="keywordflow">if</span> (in_independent_set[i]) in_set++;;
<a name="l02500"></a>02500     printf(<span class="stringliteral">"[%d]i%d independent set has %d of %d vertices sent out %d times\n"</span>,rank,iteration, in_set, num_vtx_partition_boundary_local, num_exportVtx);
<a name="l02501"></a>02501     fflush(NULL);
<a name="l02502"></a>02502   }
<a name="l02503"></a>02503 
<a name="l02504"></a>02504   <span class="comment">/* unmark the vertices that have been marked as covered */</span>
<a name="l02505"></a>02505   <span class="keywordflow">for</span> (i=num_vtx_partition_boundary_local; i&lt;num_vtx_partition_boundary; i++) <span class="keywordflow">if</span> (part_smoothed_flag[i] == 2) part_smoothed_flag[i] = 0;
<a name="l02506"></a>02506 }
<a name="l02507"></a>02507 
<a name="l02508"></a><a class="code" href="classMesquite_1_1ParallelHelperImpl.html#f9b722c9c09d1e21287091dfd7d24488">02508</a> <span class="keywordtype">int</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#f9b722c9c09d1e21287091dfd7d24488">ParallelHelperImpl::get_rank</a>()<span class="keyword"> const </span>{
<a name="l02509"></a>02509   <span class="keywordflow">return</span> rank;
<a name="l02510"></a>02510 }
<a name="l02511"></a>02511 
<a name="l02512"></a><a class="code" href="classMesquite_1_1ParallelHelperImpl.html#55a88fe6168cc9f157e7e20a7cb30bd9">02512</a> <span class="keywordtype">int</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#55a88fe6168cc9f157e7e20a7cb30bd9">ParallelHelperImpl::get_nprocs</a>()<span class="keyword"> const </span>{
<a name="l02513"></a>02513   <span class="keywordflow">return</span> nprocs;
<a name="l02514"></a>02514 }
<a name="l02515"></a>02515 
<a name="l02516"></a><a class="code" href="classMesquite_1_1ParallelHelperImpl.html#70cef5af6cb1fea97b136f34dda821ac">02516</a> <span class="keywordtype">bool</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#70cef5af6cb1fea97b136f34dda821ac">ParallelHelperImpl::is_our_element</a>(<a class="code" href="classMesquite_1_1Mesh.html#7b36dc5feec166efeed124cf173284db">Mesquite::Mesh::ElementHandle</a> element_handle,
<a name="l02517"></a>02517                                         <a class="code" href="classMesquite_1_1MsqError.html">MsqError</a>&amp; err)<span class="keyword"> const </span>{
<a name="l02518"></a>02518   <span class="keywordtype">int</span> i;
<a name="l02519"></a>02519   std::vector&lt;Mesh::VertexHandle&gt; vertices;
<a name="l02520"></a>02520   std::vector&lt;size_t&gt; junk;
<a name="l02521"></a>02521   mesh-&gt;<a class="code" href="classMesquite_1_1Mesh.html#fd0dab3edfb6d7570a08f4cb5aa295ef">elements_get_attached_vertices</a>(&amp;element_handle, 1, vertices, junk, err);
<a name="l02522"></a>02522   <a class="code" href="group__error.html#g1d829e1f69c04186f0de4b50a99203c8">MSQ_ERRZERO</a>(err);
<a name="l02523"></a>02523   <span class="keywordtype">int</span> num_verts = vertices.size();
<a name="l02524"></a>02524   std::vector&lt;int&gt; proc_ids(num_verts);
<a name="l02525"></a>02525   mesh-&gt;<a class="code" href="classMesquite_1_1ParallelMesh.html#ab8227ceb6ea93ee139ac2748e6e98cd">vertices_get_processor_id</a>(<a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(vertices), <a class="code" href="ParallelHelper_8cpp.html#f226a1569df0012e8c4fbae09105c6f8">ARRPTR</a>(proc_ids), num_verts, err);
<a name="l02526"></a>02526   <a class="code" href="group__error.html#g1d829e1f69c04186f0de4b50a99203c8">MSQ_ERRZERO</a>(err);
<a name="l02527"></a>02527   <span class="keywordtype">int</span> max_proc_id = proc_ids[0];
<a name="l02528"></a>02528   <span class="keywordflow">for</span> (i = 1; i &lt; num_verts; i++)
<a name="l02529"></a>02529     <span class="keywordflow">if</span> (max_proc_id &lt; proc_ids[i]) max_proc_id = proc_ids[i];
<a name="l02530"></a>02530   <span class="keywordflow">return</span> (max_proc_id == rank);
<a name="l02531"></a>02531 }
<a name="l02532"></a>02532 
<a name="l02533"></a><a class="code" href="classMesquite_1_1ParallelHelperImpl.html#ceba4278d12cd4395a3cfd9b8ca43831">02533</a> <span class="keywordtype">bool</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#ceba4278d12cd4395a3cfd9b8ca43831">ParallelHelperImpl::is_our_vertex</a>(<a class="code" href="classMesquite_1_1Mesh.html#9d765053bc19100f1de05d87d4222777">Mesquite::Mesh::VertexHandle</a> vertex_handle,
<a name="l02534"></a>02534                                        <a class="code" href="classMesquite_1_1MsqError.html">MsqError</a>&amp; err)<span class="keyword"> const </span>{
<a name="l02535"></a>02535   <span class="keywordtype">int</span> proc_id;
<a name="l02536"></a>02536   mesh-&gt;<a class="code" href="classMesquite_1_1ParallelMesh.html#ab8227ceb6ea93ee139ac2748e6e98cd">vertices_get_processor_id</a>(&amp;vertex_handle, &amp;proc_id, 1, err);
<a name="l02537"></a>02537   <span class="keywordflow">return</span> !<a class="code" href="group__error.html#g89169bf923bf910753638052db433a22">MSQ_CHKERR</a>(err) &amp;&amp; (proc_id == rank);
<a name="l02538"></a>02538 }
<a name="l02539"></a>02539 
<a name="l02540"></a><a class="code" href="classMesquite_1_1ParallelHelperImpl.html#0f37131d4304bacf5c130749fc076f30">02540</a> <span class="keywordtype">void</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#0f37131d4304bacf5c130749fc076f30">ParallelHelperImpl::communicate_min_max_to_all</a>(<span class="keywordtype">double</span>* minimum, 
<a name="l02541"></a>02541                                                     <span class="keywordtype">double</span>* maximum, 
<a name="l02542"></a>02542                                                     <a class="code" href="classMesquite_1_1MsqError.html">MsqError</a>&amp; err)<span class="keyword"> const </span>{
<a name="l02543"></a>02543   <span class="keywordtype">double</span> d_min[2];
<a name="l02544"></a>02544   <span class="keywordtype">double</span> d_min_recv[2];
<a name="l02545"></a>02545   d_min[0] = -(*maximum);
<a name="l02546"></a>02546   d_min[1] = *minimum;
<a name="l02547"></a>02547   <span class="keywordtype">int</span> rval = MPI_Allreduce(d_min, d_min_recv, 2, MPI_DOUBLE, MPI_MIN, (MPI_Comm)communicator);
<a name="l02548"></a>02548   <a class="code" href="ParallelHelper_8cpp.html#78b12d3996624c2282598c84cabf1874">CHECK_MPI</a>( rval, err );
<a name="l02549"></a>02549   *maximum = -d_min_recv[0];
<a name="l02550"></a>02550   *minimum =  d_min_recv[1];
<a name="l02551"></a>02551 }
<a name="l02552"></a>02552 
<a name="l02553"></a><a class="code" href="classMesquite_1_1ParallelHelperImpl.html#03dcf40c1572d18dd709d33e3e06aef7">02553</a> <span class="keywordtype">void</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#03dcf40c1572d18dd709d33e3e06aef7">ParallelHelperImpl::communicate_min_max_to_zero</a>(<span class="keywordtype">double</span>* minimum, 
<a name="l02554"></a>02554                                                      <span class="keywordtype">double</span>* maximum, 
<a name="l02555"></a>02555                                                      <a class="code" href="classMesquite_1_1MsqError.html">MsqError</a>&amp; err)<span class="keyword"> const </span>{
<a name="l02556"></a>02556   <span class="keywordtype">double</span> d_min[2];
<a name="l02557"></a>02557   <span class="keywordtype">double</span> d_min_recv[2];
<a name="l02558"></a>02558   d_min[0] = -(*maximum);
<a name="l02559"></a>02559   d_min[1] = *minimum;
<a name="l02560"></a>02560   <span class="keywordtype">int</span> rval = MPI_Reduce(d_min, d_min_recv, 2, MPI_DOUBLE, MPI_MIN, 0, (MPI_Comm)communicator);
<a name="l02561"></a>02561   <a class="code" href="ParallelHelper_8cpp.html#78b12d3996624c2282598c84cabf1874">CHECK_MPI</a>( rval, err );
<a name="l02562"></a>02562   <span class="keywordflow">if</span> (rank == 0) {
<a name="l02563"></a>02563     *maximum = -d_min_recv[0];
<a name="l02564"></a>02564     *minimum =  d_min_recv[1];
<a name="l02565"></a>02565   }
<a name="l02566"></a>02566 }
<a name="l02567"></a>02567 
<a name="l02568"></a><a class="code" href="classMesquite_1_1ParallelHelperImpl.html#a38f509b5c4887483b0b59711b5914db">02568</a> <span class="keywordtype">void</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#a38f509b5c4887483b0b59711b5914db">ParallelHelperImpl::communicate_sums_to_zero</a>(size_t* freeElementCount, 
<a name="l02569"></a>02569                                                   <span class="keywordtype">int</span>* invertedElementCount, 
<a name="l02570"></a>02570                                                   size_t* elementCount, 
<a name="l02571"></a>02571                                                   <span class="keywordtype">int</span>* invertedSampleCount, 
<a name="l02572"></a>02572                                                   size_t* sampleCount, 
<a name="l02573"></a>02573                                                   <span class="keywordtype">long</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* count, 
<a name="l02574"></a>02574                                                   <span class="keywordtype">long</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* invalid, 
<a name="l02575"></a>02575                                                   <span class="keywordtype">double</span>* sum, 
<a name="l02576"></a>02576                                                   <span class="keywordtype">double</span> *sqrSum, 
<a name="l02577"></a>02577                                                   <a class="code" href="classMesquite_1_1MsqError.html">MsqError</a>&amp; err)<span class="keyword"> const </span>{
<a name="l02578"></a>02578   <span class="keywordtype">double</span> d_sum[9];
<a name="l02579"></a>02579   <span class="keywordtype">double</span> d_sum_recv[9];
<a name="l02580"></a>02580 
<a name="l02581"></a>02581   d_sum[0] = (double)(*freeElementCount);
<a name="l02582"></a>02582   d_sum[1] = (double)(*invertedElementCount);
<a name="l02583"></a>02583   d_sum[2] = (double)(*elementCount);
<a name="l02584"></a>02584   d_sum[3] = (double)(*invertedSampleCount);
<a name="l02585"></a>02585   d_sum[4] = (double)(*sampleCount);
<a name="l02586"></a>02586   d_sum[5] = (double)(*count);
<a name="l02587"></a>02587   d_sum[6] = (double)(*invalid);
<a name="l02588"></a>02588   d_sum[7] = *sum;
<a name="l02589"></a>02589   d_sum[8] = *sqrSum;
<a name="l02590"></a>02590 
<a name="l02591"></a>02591   <span class="keywordtype">int</span> rval = MPI_Reduce(d_sum, d_sum_recv, 9, MPI_DOUBLE, MPI_SUM, 0, (MPI_Comm)communicator);
<a name="l02592"></a>02592   <a class="code" href="ParallelHelper_8cpp.html#78b12d3996624c2282598c84cabf1874">CHECK_MPI</a>( rval, err );
<a name="l02593"></a>02593 
<a name="l02594"></a>02594   <span class="keywordflow">if</span> (rank == 0) {
<a name="l02595"></a>02595     *freeElementCount = (size_t)d_sum_recv[0];
<a name="l02596"></a>02596     *invertedElementCount = (int)d_sum_recv[1];
<a name="l02597"></a>02597     *elementCount = (size_t)d_sum_recv[2];
<a name="l02598"></a>02598     *invertedSampleCount = (int)d_sum_recv[3];
<a name="l02599"></a>02599     *sampleCount = (size_t)d_sum_recv[4];
<a name="l02600"></a>02600     *count = (<span class="keywordtype">long</span> <span class="keywordtype">unsigned</span> int)d_sum_recv[5];
<a name="l02601"></a>02601     *invalid = (<span class="keywordtype">long</span> <span class="keywordtype">unsigned</span> int)d_sum_recv[6];
<a name="l02602"></a>02602     *sum = d_sum_recv[7];
<a name="l02603"></a>02603     *sqrSum = d_sum_recv[8];
<a name="l02604"></a>02604   }
<a name="l02605"></a>02605 }
<a name="l02606"></a>02606 
<a name="l02607"></a><a class="code" href="classMesquite_1_1ParallelHelperImpl.html#5d386907f0b8036c623a5b6621a94989">02607</a> <span class="keywordtype">void</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#5d386907f0b8036c623a5b6621a94989">ParallelHelperImpl::communicate_power_sum_to_zero</a>(<span class="keywordtype">double</span>* pMean, <a class="code" href="classMesquite_1_1MsqError.html">MsqError</a>&amp; err)<span class="keyword"> const</span>
<a name="l02608"></a>02608 <span class="keyword"></span>{
<a name="l02609"></a>02609   <span class="keywordtype">double</span> result;
<a name="l02610"></a>02610   <span class="keywordtype">int</span> rval = MPI_Reduce( pMean, &amp;result, 1, MPI_DOUBLE, MPI_SUM, 0, (MPI_Comm)communicator );
<a name="l02611"></a>02611   <a class="code" href="ParallelHelper_8cpp.html#78b12d3996624c2282598c84cabf1874">CHECK_MPI</a>( rval, err );
<a name="l02612"></a>02612   <span class="keywordflow">if</span> (rank == 0)
<a name="l02613"></a>02613     *pMean = result;
<a name="l02614"></a>02614 }
<a name="l02615"></a>02615 
<a name="l02616"></a><a class="code" href="classMesquite_1_1ParallelHelperImpl.html#7b9697090df39f02fee662b7206d1234">02616</a> <span class="keywordtype">void</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#7b9697090df39f02fee662b7206d1234">ParallelHelperImpl::communicate_histogram_to_zero</a>(std::vector&lt;int&gt; &amp;histogram, <a class="code" href="classMesquite_1_1MsqError.html">MsqError</a>&amp; err)<span class="keyword"> const </span>{
<a name="l02617"></a>02617   std::vector&lt;int&gt; histogram_recv(histogram.size());
<a name="l02618"></a>02618   <span class="keywordtype">int</span> rval = MPI_Reduce(&amp;(histogram[0]), &amp;(histogram_recv[0]), histogram.size(), MPI_INT, MPI_SUM, 0, (MPI_Comm)communicator);
<a name="l02619"></a>02619   <a class="code" href="ParallelHelper_8cpp.html#78b12d3996624c2282598c84cabf1874">CHECK_MPI</a>( rval, err );
<a name="l02620"></a>02620   <span class="keywordflow">if</span> (rank == 0) {
<a name="l02621"></a>02621     histogram.swap( histogram_recv );
<a name="l02622"></a>02622   }
<a name="l02623"></a>02623 }
<a name="l02624"></a>02624 
<a name="l02626"></a><a class="code" href="classMesquite_1_1ParallelHelperImpl.html#410d52447b0f31617518b62172b7462b">02626</a> <span class="keywordtype">void</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#410d52447b0f31617518b62172b7462b">ParallelHelperImpl::communicate_any_true</a>( <span class="keywordtype">bool</span>&amp; value, <a class="code" href="classMesquite_1_1MsqError.html">MsqError</a>&amp; err )<span class="keyword"> const</span>
<a name="l02627"></a>02627 <span class="keyword"></span>{
<a name="l02628"></a>02628   <span class="keywordtype">int</span> byte_out = value, byte_in;
<a name="l02629"></a>02629   <span class="keywordtype">int</span> rval = MPI_Allreduce( &amp;byte_out, &amp;byte_in, 1, MPI_INT, MPI_MAX, (MPI_Comm)communicator);
<a name="l02630"></a>02630   <a class="code" href="ParallelHelper_8cpp.html#78b12d3996624c2282598c84cabf1874">CHECK_MPI</a>( rval, err );
<a name="l02631"></a>02631   value = (byte_in != 0);
<a name="l02632"></a>02632 }
<a name="l02633"></a>02633 
<a name="l02636"></a>02636 
<a name="l02638"></a><a class="code" href="classMesquite_1_1ParallelHelperImpl.html#31daf0753d5da1a09c38c38cdb318c6e">02638</a> <span class="keywordtype">void</span> <a class="code" href="classMesquite_1_1ParallelHelperImpl.html#31daf0753d5da1a09c38c38cdb318c6e">ParallelHelperImpl::communicate_all_true</a>( <span class="keywordtype">bool</span>&amp; value, <a class="code" href="classMesquite_1_1MsqError.html">MsqError</a>&amp; err )<span class="keyword"> const</span>
<a name="l02639"></a>02639 <span class="keyword"></span>{
<a name="l02640"></a>02640   <span class="keywordtype">int</span> byte_out = value, byte_in;
<a name="l02641"></a>02641   <span class="keywordtype">int</span> rval = MPI_Allreduce( &amp;byte_out, &amp;byte_in, 1, MPI_INT, MPI_MIN, (MPI_Comm)communicator);
<a name="l02642"></a>02642   <a class="code" href="ParallelHelper_8cpp.html#78b12d3996624c2282598c84cabf1874">CHECK_MPI</a>( rval, err );
<a name="l02643"></a>02643   value = (byte_in != 0);
<a name="l02644"></a>02644 }
<a name="l02645"></a>02645 
<a name="l02646"></a>02646 } <span class="comment">// namespace mesquite</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu May 17 15:57:13 2012 for MESQUITE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
